## 新特性
- `auto` 声明
- 基于 range 的 `for` 循环
- _lambda_ 表达式
- 右值引用
- `0` 和 `typedef` 出局，`nullptr` 和别名声明新晋
- 枚举现在应该是限域的了
- 相比内置的指针类型，现在要更倾向去使用智能指针
- 移动对象通常也好过于拷贝它们

## 移动语义
最遍布C++11各处的特性可能是移动语义了，移动语义的基础是区分右值和左值表达式。那是因为右值表明这个对象适合移动操作，而左值一般不适合。概念上（尽管不经常在实际上用），右值对应于从函数返回的临时对象，而左值对应于你可以引用的（can refer to）对象，或者通过名字，或者通过指针或左值引用。
对于判断一个表达式是否是左值的一个有用的启发就是，看看能否取得它的地址。如果能取地址，那么通常就是左值。如果不能，则通常是右值。这个启发的好处就是帮你记住，一个表达式的类型与它是左值还是右值无关。也就是说，有个类型`T`，你可以有类型`T`的左值和右值。当你碰到右值引用类型的形参时，记住这一点非常重要，因为形参本身是个左值。
## 参数
在函数调用中，调用地传入的表达式称为函数的**实参**（_argument_）。实参被用来初始化函数的**形参**（_parameter_）。实参和形参的区别非常重要，因为形参是左值，而用来初始化形参的实参可能是左值或者右值。
## 异常安全
设计优良的函数是**异常安全**（_exception safe_）的，意味着他们至少提供基本的异常安全保证（即基本保证_basic guarantee_）。这样的函数保证调用者在异常抛出时，程序不变量保持完整（即没有数据结构是毁坏的），且没有资源泄漏。有强异常安全保证的函数确保调用者在异常产生时，程序保持在调用前的状态。
## 函数的**签名**

一个函数的**签名**（_signature_）为它声明的一部分，这个声明指定了形参类型和返回类型。函数名和形参名不是签名的一部分。在上面的例子中，`func`的签名是`bool(const Widget&)`。函数声明中除了形参类型和返回类型之外的元素（比如`noexcept`或者`constexpr`，如果存在的话）都被排除在外。
## **未定义的行为**
有时标准说一个操作的结果有**未定义的行为**（_undefined behavior_）。这意味着运行时表现是不可预测的，不用说你也想避开这种不确定性。有未定义行为的行动的例子是，在`std::vector`范围外使用方括号（“`[]`”），解引用未初始化的迭代器，或者引入数据竞争（即有两个或以上线程，至少一个是writer，同时访问相同的内存位置）。
## **指针**
将那些比如从`new`返回的内置指针（_build-in pointers_）称为**原始指针**（_raw pointers_）。原始指针的“反义词”是**智能指针**（_smart pointers_）。智能指针通常重载指针解引用运算符（`operator->`和`operator*`），`std::weak_ptr`是个例外。