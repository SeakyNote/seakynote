## 条款七：区别使用`()`和`{}`创建对象
- 花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析有天生的免疫性
- 在构造函数重载决议中，编译器会尽最大努力将括号初始化与`std::initializer_list`参数匹配，即便其他构造函数看起来是更好的选择
- 对于数值类型的`std::vector`来说使用花括号初始化和圆括号初始化会造成巨大的不同
- 在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战。
## 条款八：优先考虑`nullptr`而非`0`和`NULL`
- 优先考虑`nullptr`而非`0`和`NULL`
- 避免重载指针和整型
## 条款九：优先考虑别名声明而非`typedef`
- `typedef`不支持模板化，但是别名声明支持。
- 别名模板避免了使用“`::type`”后缀，而且在模板中使用`typedef`还需要在前面加上`typename`
- C++14提供了C++11所有_type traits_转换的别名声明版本
## 条款十：优先考虑限域`enum`而非未限域`enum`
- C++98的`enum`即非限域`enum`。
- 限域`enum`的枚举名仅在`enum`内可见。要转换为其它类型只能使用_cast_。
- 非限域/限域`enum`都支持底层类型说明语法，限域`enum`底层类型默认是`int`。非限域`enum`没有默认底层类型。
## 条款十一：优先考虑使用*deleted*函数而非使用未定义的私有声明
- 比起声明函数为`private`但不定义，使用_deleted_函数更好
- 任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）