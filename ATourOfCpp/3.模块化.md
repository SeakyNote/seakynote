头文件与模块的区别并不仅仅是在语法上。
- 模块只被编译一次，不会在每个用到它的翻译单元那里都被重新编译。
- 两个模块 import 的顺序不影响其含义。
- 如果你在模块内部 import 或者#include 其他内容，模块的使用者不会隐式地获得那些模块的访问权：这意味着 import 没有传染性。
模块在维护性与编译时间方面的改进非常显著。

速度提升的原理是：模块只导出接口，但头文件需要传递所有直接的或者间接的信息给编译器。
这个特性使得我们可以放心地引用大规模的模块，而不必被迫记忆与选择只#include 其中个别功能的头文件。

命名空间的机制，一方面表达某些声明是属于一个整体的，另一方面表明它们的名字不会与其他命名空间中的名字冲突。

如果觉得（在一段代码中）反复使用命名空间限定显得冗长及干扰了可读性，可以使用using 声明将命名空间中的名字放进当前作用域。

使用命名空间指令不会影响使用模块的用户；这是实现细节，影响仅限于模块内部。

使用 using 指令时，我们失去了对所指定的命名空间名称的选择权，因此需要谨慎使用。通常当特定命名空间在应用中普遍使用（例如，std）或者移植一个没有使用 namespace 的旧应用时使用 using 指令。

强烈不建议使用全局变量，已知的很多问题都来源于它。

从性能方面考虑，我们通常对小数据传值、对大数据传引用。这里的“小”意味着“复制开销很低”。它的准确定义取决于具体的机器架构，通常而言，“尺寸在两到三个指针以内”是一个不错的标准。但如果传递方式对性能影响非常显著，请先测量再做决定。

如果为了性能而使用引用传递，但并不需要修改参数，那么可以选择以 const 引用的方式传递。

返回值的默认行为是复制，对小对象而言这是理想的处理方式。返回引用的情况只应当出现在返回的内容不属于函数局部的时候。

返回类型后置中auto的含义表示“返回值可能会在后面提到或者自动推导”，使用这种记法能够更有效地将函数名对齐。

一个函数只能返回一个值，但这个值可以是拥有很多成员的类对象。这往往是函数体面地返回多个值的办法。

把类对象成员的名称赋予局部变量名称的机制叫作结构化绑定。

使用结构化绑定并不意味着复制整个 struct。实际上，返回一个简单 struct极少导致复制，因为简单类型可以在需要使用的地方按需构造。使用结构化绑定主要是为了更清晰地表达思想。

使用函数返回值的方式（而非输出参数）［CG:F.20］ ［CG:F.21］