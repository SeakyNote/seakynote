每当定义一个函数时，都应当考虑函数的前提条件，并且决定是否检测这些条件。

现代操作系统允许你分配的内存比实际物理内存更多，因此在bad_alloc异常被触发之前，系统运行会被严重拖慢。

在C++中，抛出异常是最通用的处理方式。

在下列情况下会返回错误代码：
- 这种失败很常见并且可以预期。例如，打开文件失败是一件常见的事（可能这个文件不存在或者没有打开的权限）。
- 可以理性地期待该函数的调用者立即处理这个错误。
- 在并行处理的一系列任务中发生错误，我们需要知道具体是哪个任务失败。
- 在具有极低内存的系统中，支持异常机制的运行时开销将影响系统核心功能。

在下列情况下会抛出异常：
- 这个错误极为罕见，程序员通常会忘记检查它。例如，还记得你上一次检查 printf()返回值是什么时候吗？
- 这个错误无法被直接调用者处理，而是必须向上渗透到调用链并找到顶层调用者。例如，要求每个函数都处理每一次内存分配失败及网络中断是不现实的。不断重复检查错误使代码显得冗长，代价昂贵，而且易出错。将错误及传递错误代码的检测作返回值，会将函数的主要运行逻辑隐藏起来，使检测变得难以辨识。
- 新增类型的错误出现在应用底层模块，上层模块的代码并未处理这些错误。例如，当一个原本为单线程设计的应用被修改为使用多线程，或者将访问本地资源修改为到远程网络中访问。
- 无法以合适的路径返回错误代码。例如，构造函数没有办法将返回值传递给调用者检查。特别地，构造函数可能在多个局部变量中或者一个部分构造的复杂对象中被调用，清理这些返回值会变得极其复杂。类似地，操作符函数通常也不具备返回错误代码的条件。例如：`a*b+c/d`。
- 同时返回一个值及错误代码会让函数变得非常复杂，代价也相对昂贵，可能导致被迫使用输出参数、非局部变量，或者其他奇技淫巧。
- 从错误中恢复还依赖于某些函数调用的结果，这导致需要管理本地状态机或者复杂的控制结构。
- 产生错误的函数本身是一个回调函数（函数参数），因此调用者可能并不知道调用的是什么函数。
- 当错误隐含地需要进行某种程度的“撤销动作”时。

一种确保中止程序运行的办法是把函数标明为 noexcept，这样在实现中任何抛出异常的函数行为都会变成 terminate()。

当你有疑问时，建议使用异常，因为它能更好地适配不同规模的应用，而且不需要外部工具就能确保所有错误被处理。

不要迷信地认为异常处理太慢；它常常比你想象得要快，尤其是需要正确处理一些复杂、稀有错误场景或者需要多次重复检测错误代码时。

在许多系统中，对 expect()这样的断言机制提供对于断言失效行为的单点控制很重要。在大型代码库中搜索 if语句，然后对假设条件进行检查，是不切实际的。

静态断言 static_assert 的一大重要用途是在泛型编程中对类型参数进行断言。

不假思索地为函数增加 noexcept 标识是有害的。

与其他强有力的语言特性一样，noexcept 应当在理解其特性的基础上谨慎使用。

如果不确定是使用异常还是错误代码，首选异常。

除非经过全面考虑，否则不要使用 noexcept。