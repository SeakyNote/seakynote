当我们提到C++程序的可移植性时，通常讨论的是源代码的可移植性；也就是说，源代码可以在多种不同的系统中成功编译，然后运行。

ISO C++标准定义了两种实体：
- 核心语言特性
- 标准库组件

C++是一门静态类型语言。这意味着，每一个实体（例如，对象、值、名称和表达式）在被使用的那一刻，编译器必须知道其准确的类型。目标的类型决定了目标适用的操作集合，以及其在内存中的布局。

从main()函数返回一个非零的值代表程序失败，但并非所有操作系统及运行环境都会用到这个返回值：基于 Linux/UNIX 的环境通常使用它，但基于Windows的环境极少使用它。

指令 import 是C++20的新特性，但将所有标准库放进一个单独的std模块还没有成为标准。

除非在函数声明的同时定义函数体，否则编译器会忽略函数声明中的参数名称。

使用函数来完成特定任务通常可以避免在其他代码中间编写特定的代码片段；将其作为函数可强制我们对任务进行命名并记录其依赖项。如果找不到合适的名称，则很有可能存在设计问题。

- 对象(object)是某个存放特定类型值的内存空间
- 变量(variable)是一个有名字的对象

sizeof(char)等于1而 sizeof(int)通常为4
- 前缀0b表示二进制
- 前缀0x表示十六进制
- 前缀0表示八进制

初始化：
使用=的形式是C语言传统的方式，如果拿不定主意该用什么，就使用更通用的列表形式。抛开其他因素不谈，这种形式可以避免隐式类型转换导致的信息丢失。
当使用=而不是{}的时候，会进行从double到int及从int到char这样的窄化类型转换。这样即使会丢失一些信息，C++编译器也会接受这个后果并且隐式执行程序。这个不幸的后果是为了与C语言兼容而付出的代价。
使用 auto 声明变量时，我们倾向于使用=符号，因为这没有导致类型转换问题的风险。但如果你偏好使用{}来保持初始化符号的一致性，也可以继续这样做。
当没有明显的理由需要显式地指定类型时，一般使用auto。“明显的理由”包括：
- 该定义的作用域较大，我们希望代码的读者清楚地知道其类型
- 初始化表达式的类型（对读者来说）不是显而易见的
- 我们希望明确规定某个变量的范围和精度（例如，希望使用 double 而非 float）
使用 auto 可以避免书写冗长的类型名称及重复代码。在泛型编程中这一点尤其重要，因为在泛型编程中程序员很难知道对象的确切类型，类型名称也会相当长。

一个使用new创建的对象则可以持续“生存”，直到用delete将其销毁为止。

constexpr：大致意味着“请在编译时计算出它的值”。这主要用于声明常量，作用是把数据置于只读内存区域（更小概率被破坏），以及提高性能。constexpr的值必须由编译器计算。
一个constexpr函数可以输入非常量参数调用，但此时返回值不是常量表达式。只要上下文不需要该函数返回常量表达式，就允许以非常量表达式为参数调用 constexpr 函数。使用这种方法，不需要仅仅为了区分常量表达式与变量输出，定义实质上相同的函数两次。如果要求某个函数仅在编译时计算，可以声明它为consteval而不是constexpr。

范围for语句可以用于任何序列的元素。

引用在初始化以后就不能再指向其他的对象了

不希望函数修改传入的参数，只想减小参数复制的开销。此时可以使用const引用实现。

switch: 如果程序没有提供default分支，则当检验值不等于任何case标签时什么也不做。

在if语句条件内定义一个名称的目的是限制变量的作用域，从而提升可读性，尽可能减少错误。
将变量值与0或nullptr进行比较是很常见的情况，在这种情况下可以省略条件。

基本语言结构能够直接映射到硬件，这使得一门语言能获得系统原生的底层性能，C与C++数十年间以此闻名。