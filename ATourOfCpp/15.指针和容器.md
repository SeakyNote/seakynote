正确使用指针来表示资源的所有权已被证明是非常困难的。因此，标准库提供了资源管理指针；换句话说，将指针封装成类，并将其正确的使用方式以类的成员函数提供。
这些标准库抽象封装了内置语言类型，（标准规定）封装的类需要在时间和空间效率上与内置类型的正确使用一样好。

内置引用类型是一个隐式解引用的指针。

可以有多个指针指向同一个对象。拥有所有权的指针意味着它负责删除所指向的对象。不拥有所有权的指针可以悬空；也就是说，它们允许指向已经被删除的对象（成为野指针），或者离开作用域（造成潜在泄漏）。

string_view 与 span 是不具备所有权的指针。

“智能指针”最基本的用途是防止“粗心”的程序引起内存泄漏。

过度使用 new（以及指针和引用）似乎是一个日益严重的问题。

与正确使用内置指针相比，unique_ptr是一种没有空间或时间开销的轻量级机制。

请确保确实需要共享所有权时才使用 shared_ptr。

相比单独使用 new 创建一个对象，然后将其传递给 shared_ptr 来说，使用`make_shared()`不仅更方便，而且效率也明显更高，因为它不需要单独分配引用计数，这个变量在 shared_ptr 的实现中非常重要。

内置数组：固定大小、连续分配的N个类型为T的元素序列；会被隐式转换为`T*`。

与使用内置数组相比，使用 array 没有任何额外开销（时间或空间）。array 并不遵循STL 容器常见的“元素句柄”模型。相反，array 直接包含它的元素。它只不过是内置数组的更安全的版本。

array可以而且必须由初始化列表初始化，元素个数不是可选的，其必须是常量表达式，且必须是正数，元素类型必须被明确指定。

如果你需要用变量传入元素数量，那么可用 vector 类。

既然 vector 如此灵活，我们为什么还要使用 array 呢？array 不太灵活所以可以更简单。有时，直接访问分配在栈上的元素比通过 vector 句柄间接访问自由存储中的元素（然后释放它们），具备显著的性能优势。

既然可以使用内置数组，为什么还要使用 array 呢？anray 知道它的大小，所以它更容易结合标准库算法一起使用，并且可以使用=操作符直接拷贝。

我更喜欢 array 的主要原因是，它使我免于使用令人惊讶和讨厌的指针转换。

对于无法放进`long long int`（通常为64位）变量的比特集合，使用bitset比直接使用整数方便得多。

类型推导使得在不显式写出其类型的情况下轻松创建pair类型。

tuple中具有唯一类型的元素可以通过其类型被“命名”。

pair类型和具有两个成员的tuple之间也可以互相转换。

与显式使用union相比，variant通常是更安全、更方便的替代方法。最简单的示例可能是返回值或错误代码。

optional可以被看作一种特殊的 variant（如 variant<A, nothing>）或对`A*`的概念的概括，要么指向对象，要么是nullptr。

optional被视为指向其对象的指针，而不是对象本身。

不要在本可以使用局部变量的场合使用智能指针。

与shared_ptr相比，优先选择unique_ptr。

如果你需要使用N个二进制比特，而N又不是内置整数类型的位宽，则建议使用bitset。

不要过度使用pair和tuple，命名struct通常会有更易读的代码。

使用pair时，使用模板参数推导或`make_pair()`可以帮助我们避免冗余类型说明。

使用tuple时，使用模板参数推导或`make_tuple()`可以助我们避免冗余类型说明。