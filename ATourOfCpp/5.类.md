C++最核心的语言特性就是类。

不需要实参就可以调用的构造函数称为默认构造函数。

const 修饰符表示函数不会修改所调用的又象。const 成员函数可以被 const 及非 const 对象调用，但非 const 成员函数只能被非 const 对象调用。

容器是指一个包含若干元素的对象。

析构函数的命名规则是在一个求补操作符~后跟上类的名字，从含义上来说，它是构造函数的补充。

单独的 delete 释放一个独立对象；`delete[]`则释放一个数组。

在构造函数中获取资源，然后在析构函数中释放它们，这种技术称为资源获取即初始化，又叫 RAII。

static_cast 本身并不负责检查要转换的值；它认为程序员自己知道应该如何正确地使用技术。

强制类型转换包括用于将对象直接当作字节流的 reinterpret_cast 和 bit_cast。

奇怪的=0语法说明函数是纯虚函数，意味着派生类必须定义这个函数。

含有纯虚函数的类被称为抽象类。

把一个常用来其他类型提供接口的类称为多态类型。

显式指定 override在大型的类层次结构中特别有用，否则我们很难知道谁试图覆盖谁。

虚调用机制的效率非常接近“普通函数调用”机制（速度相差不超过25%，而且开销比重复调用相同对象低得多）。而它的空间开销包括两部分：如果类包含虚函数，则该类的每个对象都需要一个额外的指针；每个这样的类需要一个 vtbl。

当使用一个基类指针释放派生类对象时，虚函数调用机制能够确保我们调用了正确的析构函数，然后该析构函数再隐式调用其基类的析构函数和成员的析构函数。

当一个指向其他派生类的对象的指针是一个有效参数时，我们就能对指针类型使用dynamic_cast，然后可以检验求值结果是否是 nullptr。这种用法常常用来在条件语句中初始化变量。

适度使用 dynamic_cast 能让代码显得更简洁。

当我们获取了资源并且没有释放它们的时候，通常用泄漏这个词来描述。

使用unique_ptr的代码会与正确使用原始指针的代码同样高效。

当对象的unique_ptr离开了作用域时，unique_ptr 将释放掉所指的对象。

只有当函数确实需要直接访问类的成员变量时，才把它作为成员函数。

如果成员函数不会改变对象的状态，则把它声明成 const。

抽象类通常不需要构造函数。

含有虚函数的类应该同时包含一个虚析构函数。

当设计类的层次结构时，注意区分实现继承和接口继承。

当类层次结构导航不可避免时，记得使用dynamic_cast。

为了防止忘记用 delete 销毁用 new 创建的对象，建议使用 unique_ptr 或者 shared_ptr。