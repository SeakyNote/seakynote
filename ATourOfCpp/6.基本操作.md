如果类的析构函数执行了某些特定的任务，比如释放自由存储空间或者释放锁，则该类也应该实现所有其他相关的函数。

拷贝与移动构造函数常常被优化为在目标对象的位置直接初始化。

当类中含有指针成员时，最好显式地指定拷贝操作和移动操作。

好的经验法则（有时叫作零法则）是要么定义所有的基本操作，要么不定义任何操作。

类层次结构的基类通常不允许拷贝。

=delete 可以用于禁用任意函数，并非仅仅用于禁用基础成员函数。

除非你有充分的理由，否则最好把接受单个参数的构造函数声明explicit 的。

定义类的数据成员时，可以提供默认的初始值，称其为默认成员初始值设定项。

符号&&的意思是“右值引用”，右值大致上就是无法其赋值的值。右值引用的含义就是引用了一个别人无法赋值的内容，所以我们可以安全地“窃取”它的值。

标准库函数 move（）不会真的移动什么，而是负责返回我们能移动的函数实参的引用——右值引用；这是一种强制类型转换。

C++标准规定了编译器必须将与初始化相关的绝大多数拷贝行为消除掉，因此移动构造方法并不像你想象的那么经常被调用。这种拷贝省略行为消除了移动开销（哪怕这些开销并不大）。

C++不允许定义新的操作符。在定义操作符时，强烈建议让它们保持通常的语义。

由于历史原因，`=`、`->` 、`()`和`[]`这几个操作符必须被声明为成员函数。

用于对称操作数的操作符，通常应当将其定义为独立函数，以表示对两个操作数平等对待。

在拷贝完成之后，两份拷贝应当相等。

当我们定义=操作符时，应当同步定义`!=`操作符，并且确保`a!=b`与`!(a==b)`一致。

如果定义了<操作符，建议同步定义<=、>、>=

为了让双目操作符（比如`==`）的两个操作数得到平等对待，最好将其定义成独立函数，并且与类位于相同的命名空间。

与C语言中的`strcmp()`函数一样，`<=>`实现了三向比较。返回负数表示小于，返回零表示等于，返回正数表示大于。

`p?x:y`是一个表达式，如果条件p为真，`?:`表达式的值为x，否则就是y。

独立优化的`==`很有必要，可避免`<=>`对所有三种情况都进行检查。

swap()高效、快速并且不抛出异常。标准库提供的 std::swap(a,b)使用了三次移动操作来实现。如果你设计了一个拷贝开销较大但可以被移动的类型，那么给它定义移动操作符或者 swap()函数，或者两个都实现。

`"Surprise!"`是 `const char[10]`类型
`"Surprise!"s` 是 `std::string`类型

符号 `operator""`表明我们正在定义字面量操作符。

默认情况下，把单参数的构造函数声明成 explicit 的。