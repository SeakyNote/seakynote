不要认为并发是灵丹妙药。如果一项任务可以按顺序完成，那么这样做通常更简单、更快捷。因为，将信息从一个线程传递到另一个线程可能会非常昂贵。

标准库提供了jthread，它是一个“自动会合线程”。

`{f,ref(some_vec)}`形式的初始化，使用了 thread 类的可变参数模板构造函数，它能接受任意参数序列。`ref()`是来自`<functional>`的类型函数，因为我们必须用它告诉可变参数模板将 some_vec 视为引用，而不是对象。如果没有`ref()`，some_vec 将被按值传递。

需要同时访问多个资源以执行某些操作的情况并不少见，这可能会导致死锁。例如，如果thread1 获取了 mutex1，然后尝试获取 mutex2，而 thread2 获取了 mutex2，然后尝试获取mutex1，则两个任务都不会继续进行。scoped_lock 可帮助我们同时获取多个锁。

有些人笃信共享数据一定比拷贝函数参数和返回值更有效率。当涉及大量数据时确实如此，但锁定和解锁是相对昂贵的操作。而且，现代机器非常擅长拷贝数据，尤其是紧凑型数据。所以不要因“效率”而不假思索地选择使用共享数据进行通信，最好先测量再做出选择。
基本的 mutex 一次只允许一个线程访问数据。共享数据的最常见方式之一是多线程读取和单线程写入。shared_mutex 支持这种“读写锁”的用法。多个读取线程将获得“共享”的互斥锁，以便其他读取线程仍然可以获得访问权限，而写入线程将要求独占访问。

`this_thread::sleep_for(milliseconds{20});`

默认情况下，this_thread 可以指代当前唯一的线程（主线程）。

标准库提供了 packaged_task 类型，其可以简化 thread 上的 future 和promise 的相关设置。

需要 `move()`操作，因为无法拷贝packaged_task。packaged_task 不能被拷贝的原因是，它是一个资源句柄：它拥有它的promise 并且（间接地）负责它的任务可能拥有的任何资源。

如果任务需要用到共享资源，且共享资源需要锁机制，则不该使用`async()`。

很少需要手动并行化如`accumulate()`之类的标准库算法，因为并行算法通常在这方面做得更好，而且这类技术是通用的。

请注意，`async()`并非只是为提高并行计算性能所设计的机制，还可以用它来创建比如从用户获取信息的任务，而让“主程序”继续进行其他计算。

协程框架实现得极其灵活，能够服务于极端范围的潜在用途。它由专家设计并为专家设计，具有委员会的设计风格。这很好，但在C++20 中仍然缺失能让简单功能轻松实现的库设施。例如，generator（目前还）不是标准库的一部分。

有时串行解决方案比并发解决方案更简单也更快。

优先选择并行算法，而不是直接使用并发。

优先使用 jthread 而不是thread。

尽可能避免显式共享数据。

使用 atomic 可进行非常简单的共享。

优先使用 packaged_task 和 future，而不是直接使用 thread 和 mutex。

使用 `async()` 来启动简单的任务。