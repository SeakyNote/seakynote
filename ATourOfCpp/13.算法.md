标准库list具有移动构造函数，这使得以传值方式返回res也很高效。

类似很多标准库搜索算法，find返回`end()`，表示“未找到”。

返回 vector 是很高效的，因 vector 提供了移动语义。

迭代器的重要作用是分离算法和容器（数据结构）。算法通过迭代器来处理数据，但它对存储元素的容器一无所知。反之亦然，容器对处理其元素的算法也一无所知，它所做的全部事情就是，按需求提供迭代器（如 `begin()`和 `end()`）。这种数据存储和算法分离的模型催生出非常通用和灵活的软件。

如果需要同时使用标准库算法的迭代器版本及范围版本，需要显式地指定调用的版本，或者使用using 声明: `ranges::copy(v, 00);` 

谓词不能改变它所施用的元素。

在C++ 标准库的语境中，算法就是对元素序列进行操作的函数模板。

标准库提供了很多算法，它们都被定义在命名空间 std 中，通过头文件`<algorithm>`和`<numeric>`提供。这些标准库算法都以序列作为输入。一个从b到e的半开半闭序列表示为`[b:e)`。

对于每个将`[b:e)`作为范围的算法，都可以换用`<range>`提供的范围版本。

算法可以用于容器、string 和内置数组。

应该了解标准库算法，尽可能使用它们编写程序，而不是从头另起炉灶。

是否值得并行化和/或数组化取决于算法、序列中的元素数量、硬件及在其上运行的程序对该硬件的利用率。因此，执行策略指标仅仅是提示而非强制。编译器或者运行时调度器负责决定使用何种程度的并发。这不是小事，它基于一个重要规则：反对未经测量之前进行任何关于效率的决定。

大多数标准库算法可以申请并行化或者数组化执行。

对于参数序列，算法并不直接在其中添加或删除元素。

编写循环代码时，思考它是否可以表达为一个通用算法。

谓词不能修改其参数。

了解标准库算法，尽量使用它们而不要用自己设计的循环版本编写程序。