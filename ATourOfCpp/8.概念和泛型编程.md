类型名称指示符 typename是限定程度最低的，它仅仅要求该参数是一个类型。

`Arithmetic<X, Y>`则是一个概念，它表明，X与Y 可以进行算术运算。

`requires Arithmetic<range_value_t<seq>，Nums>`被称作 requirements 子句。

编译器会选择满足最严格参数需求的版本。

requires requires 不是拼写错误。第一个 requires 开始一个 requirements 子句，而第二个 requires 开始一个 requires 表达式。

`requires (Iter p, int i) { p[i]; p+i; }`
这里的 requires 表达式是一个谓词，如果代码为有效代码则为 true，否则返回 false。

如果你在你的代码中看到了requires requires 子句，很可能这样的代码过于底层，最终可能产生潜在问题。

尽量使用有良好定义语义的命名概念。

标准库中的名称通常使用小写字母。在这里，我们自己定义的概念的名称都会以大写字母开头。

概念是一个编译时谓词，指示了一个或多个类型如何被使用。

`typename T2=T` 表示，如果没有指定第二个模板参数，那么T2 就与T相同；T被称为默认模板参数。

最难定义的概念就是用来表示语言基础元素的底层概念，因此最好直接使用一个已经建立好概念集的库。

模板中的概念是用来检查模板实例化时的参数的，并不用于在定义模板时进行检查。

关键字 auto 表示了值的最小约束概念：它需要的仅仅是某个类型的值。在参数中使用 auto 会将一个函数变成模板函数。

使用概念替换 auto，可以增强类似的初始化需求约束。

概念：
- 与对象在内存中的布局没有任何关系。
- 允许一系列可使用类型的集合。

使用概念来约束代码比直接使用类型进行约束会更灵活。

我们只能把概念当成一个形容词，而无法将其当成名词。

从一段或者几段实体代码生成一段泛型代码的同时保持原有性能，这种行为叫作提升（lifting）。从而，最佳的开发模板的方法通常是：
- 首先，写一个实体代码版本。
- 调试，测试，然后测量它们。
- 最后，将实体类型转化类模板参数。