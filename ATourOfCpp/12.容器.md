如果一个类的主要目的是保存对象，那么我们通常称之为容器container。

vector是一个给定类型元素的序列，元素在内存中是连续存储的。

标准库的 vector 经过了精心设计，即便不断调用 `push_back()`来扩展 vector，也不会影响效率。

"我原来习惯用`reserve()`来提高性能，但事实证明这是浪费精力：vector 所使用的启发式策略远好于我的估计。因此，我现在只有在使用元素指针时才用`reserve()`来避免迁移元素。"

当(vector的)拷贝并非必要时，应该使用引用或指针或是移动操作。

标准库vector非常灵活且高效，应当将它作为默认容器。也就是说，除非有充分的理由使用其他容器，否则应使用vector。如果你的理由是“效率”，请进行性能测试——我们在容器使用性能方面的直觉通常是很不可靠的。

如果你有一个类层次结构依赖 virtual 函数获得多态性，那就不应在容器中直接保存对象，而应保存对象的指针（或智能指针）。

vector的`at()`函数也可完成下标操作，但它会在参数越界时抛出一个类型为out_of_range的异常。

一种尽量减少未捕获异常带来问题的方法是使用try块作为`main()`函数的函数体。

为什么标准库不确保范围检查？因为很多性能关键型应用程序使用vector，对所有下标操作进行范围检查意味着要支出大约20%的性能开销。显然这个开销对于不同场景区别会很大，比如当你使用的硬件、优化器，以及下标用法不同时开销都会不同。经验表明，这个级别的开销会导致很多人倾向于使用相对不安全的内置数组。对范围检查附加的任何开销都可能导致人们的潜在恐惧，从而拒绝使用标准库容器。现在，至少在调试阶段可以很容易地在vector上实现范围检查，而且可以在无检查的默认版本之上构建出带检查的版本。

可以直接使用`vector::at()`替代下标访问，这样就不需要诸如Vec类这样的变通方案了。某些 C++实现提供了带范围检查功能的vector（例如，作为一个编译选项）

如果希望在一个序列中添加、删除元素而无须移动其他元素，则可以使用 list。

对于 list 来说，`insert(p，elem)`将一个新元素插入p指向的元素之前，新元素的值是elem的一份拷贝。

vector的性能经常会优于list。当想要一个元素序列时，我们面临vector与list之间的选择。但除非你有充分的理由选择list，否则就应该使用vector。vector无论是遍历（如，`find()`和`count()`）性能还是排序和搜索（如，`sort()`和`binary_search()`），性能都优于 list。

标准库同时还提供单向链表，名叫 forward_list。

forward_list 与 list（双向链表）的区别仅仅是它只允许向前的迭代方向。这个设计的目的是节省空间，因为每个节点只需存储向前的指针链接，而且空 forward_list 的尺寸仅仅只有一个指针大小。forward_list 甚至不保存元素的个数。如果你需要知道元素的个数，得逐个遍历去数。如果你认为不能接受这个开销，那么你可能根本不应该使用forward_list 类型。

标准库提供了名为map的平衡二分搜索树（通常是红黑树）。

如果希望避免将无效号码添加到电话簿中，应该使用`find()`和`insert()`来代替`[]`。

搜索 map 的时间复杂度是 O(log(n))

map与unordered_map之间的区别：
- map 类型需要顺序比较函数（默认为`<<`操作符）来构建排序序列。
- unordered_map类型需要相等性比较函数（默认为`==`操作符）；它不需要管理元素的顺序。

在给定了优秀的哈希函数的情况下，unordered_map比map快很多，尤其是对于大型容器而言。但是，在最坏情况下的表现，配备了糟糕的哈希函数，unordered_map可能远比map的性能要差。

下标操作和遍历 vector 的操作很高效也很简单。但另一方面，当在 vector 中插入或删除元素时，就需要移动元素，效率不佳。而 list 则恰好具有相反的特性。请注意，当序列较短、元素大小较小时，vector 通常比 list 更为高效（即便是 `insert()`和 `erase()`操作也是如此）。我推荐将标准库 vector 作为存储元素序列的默认类型：除非有充分的理由，否则不要选择其他容器。

标准库还提供了单向链表 forward_list，这是一种为空序列特别优化过的容器，它只占用一个字的空间，而空 vector 占用三个字的空间。这种序列的元素数目为或特别少，在实际中特别有用。

```cpp
v.push_back(pair{1, "copy or move"}) ;
v.emplace_back(1, "build in place");
```
注意，对于上述简单操作，优化器可以将两种写法优化为同等性能。

使用`reserve()`可避免指向元素的指针或迭代器失效。

在未经测试的情况下，不要假定使用`reserve()`会带来性能收益。

不要在调整 vector 大小时使用迭代器。

不要假定`[]`有范围检查功能。

如果你需要确保进行范围检查，应使用`at()`函数。

元素是被拷贝到容器中的。

如要保持元素的多态行为，可在容器中保存指针（内置的或用户自定义的）。

对通常为空的序列使用 forward_list。

事关性能时，不要相信你的直觉，应进行性能测试。

map通常用红黑树实现。

unordered_map 是哈希表。

传递容器参数时，应传递引用，返回容器时，应返回值。

遍历 list 的代价相对较高。

如果需要在大量数据中进行快速搜索操作，应选择无序容器。

如果需要按顺序遍历容器中的元素，选择有序容器（如map 和 set）。

若元素类型没有自然的顺序（如没有合理的<操作符），选择无序容器（如unordered_map）。

当需要在容器尺寸变化时，确保指向元素的指针稳定不变，可使用关联容器（如 map
和 list）。

将多个标准哈希函数用异或操作符（^）组合设计成的哈希函数通常有较好的效果。

了解标准库容器，优先选择这些容器而不是自己实现的数据结构。

如果你的应用程序遇到了与内存相关的性能问题，尽量減少使用自由存储和/或考虑使用专门的分配器。

