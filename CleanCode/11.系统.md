软件系统应将起始过程和起始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在互相缠结的依赖关系。

将构造与使用分开的方法之一是将全部构造过程搬迁到 main 或被称之 main 的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置。

有一种强大的机制可以实现分离构造与使用，那就是依赖注入（Dependency Injection，DI）。控制反转（Inversion of Control, IoC）在依赖管理中的一种应用手段。控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则。在依赖管理情景中，对象不应负责实体化对自身的依赖，反之，它应当将这份权责移交给其他“有权力”的机制，从而实现控制的反转。因为初始设置是一种全局问题，所以通常这种授权机制要么是 main 例程，要么是有特定目的的容器。

“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。

与物理系统相比，软件系统比较独特。软件系统的架构可以递增式地增长，只要我们持续将关注面恰当地切分。

采用一些新技术，就能将架构按需从简单演化到精细。没必要先做大设计（Big Design Up Front, BDUF）。实际上，BDUF 甚至是有害的，它阻碍改进，因为心理上会抵制丢弃既成之事，也因为架构上的方案选择影响后续的设计思路。
建筑设计师不得不做BDUF，因为一旦建造过程开始，就不可能对大型物理建筑的结构做根本性改动。尽管软件也有物理的一面，但只要软件的构架有效切分了各个关注面，还是有可能做根本性改动的。
这意味着我们可以从“简单自然”但切分良好的架构开始做软件项目，快速交付可开展工作的用户故事，随着规模的增加添加更多基础架构。有些世界上最大的网站采用了精密的数据缓存、安全、虚拟化等技术，获得了极高的可用性和性能，在每个抽象层和范围之内，那些最小化耦合的设计都简单到位，效率和灵活性也随之而来。
当然，这不是说要毫无准备地进入一个项目。对于总的覆盖范围、目标、项目进度和最终系统的总体构架，我们会有所预期。不过，我们必须有能力随机应变。

在没能真正得到使用时，设计得再好的API 也等于是杀鸡用牛刀。优秀的API 在大多数时间都该在视线之外，这样团队才能将创造力集中在要实现的用户故事上。否则，架构上的约束就会妨碍向客户交付优化价值的软件。

最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java（或其他语言）对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具整合起来。这种架构能测试驱动，就像代码一样。

模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或一个软件项目，无人能做所有决策。
众所周知，对于决策最好是授权给最有资格的人。但我们常常忘记了，延迟决策至最后一刻也是好手段，这不是懒惰或不负责，而是让我们能够基于最有可能的信息做出选择。提前决策是一种预备知识不足的决策。如果决策太早，就会缺少太多客户反馈、关于项目的思考和实施经验。

有了标准，就更易复用想法和组件、雇用拥有相关经验的人才、封装好点子，以及将组件连接起来。不过，创立标准的过程有时却漫长到行业等不及的程度，有些标准没能与它要服务的采用者的真实需求相结合。

系统也应该是整洁的。侵害性架构会湮灭领域逻辑，冲击敏捷能力。如果领域逻辑受到困扰，质量就会堪忧，因为缺陷更易隐藏，用户故事更难实现。当敏捷能力受到损害时，生产力也会降低，TDD 的好处遗失殆尽。

无论是设计系统还是单独的模块，别忘了使用大概可开展工作的最简单方案。