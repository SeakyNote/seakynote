TDD 三定律
**第一定律** 在编写不能通过的单元测试前，不可编写生产代码。
**第二定律** 只可编写刚好无法通过的单元测试，不能编译也算不通过。
**第三定律** 只可编写刚好足以通过当前失败测试的生产代码。

脏测试等同于——如果不是坏于的话——没测试。测试必须随生产代码的演进而修改。测试越脏，就越难修改。测试代码越缠结，你就越有可能花更多时间塞进新测试，而不是编写新的生产代码。修改生产代码后，旧测试就会开始失败，而测试代码中乱七八糟的东西将阻碍代码再次通过。于是，测试变得就像是不断翻番的债务。
随着版本递进，团队维护测试代码组的代价也在上升，最终，这样的代价变成了开发者最大的抱怨对象。当经理们问及为何超支如此巨大，开发者们就归咎于测试。最后，他们只能扔掉整个测试代码组。
但是，没有了测试代码组，他们就失去了确保对代码的改动能如愿工作的能力。没有了测试代码组，他们就无法确保对系统某个部分的修改不会影响系统的其他部分。故障率开始上升。随着并非出自有意的故障越来越多，他们开始害怕做改动。他们不再清理生产代码，因为他们害怕修改带来的损害多于收益。生产代码开始腐坏。最后，他们只剩下没有测试、纷乱而缺陷缠身的生产代码，沮丧的客户，还有对测试的失望。

测试代码和生产代码一样重要。测试代码可不是二等公民，它需要被思考、被设计和被照料，它该像生产代码一般保持整洁。

覆盖了生产代码的自动化单元测试程序组能尽可能地保持设计和架构的整洁。测试带来了一切好处，因为测试使改动变得可能。
如果测试不干净，你改动自己代码的能力就会有所限制，而你也会开始失去改进代码结构的能力。测试越脏，代码就会变得越脏。最终，你丢失了测试，代码开始腐坏。

整洁的测试有哪些要素呢？有3个要素：可读性、可读性和可读性。在单元测试中，可读性甚至比在生产代码中还重要。测试如何才能做到可读？和在其他代码中一样：明确，简洁，并有足够的表达力。在测试中，你要以尽可能少的文字表达大量内容。

测试API 中的代码与生产代码相比，的确有一套不同的工程标准。测试代码应当简单、精悍、足具表达力，但它该和生产代码一般有效。毕竟它是在测试环境而非生产环境中运行的，这两种环境有着截然不同的需求。

有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题。通常这关乎内存或CPU效率的问题，不过却永远不会与整洁有关。

单个测试中的断言数量应该最小化。

应该尽可能减少每个概念的断言数量，每个测试函数只测试一个概念。

F.I.R.S.T.
整洁的测试还遵循以下5条规则:
- 快速（Fast）。测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。
- 独立（Independent）。测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，以及以任何顺序运行测试。当测试互相依赖时，头一个测试没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。
- 可重复（Repeatable）。测试应当可以在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的借口。当环境条件不具备时，你也会无法运行测试。
- 自足验证（Self-Validating）。测试应该有布尔值输出。无论是通过或失败，你都不应该通过查看日志文件来确认测试是否通过。你不应该手工对比两个不同的文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。
- 及时（Timely）。测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会因为某些生产代码本身难以测试而不去设计可测试的代码。

对于项目的健康度，测试和生产代码同等重要。或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。

如果你坐视测试腐坏，那么代码也会跟着腐坏。保持测试整洁吧。