通常，作者、最后修改时间、SPR数等元数据不该在注释中出现。注释只应该描述有关代码和设计的技术性信息。

过时、无关或不正确的注释就是废弃的注释。注释会很快过时。最好别编写将被废弃的注释。如果发现废弃的注释，最好尽快更新或删除。废弃的注释会远离它们曾经描述的代码，变成代码中无关和误导阅读者的浮岛。

如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。

注释应该谈及代码自身没提到的东西。

值得编写的注释，也值得好好写。如果要编写一条注释，就花时间保证写出最好的注释，字斟句酌，使用正确的语法和拼写，别闲扯，别画蛇添足，要保持简洁。

看到被注释掉的代码会令我抓狂。谁知道它有多旧？谁知道它有没有意义？没人会删除它，因为大家都假设别人需要它或是有进一步计划。

看到注释掉的代码，就删除它！别担心，源代码控制系统还会记得它。如果有人真的需要，可以签出较旧的版本。别被它搞得死去活来。

构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四处寻找额外的小JAR、XML 文件和其他系统所需的杂物。你应当能够用单个命令签出系统，并用单个指令构建它。

你应当能够发出单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速、轻易和直截了当地做到。

函数的参数量应该少。没参数最好，一个次之，两个、三个再次之。三个以上的参数非常值得质疑，应坚决避免。

输出参数违反直觉，因为读者期望参数用于输入而非输出。如果函数非要修改什么东西的状态，就修改它所在对象的状态好了。

布尔值参数大声宣告函数做了不止一件事。它们令人迷惑，应该被消灭掉。

永不被调用的函数应该被丢弃。保留死函数纯属浪费，别害怕删除死函数，记住，源代码控制系统还会记得它。

理想的源文件包括且只包括一种语言。现实中，我们可能会不得不使用多于一种语言，但应该尽力缩小源文件中额外语言的数量和范围。

遵循“最小惊异原则”，函数或类应该实现其他程序员有理由期待的行为。

别依赖直觉。追索每种边界条件，并编写测试。

关闭某些编译器警告（或者全部警告！）可能有助于构建成功，但可能会陷于无穷无尽的调试中。关闭失败测试、告诉自己过后再处理，这和假装刷信用卡不用还钱一样存在安全隐患。

有一条本书提到过的最重要的规则之一，你应该非常严肃地对待它，实际上，每位编写有关软件设计的作者都提到过这条规则，Dave Thomas 和 Andy Hunt 称之DRY 原则（Don'tRepeat Yourself，别重复自己）。Kent Beck 将它列为极限编程核心原则之一，并称之为“一次，也只一次”。Ron Jeffries 将这条规则列在第二位，地位仅次于通过所有测试。
每次看到重复代码，都代表遗漏了抽象。重复的代码可能成为子程序或干脆是另一个类。将重复代码叠放进类似的抽象，增加了你的设计语言的词汇量。其他程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。
重复最明显的形态是你不断看到明显一样的代码，就像是某位程序员疯狂地用鼠标不断复制粘贴代码。可以用单一方法来替代之。

将概念分解到基类和派生类的最普遍的原因是，较高层级基类概念可以不依赖较低层级派生类概念。这样，如果看到基类而提到派生类名称，就可能发现了问题。通常来说，基类对派生类应该一无所知。

优秀的软件开发人员要学会限制类或模块中暴露的接口数量。类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好。
隐藏你的数据，隐藏你的工具函数，隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类，不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。

死代码就是不执行的代码。可以在检查不会发生的条件的if 语句体中找到，可以在从不抛出异常的try 语句的catch 块中找到，可以在从不被调用的小工具方法中找到，也可以在永不会发生的 switch/case 条件中找到。
死代码的问题是过不久它就会发出“坏味道”。时间越久，味道就越酸臭。这是因为，在设计改变时，死代码不会随之更新。它还能通过编译，但并不会遵循较新的约定或规则。
编写它的时候，系统是另一番模样。如果你找到死代码，就体面地埋葬它，将它从系统中删除掉。

变量和函数应该在靠近被使用的地方定义。本地变量应该正好在其首次被使用的位置上面声明，垂直距离要短。本地变量不该在距离其被使用之处几百行以外的位置声明。
私有函数应该刚好在其首次被使用的位置下面定义。私有函数属于整个类，但我们还是要限制调用和定义之间的垂直距离。找一个私有函数，应该只是从其首次被使用处往下一点儿的位置那么简单。

从一而终。这可以追溯到最小惊异原则。小心选择约定，一旦选中，就小心持续遵循。

前后一致，一旦坚决贯彻，就能让代码更加易于阅读和修改。

没有实现的默认构造器有何用处呢？它只会用无意义的杂碎搞乱对代码的理解。没有用到的变量，从不调用的函数，没有信息量的注释，等等，这些都是应该移除的废物。保持源文件整洁，组织良好，不被搞乱。

不互相依赖的东西不该耦合。例如，普通的enum 不应被包括在特殊类中，因为这样一来应用程序就要了解这些更为特殊的类。对于在特殊类中声明一般目的的static 函数也是如此。
一般来说，人为耦合是指两个没有直接目的的模块之间的耦合。其根源是将变量、常量或函数不恰当地放在临时方便的位置。这是一种漫不经心的偷懒行为。
花点儿时间研究应该在什么地方声明函数、常量和变量。不要为了方便随手放置，然后置之不理。

没有什么比在函数调用末尾遇到一个 false 参数更为可憎的事情了，这个 false 是什么意思呢？如果它是 true，会有什么变化吗？不仅一个选择算子（selector）参数的目的令人难以记住，而且每个选择算子参数将多个函数绑到了一起。选择算子参数只是一种避免把大函数切分为多个小函数的偷懒做法。

使用多个函数，通常优于向单个函数传递某些代码来选择函数行为。

代码要尽可能具有表达力。联排表达式、匈牙利语标记法和魔术数都遮蔽了作者的意图。

软件开发者做出的最重要决定之一就是在哪里放代码。

最小傢异原则在这里起作用了。代码应该放在读者自然而然期待它所在的地方。

通常应该倾向于选用非静态方法。如果有疑问，就用非静态函数。如果的确需要静态函数，确保没机会打算让它有多态行为。

让程序可读的最有力方法之一就是将计算过程打散成在用有意义的单词命名的变量中放置的中间值。

这事很难做过火。解释性变量多比少好。只要把计算过程打散成一系列命名良好的中间值，不透明的模块就会突然变得透明，这很值得注意。

如果你必须查看函数的实现（或文档）才知道它是做什么的，就该换个更好的函数名，或者重新安排功能代码，放到有较好名称的函数中。

在你认为自己完成某个函数之前，确认自己理解了它是怎么工作的。通过全部测试还不够好。你必须知道解决方案是正确的。
获得这种知识和理解的最好途径，往往是重构函数，得到某种整洁而足具表达力、清楚呈示如何工作的东西。

对于给定的选择类型，不应有多于一个的 switch语句。在那个 switch 语句中的多个 case，必须创建多态对象，取代系统中其他类似的switch语句。

每个团队都应遵循基于通用行业规范的一套编码标准。编码标准应指定诸如在何处声明实体变量，如何命名类、方法和变量，在何处放置括号，等等。团队不应用文档描述这些约定，因为代码本身提供了范例。
团队中的每个成员都应遵循这些约定。这意味着每个团队成员必须成熟到能了解只要全体同意在何处放置括号，那么在哪里放置都无关紧要。

在代码中出现原始形态数字通常来说是坏现象。应该用命名良好的常量来隐藏它。

有些常量与非常具有自我解释能力的代码协同工作时，如此易于识别，也就不必总是需要命名常量来隐藏了。

有些情况下，常量直接写作原始形态数字会更好。

术语“魔术数”不仅指数字，它还泛指任何不能自我描述的符号。

在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。

代码中的含糊和不准确要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。

如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。

否定式要比肯定式难明白一些。所以，尽可能将条件表示为肯定形式。

编写执行一系列操作的包括多段代码的函数常常是诱人的。这类函数做了不只一件事，应该转换为多个更小的函数，每个小函数只做一件事。

常常有必要使用时序耦合，但你不应该掩蔽它。排列函数参数，好让它们被调用的次序显而易见。

构建代码需要理由，而且理由应与代码结构相契合。如果结构显得太随意，其他人就会想修改它。如果结构自始至终保持一致，其他人就会使用它，并且遵循其约定。

边界条件难以追踪。把处理边界条件的代码集中到一处，不要散落于代码中。我们不想见到四处散见的+1和-1 字样。

函数中的语句应该在同一抽象层级上，该层级应该是函数名所示操作的下一层。这可能是最难理解和遵循的启发。尽管概念足够直白，但是人们还是很容易混淆抽象层级。

在较高层级放置可配置数据：
如果你有一个已知并该在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。

位于较高层级的配置性常量易于修改，它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。

避免传递浏览：
正确的做法是让直接协作者提供所需的全部服务，而不必逛遍系统的对象全图，搜寻我们要调用的方法。只要简单地写：
`myCollaborator.doSomething()` 

如果你用通配符导入某个包，则不需要存在具体的类。导入语句只在搜寻名称时把这个包列入查找路径。所以，这种导入并未构成真正的依赖，也就让我们的模块较少耦合。

软件中的名称对于软件可读性有90%的作用。你要花时间明智地起名，保持名称有关。名称太重要了，不可随意对待。

名称的长度应与作用范围的广泛度相关。对于较小的作用范围，可以用很短的名称，而对于较大的作用范围，就该用较长的名称。

在较长距离上，使用短名称的变量和函数会丧失其含义。名称的作用范围越大，名称就该越长、越准确。

不要用匈牙利语命名法污染你的名称。

名称应该说明函数、变量或类的一切信息。不要用名称掩蔽副作用。不要用简单的动词来描述做了不止一个简单动作的函数。