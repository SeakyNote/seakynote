关于类的第一条规则是类应该短小。第二条规则是还要更短小。

类的名称应当描述其权责。实际上，命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，那么这个类大概就太长了。类名越含糊，该类越有可能拥有过多权责。例如，如果类名中包含含义模糊的词，如 Processor、Manager 或 Super，那么这种现象往往说明有不恰当的权责聚集情况存在。

单一权责原则（SRP）认为，类或模块应该有且只有一条加以修改的理由。该原则既给出了权责的定义，又是关于类的长度的指导方针。类只应有一个权责只有一条修改的理由。

让软件能工作和让软件保持整洁，是两种截然不同的工作。我们中的大多数人脑力有限，只能更多地把精力放在让代码能工作上，而不是放在保持代码有组织和整洁上，这全然正确。
分而治之在编程行为中的重要程度，等同于其在程序中的重要程度。
问题是太多人在程序能工作时就以为万事大吉了。我们没能把思维转向有关代码组织和整洁的部分。我们直接转向了下一个问题，而没能回过头将臃肿的类切分为只有单一权责的去耦式单元。
与此同时，许多开发者害怕数量巨大的短小单一目的类会导致难以一目了然抓住全局。他们认为，要搞清楚一件较大工作如何完成，就得在类与类之间找来找去。
然而，有大量短小类的系统并不比有少量庞大类的系统拥有更多移动部件，其数量大致相等。问题是：你是想把工具归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱中呢？还是想要少数几个能随便把所有东西扔进去的抽屉？
每个达到一定规模的系统都会包括大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织，以便开发者知道到哪儿能找到东西，并且在某个特定时间只需要理解直接相关的复杂性。反之，拥有巨大、多目的类的系统，总是让我们在目前并不需要了解的一大堆东西中艰难跋涉。
再强调一下：系统应该由许多短小的类而不是少量巨大的类组成，每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。

类应该只有少数实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。

将大函数拆分为许多小函数时，往往也是将类拆分为多个小类的时机。程序会更加有组织，也会拥有更为透明的结构。

对于多数系统，修改将一直持续。每处修改都让我们冒着系统其他部分不能如期望般工作的风险。在整洁的系统中，我们对类加以组织，以降低修改的风险。

开放闭合原则（OCP）：类应当对扩展开放，对修改封闭。

我们希望精心组织系统，从而在添加或修改特性时尽可能少惹麻烦。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。

依赖倒置原则（Dependency Inversion Principle, DIP) ：类应当依赖抽象而不是依赖具体细节。