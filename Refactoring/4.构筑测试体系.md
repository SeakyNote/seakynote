要正确地进行重构，前提是得有一套稳固的测试集合，以帮我发现难以避免的疏漏。

确保所有测试都完全自动化，让它们检查自己的测试结果。

一套测试就是一个强大的 bug侦测器，能够大大缩减查找 bug 所需的时间。

测试驱动开发的编程方式依赖于下面这个短循环：先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁。

总是确保测试不该通过时真的会失败。

频繁地运行测试。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。

测试应该是一种风险驱动的行为，我测试的目标是希望找出现在或未来可能出现的bug。所以我不会去测试那些仅仅读或写一个字段的访问函数，因为它们太简单了，不太可能出错。


如果尝试撰写过多测试，结果往往反而导致测试不充分。事实上，即使我只做一点点测试，也从中获益良多。测试的重点应该是那些我最担心出错的部分，这样就能从测试工作中得到最大利益。

编写未臻完善的测试并经常运行，好过对完美测试的无尽等待。

为既有代码添加测试时最常用的方法：先随便填写一个期望值，再用程序产生的真实值来替换它，然后引入一个错误，最后恢复错误。

共享测试夹具会使测试间产生交互，这是滋生bug 的温床——还是你写测试时能遇见的最恶心的bug之一。

作一个基本规则，一个it语句中最好只有一个验证语句，否则测试可能在进行第一个验证时就失败，这通常会掩盖一些重要的错误信息，不利于你了解测试失败的原因。

考虑可能出错的边界条件，把测试火力集中在那儿。

在同一代码库的不同模块之间加入太多的检查往往会导致重复的验证代码，它带来的好处通常不抵害处，特别是你添加的验证可能在其他地方早己做过。

不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。

当测试数量达到一定程度之后，继续增加测试带来的边际效用会递减：如果试图编写太多测试，你也可能因为工作量太大而气馁，最后什么都写不成。你应该把测试集中在可能出错的地方。观察代码，看哪儿变得复杂：观察函数，思考哪些地方可能出错。是的，你的测试不可能找出所有bug，但一旦进行重构，你可以更好地理解整个程序，从而找到更多bug。虽然在开始重构之前我会确保有一个测试套件存在，但前进途中我总会加入更多测试。

一个架构的好坏，很大程度要取决于它的可测试性。

一个值得养成的好习惯是，每当你遇见一个bug，先写一个测试来清楚地复现它。仅当测试通过时，才视为bug修完。只要测试存在一天，我就知道这个错误永远不会再复现。这个bug 和对应的测试也会提醒我思考：测试集里是否还有这样不被阳光照耀到的犄角旮旯？

每当你收到bug报告，请先写一个单元测试来暴露这个 bug。

测试写得太多的一个征兆是，相比要改的代码，我在改动测试上花费了更多的时间—并且我能感到测试就在拖慢我。不过尽管过度测试时有发生，相比测试不足的情况还是稀少得多。
