如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。

每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码拥有一组可靠的测试。

重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。

无论每次重构多么简单，养成重构后即运行测试的习惯非常重要。犯错误是很容易的—至少我知道我是很容易犯错的。做完一次修改就运行测试，这样在我真的犯了错时，只需要考虑一个很小的改动范围，这使得查错与修复问题易如反掌。这就是重构过程的精髓所在：小步修改，每次修改后就运行测试。如果我改动了太多东西，犯错时就可能陷入麻烦的调试，并为此耗费大把时间。小步修改，以及它带来的频繁反馈，正是防止混乱的关键。

重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。

把代码推送（push）到远端仓库前，我会把零碎的修改压缩成一个更有意义的提交（commit）。

永远将函数的返回值命名为“result”，这样我一眼就能知道它的作用。

傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。

好代码应能清楚地表明它在做什么，而变量命名是代码清晰的关键。只要改名能够提升代码的可读性，那就应该毫不犹豫去做。

软件的性能通常只与代码的一小部分相关，改变其他的部分往往对总体性能贡献甚微。

对于重构过程的性能问题，我总体的建议是：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。

与复杂代码打交道时，细小的步子是快速前进的关键。

把复杂的代码块分解为更小的单元，与好的命名一样都很重要。

虽说言以简贵，但可演化的软件却以明确为贵。

编程时，需要遵循营地法则：
保证你离开时的代码库一定比来时更健康。

好代码的检验标准就是人们是否能轻而易举地修改它。

开展高效有序的重构，关键的心得是：小的步子可以更快前进，请保持代码永远处于可工作状态，小步修改累积起来也能大大改善系统的设计。

