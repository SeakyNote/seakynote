## 注释占比 15%左右

https://www.solidot.org/story?sid=65769

通过代码注释，可以看出代码作者的编码功底。新手写代码，要么不写注释，要么注释里尽写些废话，犹如画蛇添足；而优秀的程序猿写的注释言简意赅、恰到好处，有画龙点睛之妙。

## 标准制定

是否合理，还是制定者个人喜好，哪些地方需要制定规范

能否自动化/增加的工作量有多少？

主流项目是否制定了这个标准

## 代码检查

https://blog.csdn.net/qq_36631379/article/details/114533196

https://blog.csdn.net/qq_35333978/article/details/122347687

## google c++ 编程规范

https://zh-google-styleguide.readthedocs.io/en/latest/

https://google.github.io/styleguide/cppguide.html

## 更改 VS Code C++ 默认代码风格为 Google C++ Style

https://blog.csdn.net/sinat_34524528/article/details/85878592

## C++编程规范

https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main

## 有的注释风格需要许多重复性劳动，应舍弃之，改用易于维护的注释风格。

## 直接把代码注释掉是讨厌的做法。别这么干！

《代码整洁之道》4.4.12

## c++在提交代码到git时，要保留注释掉的代码吗？

通常情况下，在提交代码到 Git 时，建议不要将注释掉的代码保留在提交中。Git 提交应该只包含当前正在使用的代码，而不是注释掉的或被废弃的代码。

如果注释掉的代码是针对特定情况的备份或调试目的，最好将其保存在本地，而不要将其提交到共享的代码库中。这可以通过本地的备份或分支来实现。Git 提交的目的是记录代码的改变历史，如果注释掉的代码不再需要，最好将其删除，保持提交的干净和可读性。

然而，有时注释掉的代码可能对于理解历史上的更改或者作为参考是有用的。在这种情况下，可以考虑使用版本控制系统的一些技巧，比如使用 git blame 或 git log 来查看代码历史，而不必保留注释掉的代码在提交中。

## 魔法字符串

https://www.cnblogs.com/perhaps/archive/2005/07/06/187464.html

## BS C++ style

https://www.stroustrup.com/bs_faq2.html

## 匈牙利记法

NL.5: Avoid encoding type information in names

https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-knr

## c++101编程规范

https://killwing.github.io/c++-coding-standards.md.html

## 函数默认传递指针用const修饰

 `[CG]Con.3`

## 魔数/魔法字符串

ES.45: Avoid “magic constants”; use symbolic constants

## 不要用C风格转换

ES.49: If you must use a cast, use a named cast

## 成员函数与纯函数

Cpp Core Guidelines 的 "F.8: Prefer pure functions" 指导原则的核心在于 **强调函数的可预测性、可测试性和可维护性，并尽量避免副作用**。

理解这个原则的关键在于理解什么是“纯函数”。

**纯函数 (Pure Function) 的定义：**

1.  **确定性 (Deterministic):** 对于相同的输入，总是产生相同的输出。
2.  **无副作用 (No Side Effects):** 函数的执行不会修改外部状态，也不会依赖于外部的可变状态。这意味着函数不会：
    -   修改全局变量或静态变量。
    -   修改传入的引用或指针指向的数据（除非是显式地通过参数返回的修改）。
    -   执行 I/O 操作（如打印到控制台、读写文件）。
    -   抛出未捕获的异常（在某些严格的定义下）。

**为什么Cpp Core Guidelines 提倡纯函数？**

*   **可预测性:** 你可以确信给定输入，函数的行为总是相同的，这使得理解和推理代码变得更容易。
*   **可测试性:** 纯函数非常容易测试。你只需要提供输入并检查输出，无需设置复杂的测试环境或模拟外部依赖。
*   **可维护性:** 当一个函数没有副作用时，你可以安全地移动它、并行化它，或者将其优化，而不用担心破坏其他部分的代码。
*   **编译器优化:** 编译器可以更容易地对纯函数进行各种优化，例如死代码消除、循环展开等。

---

**对于类的成员函数，如果函数内需要使用成员变量，是否应把该成员变量作为函数的参数传入？**

**答案是：通常不建议将成员变量作为函数的参数传入，除非是为了实现更严格的“纯函数”定义，或者有特定的设计目的。**

让我们深入分析一下：

**成员函数与纯函数的权衡**

类的成员函数，特别是那些需要访问或修改类状态（即成员变量）的函数，**本质上很难完全符合纯函数的严格定义**。

*   **访问成员变量:** 即使函数不修改成员变量，它也依赖于类实例的状态。`this` 指针隐式地指向了类对象，而类对象包含了成员变量。因此，从最严格的意义上来说，一个访问成员变量的函数（即使只是读取）也 **不是一个纯函数**，因为它依赖于类的内部状态，而这个状态可以随时改变（通过其他方法）。
*   **修改成员变量:** 如果成员函数修改了成员变量，那么它就 **肯定不是纯函数**，因为它有副作用（修改了类的状态）。

**那么，"F.8: Prefer pure functions" 对成员函数意味着什么？**

这个原则更多的是一种**指导思想和目标**，而不是一个绝对的禁令。对于成员函数，我们可以从两个层面来理解：

1.  **尽可能模拟纯函数的特性:**
    -   **避免不必要的副作用:** 如果一个成员函数可以只读取成员变量而不需要修改它们，那么它应该尽量避免修改其他成员变量或全局状态。
    -   **明确的意图:** 函数的名称应该清晰地表明它是否会修改类的状态。例如，使用 `get` 前缀通常表示只读取，而没有前缀或使用 `set` 前缀则可能表示修改。
    -   **封装:** 类的成员变量本身就是封装的一部分。访问这些成员变量是类内部的“业务”，而不需要将它们暴露给外部作为参数。

2.  **将“纯”的概念应用到更细的粒度:**
    -   **辅助函数 (Helper Functions):** 在一个非纯的成员函数内部，你可以定义一些 **私有的辅助函数**。如果这些辅助函数只接受参数并且不修改任何外部状态（包括类的成员变量），那么它们可以被视为纯函数。这有助于提高代码的可读性和可测试性，即便整个成员函数不是纯的。

**关于将成员变量作为参数传入的讨论：**

将成员变量作为参数传入一个成员函数，在大多数情况下，这是一种**反模式 (anti-pattern)**，因为它破坏了面向对象设计的核心思想：

*   **破坏封装:** 类的成员变量是类的内部实现细节，不应该被暴露给成员函数本身作为参数。成员函数应该能够自然地访问它所属对象的状态。
*   **冗余:** 如果一个函数属于一个类 `MyClass`，并且需要访问 `MyClass` 的成员变量 `m_value`，那么在函数定义中写成 `void MyClass::my_func(int m_value)` 是多余的，并且会混淆 `this->m_value` 和传入的 `m_value`。
*   **增加复杂性:** 每次调用都需要显式传递成员变量，使得代码更冗长。

**什么时候可能会考虑（非常特殊的情况下）将成员变量作为参数传入？**

虽然不推荐，但有极少数情况下，你可能需要考虑这种做法，通常是为了**实现一个更严格的、与类实例状态解耦的计算逻辑**：

*   **将计算逻辑从对象中剥离:** 假设你有一个复杂的计算，它 *偶然地* 使用了某个成员变量的值，但这个计算本身也可以独立于对象存在。你可以创建一个**静态成员函数**（没有 `this` 指针）或一个**独立的非成员函数**，并将需要的成员变量作为参数传入。
    ```c++
    class MyClass {
        int data;
    public:
        int calculate_something() const {
            // 传统的成员函数方式
            return data * 2;
        }

        // 另一种思考方式：将计算逻辑剥离成一个独立的函数
        static int calculate_something_pure(int value) {
            // 这个函数是纯函数
            return value * 2;
        }

        int get_data() const { return data; }
    };

    // 在类的外部使用独立的纯函数
    MyClass obj;
    int result = MyClass::calculate_something_pure(obj.get_data());
    ```
    在这个例子中， `calculate_something_pure` 是一个纯函数，它接受一个 `int` 参数并返回一个 `int` 。我们仍然可以通过 `obj.get_data()` 来获取需要的值并传递给它。这并没有改变 `calculate_something` 的成员函数形式，但展示了将纯粹的计算逻辑独立出来的思想。

*   **测试中的模拟 (Mocking):** 在进行单元测试时，你可能需要模拟成员变量的行为。但通常这通过依赖注入或更高级的测试框架来实现，而不是直接在成员函数签名中修改。

**总结:**

Cpp Core Guidelines 的 "F.8: Prefer pure functions" 是一个重要的原则，它鼓励我们编写清晰、可预测和易于测试的代码。

*   对于**普通的成员函数**，它们通常需要访问或修改类的成员变量，因此 **难以成为严格意义上的纯函数**。
*   我们应该**尽量让成员函数在不修改类状态的情况下，只读取成员变量**，并避免不必要的副作用。
*   **不应该将成员变量作为参数传入成员函数**。这是违反封装原则的，并且冗余。成员函数天然地可以通过 `this` 指针访问其所属对象的成员变量。
*   可以将**纯粹的计算逻辑**从成员函数中剥离出来，作为静态成员函数或独立的非成员函数，并显式传递所需的参数。这样可以使这部分计算逻辑更符合纯函数的定义。

理解 "Prefer pure functions" 更多的是关于**软件设计的哲学**，即在可能的情况下，尽量追求无副作用和确定性，而不是要求所有成员函数都必须是纯的。对于成员函数，重点在于 **管理和控制副作用**，使其行为清晰可控。

## C.140: Do not provide different default arguments for a virtual function and an overrider

## F.9: Unused parameters should be unnamed
