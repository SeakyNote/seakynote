如果一个类同时包含了处理命令栈、格式化报告、打印报告和初始化全局数据的子程序，那么在命令栈和报告子程序或全局数据之间，我们很难看到任何联系。类的接口没有呈现出一致的抽象，所以该类的内聚性很差（越明显相关，说明内聚性越好）。这些子程序应重新组织到职能更专一的类中，每个类都通过其接口提供更好的抽象。

抽象数据类型（Abstract Data Type,ADT） 是数据和对这些数据进行的操作的一个集合。这些操作既向程序的其余部分描述数据，又允许程序的其余部分改变数据。“抽象数据类型”中的“数据”一词用得很宽泛。一个 ADT 可以是一个图形窗口和所有影响它的操作、一个文件和文件操作、一个保险费率表和对它的操作或者其他东西。

每个类都应实现一个且只有一个ADT。如发现某个类实现了不止一个 ADT，或无法确定该类实现了什么 ADT，就应将该类重新组织成一个或多个良好定义的ADT。

每个接口都由一个可编程的部分和一个语义部分构成。可编程部分（programmatic part）由数据类型和接口的其他属性构成，可由编译器予以强制（在编译时检查错误）。接口的语义部分（semantic part）则由关于这个接口应该如何使用的假设构成，这些假设无法由编译器强制。语义接口包括诸如“必须在RoutineB 之前调用RoutineA”或者“如果 dataMember1 在传递给RoutineA之前没有被初始化，RoutineA 将崩溃”之类的考虑。语义接口要用注释来说明，但要尽量保证不看这些说明也能理解接口。接口的任何方面如果不能被编译器强制，这个方面就可能被误用。想一些办法，利用断言或其他技术，将接口的语义元素转换为接口的可编程元素。

不要添加与接口抽象不一致的公共成员。每当类的接口添加子程序时，都要问：“这个子程序是否与现有接口提供的抽象一致？”如果不一致，就找一种不同的方式来修改，并保持抽象的完整性。
把抽象和内聚放在一起考虑。抽象和内聚的概念密切相关，呈现良好抽象的类接口通常有很强的内聚性。具有强大内聚性的类往往也会呈现出良好的抽象，虽然这种关系不如前者那么强。
我发现，相较于关注类的内聚性，若是关注类的接口所呈现的抽象性，往往能类的设计提供更多见解。如果发现一个类的内聚性很弱，但又不知道如何去纠正，就换个角度问：“这个类是否呈现了一致的抽象？”

如果没有封装，抽象往往会被打破。根据我的经验，要么同时拥有抽象和封装，要么两个都没有。没有所谓的中间地带。

“区分设计良好和不良的模块，最重要的因素在于，该模块在多大程度上对其他模块隐藏了它的内部数据和其他实现细节。”——布洛克（Joshua Bloch）

可以正确分清为什么要多重继承和能够正确运用多重继承的开发者少得可怜，甚至不到2%

避免友元类。在少数情况下，例如State 模式，可以谨慎使用友元类以管理复杂性（Gamma et al.1995）。但一般情况下，友元类违反了封装。它们增大了你在任何时候要考虑的代码量，从而增加了复杂性。

倾向于读代码方便而不是写代码方便。

“如果必须看底层实现才能理解发生的事情，就谈不上什么抽象。”——普劳戈 （P. J. Plauger）

任何时候，只要注意到自己需要看一个类的实现才能弄清楚如何使用该类，就意味着你并不是在为接口编程；而是在“通过”接口来为实现进行编程。如果是通过接口编程，封装就被打破了，一旦封装被打破，接着就该轮到抽象了。
如果不能仅仅根据类的接口文档来搞清楚如何使用该类，正确反应不是调出源代码并查看实现。意图很好，方法却是错的。正确的反应是联系该类的作者，说：“我不知道如何使用这个类。”类的作者的正确反应不是直接回答你的问题。相反，是签出类接口文件，修改类接口文档，签入文件，然后跟你说：“现在看看能不能理解它是怎么工作的。”像这样的对话你希望发生在接口代码本身，这样能留下来给未来的程序员看。你不希望这种对话只发生在自己的脑海中，因为这样会将微妙的语义依赖植入使用该类的客户代码中。你也不希望这个对话发生在人和人之间，这样的话，就说明它只适合你的代码，不适合其他人的。

警告数据成员超过7个的类。5-9被认为是一个人在执行其他任务时能记住的离散项目的数量（Miller 1956）。如果一个类包含的数据成员超过7个，就要考虑该类是否应分解成多个小类（Riel 1996）。如果数据成员是整数和字符串这样的基本数据类型，5-9可以往高了算；如果数据成员是复杂的对象，则往低了算。

继承（is a关系）是指一个类是另一个类的“特化”。

如果派生类不打算完全遵守基类所定义的相同接口契约，继承就不是正确的实现技术。请考虑使用“包含”（has a），或在继承层次结构的更上层进行修改。

除非派生类真的“is a”（是一个）基类更具体的版本，否则不应从基类继承。

子类必须能通过基类的接口来使用，使用者无需知道两者的差异。

基类中定义的所有子程序在任何派生类中使用时，其含义都应该相同。

如果只想使用类的实现而不是它的接口，应使用“包含”（has a） 而不是“继承”（is a）。

不要在派生类中重用不可覆盖的基类子程序名称。

对仅一个派生类的基类持怀疑态度。当我看到某个基类只有一个派生类时，会怀疑有的程序员做了“提前设计”，试图预测未来的需求，但通常并不完全理解这些未来的需求。要为将来做准备，最好的办法不是设计“某天可能会要到”的额外基类层级，而是使当前的工作尽可能清晰、直接和简单。这意味着不要创建非绝对必要的继承结构。

建议将继承层级限制在最多6层。

大多数人都很难在大脑中同时处理超过网到三层的继承关系。神奇数字5-9或许更适合限制基类的子类总数，而不是限制继承树的层级数。

嵌套过深的继承树与故障率的增加有密切的联系。

深的继承树增加了复杂性，而这恰恰与继承所要达到的目的背道而驰。牢记自己的首要技术使命。确保自己的目的是用继承来避免重复的代码，并尽量降低复杂性。

有的时候，case 语句被用来分隔真正不同种类的对象或行为。

如果派生类真的需要访问基类的属性，请改为在基类中提供 protected 访问器。

如果说继承是一把链锯，那么多重继承（multiple inheritance） 就是一把二十世纪五十年代的链锯，没有护罩，不支持自动关闭，马达也难以伺候。这样的工具有时还是有价值的；但大多数时候，最好还是把它妥善藏在车库里以绝后患。

多重继承主要用于定义“mixins”（混合体），即用来给对象增加一组属性的简单类。之所以取“mixins”这个名字，是因为它们允许属性被“混入” （mix in） 到派生类中。mixins 可以是像 Displayable（可显示）、Persistant（持久化）、Serializable（可序列化）或 Sortable（可排序）这样的类。mixins 几乎都是抽象的，不打算独立于其他对象进行实例化。

程序员只有在仔细考虑了替代方案，并权衡了对系统复杂性和可理解性的影响之后，才应该使用多重继承。

继承往往与你作为程序员的首要技术使命（管理复杂性）相违背。为了控制复杂性，应对继承持十分警惕的态度。

如果希望由基类控制你的接口，就选择继承；如果想控制自己的接口，就选择包含。

得墨忒耳法则可以简单地陈述为“只使用一个`.`操作符”。`a.b.Method()`违反了此法则，而 `a.Method()`不违反。一个简单的例子是，人可以命令一条狗行走（walk），但不应直接指挥狗的腿行走，应该由狗来指挥和控制自己的腿应该如何行走。

使用 private 构造函数强制单例属性。为了强制类只能实例化一个对象，可以隐藏该类的所有构造函数，再提供一个静态 `GetInstance()`子程序来访问该类的单一实例。

除非证明浅拷贝更佳，否则索性无脑使用深拷贝。

在编程项目中，抽象并不像 Shape 那样是现成的，所以必须更努力地归纳出清晰的抽象。

想出合适的抽象对象是面向对象设计的主要挑战之一。

创建类最重要的原因是降低程序的复杂性。创建类来隐藏信息，这样不用去考虑它们了。当然，写类的时候还是考虑这些信息。但写完之后，应该就能忘记这些细节，在不关心内部运作的情况下使用该类。

NASA 创建可重用类的方法的核心并不涉及“为重用而设计”。相反，NASA 是在其项目结束时确定要重用的候选者。然后，他们进行必要的工作，使这些类在主项目的最后作为一个特殊项目来重用，或作新项目的第一步来重用。这种方法有助于防止“镀金”，即创建不需要的功能，从而不必要地增加复杂性。

避免创建无所不知、无所不能的类。

类的接口应提供一致的抽象。许多问题都是由于违反该原则而引起的。

“包含”（has a）往往比“继承”（is a）更可取，除非必须建模 is a关系。

继承是有用的工具，但它会增加复杂性，这违背了软件的首要技术使命，即“管理复杂性”。

类是管理复杂性的首选工具。只有在设计类时给予足够的关注，才能实现这一目标。