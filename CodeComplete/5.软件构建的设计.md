不管以什么方式设计，小项目和大项目一样，都能从精心的设计中受益，而将设计作为一项明确的活动来认识，可以使你从中获得最大的收益。

好的设计对小的项目有用，对于大型的项目，更是不可或觖的刚需。

期望软件设计者以合理的、无错误的方式从需求说明中直接推导出设计，这是非常不现实的。从来没有一个系统是以这种方式开发的，以后也不可能有。

如果老师布置了一个编程作业，然后在刚完成设计时就修改了作业，在准备交作业时又改了一次，那么你可能会想给他涂上柏油，粘上羽毛。但是，这个过程正是专业程序员日常的基操。

派三个人去设计同一个程序，他们很容易带着三种截然不同的设计回来，而且每种都是完全可以接受的。做某些事情的时候，方法或许不止一种，但计算机程序的设计方法往往至少有好几十种。

由于设计是不确定的，所以设计技术往往是启发式（探索式）的，即需要用到“经验法则”或者“试行”的策略，而不是使用保证能产生可预测结果的一种可重复的过程。设计涉及试验和错误。一个设计工具或技术在一项工作或工作的一个方面做得很好，但在下一个项目中可能没那么有效。没有一种工具是万能的。

设计不会从人的大脑一出来便是完整形式。它们需要通过设计评审、非正式讨论、写代码的过程以及修改代码的过程来发展和改进。

项目失败最常见的原因是需求不到位、计划不周或管理不善。但是，当项目确实主要是因技术而失败时，原因往往是失控的复杂性。软件变得如此复杂，以至于没人真正知道它在做什么。一旦没人完全能够理解一个区域的代码变化对其他区域造成的影响，项目就无法进一步发展了。

没有谁的大脑真正足以容下一个现代计算机程序（Dijkstra 1972），这意味着作为软件开发人员，我们不应该尝试将整个程序一次性塞进自己的大脑。相反，应该用一种安全的、一次只专注于其中一部分的方法来组织程序。

在软件架构层面，问题的复杂性通过将系统划分为子系统来降低。人类理解几小段简单的信息比理解一大段复杂的信息要容易得多。所有软件设计技术的目标都是将复杂问题分成简单的部分。子系统越是独立，就越能使其安全地专注于解决一个复杂的点。

将复杂性降至最低。避免做“聪明的”设计。聪明的设计通常难以理解。相反，要做“简单的”和“容易理解的”设计。如果设计不能让你在沉浸在一个特定的部分时安全地忽略程序的其他大多数部分，这个设计就不对。

高扇出（超过7个）表明一个类使用了其他大量类，因此可能过于复杂。研究人员发现，无论考虑在一个子程序内调用的子程序数量，还是在一个类内使用的类的数量，低扇出原则都是有益的。

假设要写一个现代系统，但其中必须用到大量设计不良的旧代码，就可以在新系统中专门写一层来负责与旧代码的接口。这一层的设计宗旨是隐藏旧代码的低质量，为较新的层提供一组一致的服务。然后，让系统其余部分使用这些类而不是旧代码。在这种情况下，分层设计有两个好处：它可以把不良代码的混乱分隔开；如果以后可以抛弃旧代码或重构它，那么除了接口层，不需要修改任何新代码。

有的程序员直接从系统层跳到类的设计。但是，从更高层次的类的组合（比如子系统或包）来思考问题是有益的。

尤其重要的是各个子系统的通信规则。如果所有子系统都能与其他所有子系统通信，就丧失了将它们分开的好处。应该限制通信，使每个子系统变得有意义。

程序不应包含任何循环关系，即类A使用类B，类B使用类C，类C又使用类A。

抽象是指在使用一个概念时，安全忽略其部分细节的能力，也就是在不同层次处理不同细节的能力。任何时候只要使用一个集合体，就是在使用抽象。例如，假设将一个东西称 “房子”，而不是玻璃、木材和钉子的组合，就是在抽象。将房子的集合称为一个“镇”，也是在进行抽象。

封装是抽象的延续。抽象的意思是“你允许从高的细节层次观察对象。”封装的意思是“除此之外，你不可以从其他任何细节层次观察对象。

一种语言如果支持像Open或Close这样的操作，而且在运行时才知道具体处理的是哪种门，这种能力就称为“多态性”（polymorphism）。

继承是面向对象编程最强大的工具之一。如果用得好，它可以提供巨大的好处：如使用不当，它也会造成巨大的损失。

类的接口应尽可能少地透露其内部运作情况。类很像一座冰山：八分之七在水下，你只能看到水面以上的八分之一。

类的接口的设计是一个迭代过程，这和设计的其他方面是一样的。如果第一次没有把接口设计好，就多试几次，直到稳定下来。如果稳定不下来，就表明需要尝试一种不同的方法。

信息隐藏中的“秘密”主要有下面两种。
- 隐藏复杂性，这样你的大脑就不必处理它，除非你特别关注它。
- 隐藏变化源，这样当变化发生时，其影响被限制在局部。

另一个信息过度分散的例子是在系统中到处间插与人类用户的交互。假如交互方式发生变化（例如从GUI 界面改为命令行界面），那么几乎所有代码都要修改。最好将用户交互集中到单一的类、包或子系统中，这样在修改时就不至于影响整个系统。

习惯于深人思考哪些细节需要隐藏，有助于在所有层次上得到好的设计决策。它在构建层次促进了具名常量的使用（而不是使用字面量）。它有助于在类中创建良好的子程序名和参数名。它还为类和子系统的分解以及系统级互连的决策提供了指引。
养成习惯，多思考“我该隐藏哪些细节”。很快，你就会惊讶地发现，许多困难的设计问题都能迎刃而解。

编程和中情局的工作不一样；你不会因为偷偷摸摸而获得荣誉。它更像是广告业，你会因为使连接变得更显眼而获得大量荣誉。通过参数列表传递数据就建立了一种明显的连接，所以是好的。修改全局数据使另一个模块可以使用这些数据，则是一种偷偷摸摸的连接，所以不好。

从一组熟悉的替代方案中寻找，比从头创建一个自定义设计方案要容易得多。而且，相比完全自定义的代码，根据熟悉的模式来生成代码也更容易被读者理解。

模式一个潜在的陷阱是让代码强行使用某模式。一些情况下，稍微修改代码以符合一个公认的模式会提高代码的可理解性。但是，如果代码必须大幅修改，强迫使其看起来像一个标准模式，则可能增加复杂性。
模式另一个潜在的陷阱是特征强迫症：之所以使用一个模式，是因为想尝试这个模式，而不是因力该模式是合适的设计方案。

内聚性指的是类中的所有子程序或者子程序中的所有代码对一个中心目的支持有多紧密。换言之，类的目标有多集中。

如果其他所有方法都失败了，就放下这个问题。出去走走，或者在回到问题前先想点别的事情。如尽力而为之后也毫无进展，就清空大脑，抛开一段时间，这往往比纯粹的坚持更快见效。

自上而下往往开始时很简单，但有时低级别的复杂性会波及顶层，而这些会使事情变得复杂，完全没必要。自下而上往往开始时很复杂，但在早期识别这种复杂性会导致更好地设计更高层次的类，如果这种复杂性没有先使整个系统遭受破坏的话！
归根结底，自上而下和自下而上的设计并不是相互竞争的策略，两者是相辅相成的。设计是一个启发式（探索式）的过程，这意味着没有任何解决方案可以保证每次都能成功。试验和错误都是正常的设计元素。尝试各种不同的方法最合适、有效的。

如果我无法确定开始编码之前要对一个设计进行多深入的调研，会倾向于选择更多的细节。最大的设计错误来自于这样的情况：我认为已经走得够远了，但其实并没有走得多远，以至于没有意识到还存在其他设计挑战。换言之，最大的设计问题往往不是来自于我知道有困难而做了糟糕设计的领域，而是来自于我认为很容易而根本没有做任何设计的领域。我很少遇到因为做了太多的设计而受影响的项目。

我宁愿看到80%的设计工作用于创建和探索多种备选设计方案，20%用于创建粗略不太精炼的文档，也不愿意看到20% 用于创建平庸的设计方案，80% 的工作浪费在打磨拙劣的设计文档上。

如何判断多少设计才够？这是一道主观判断题，没有人能够完美做出判断。但是，虽然无法判断准确的设计量，但有两种设计量保证是错误的：设计每一个细节和根本不做任何设计。极端主义者所主张的两种立场，是两种必然错误的立场。

正如普劳戈（P.J.Plauger）所言：“应用一种设计方法时，越是教条，解决的现实问题就越少。”（Plauger 1993）。我们要将设计当作一个棘手的（wicked）、没有章法的（sloppy）、启发式的（heuristic）过程。不要满足于自己想到的第一个设计。要协作。要努力追求简单。在需要的时候进行原型设计。迭代，迭代，再迭代。到最后，得到一个让自己满意的设计。

软件的首要技术使命是管理复杂性。以简单性作为目标的设计方案对此最有帮助。

设计是一种启发式过程。固守于某种单一的方法会抑制创新能力，进而损及程序。

优秀的设计都是迭代而来的。尝试的设计可能性越多，最终的设计方案越好。
