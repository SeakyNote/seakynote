## 前言

应该让团队成员都参与制定标准

### 好的编程规范

改善代码质量

提高开发速度

增进团队精神

在正确的方向上取得一致

## 1. 组织和策略：新手先略过

### 0不要拘泥于小节

不要使用下划线或双下划线开始的名称

全大写字母表示宏（下划线连接）

类、函数、枚举，首字母大写

变量驼峰

私有成员变量形如likeThis_

宏形如LIKE_THIS

不规定注释风格，编写有用的注释；编写解释方法和原理的说明性注释

**禁止匈牙利记法**——泛型编程中不可行

### 1在高警告级别干净利落地进行编译

使用编译器最高警告级别

理解所有的警告

修改代码而非降低警告级别

### 2使用自动构建系统

### 3使用版本控制系统

版本控制系统中的代码必须总能构建成功

例外：只有一个程序员且从头至尾只需一周的项目，可能不需要版本控制系统

### 4做代码审查

有助于提高软件的安全性

内部培训的一种极佳方法

#### 静态代码检查工具

cppCheck

cpplint

Klocwork

## 2. 设计风格：好好体会

### 5一个实体应该只有一个紧凑的职责

#### 反面例子

realloc——承担太多任务

basic_string——巨大的类，多多益善的功能

### 6正确、简单和清晰第一

Keep It Simple Software, KISS

程序必须为阅读他的人而写，只是顺便用于机器执行——为人写代码

要避免使用程序设计语言中的冷僻特性，使用最简单有效的技术

### 7应知道何时和如何考虑可伸缩性

使用灵活的、动态分配的数据，不要使用固定大小的数组

了解算法的实际复杂性

优先使用线性算法或尽可能快的算法

尽可能避免劣于线性复杂性的算法

永远不要使用指数复杂性的算法，除非别无选择

### 8不要进行不成熟的优化

不成熟的优化定义：以性能为名，使设计或代码更复杂，从而导致可读性更差，但并没有经过验证的性能需求作为正当理由

优化只在必要的时候进行

要求进行优化时，先进行需求验证

例外：编写程序库

### 9不要进行不成熟的劣化

25/28/48

使用抽象和库

### 10尽量减少全局和共享数据

例外：cin/cout/cerr

### 11隐藏信息

不要公开提供抽象实体的内部信息

不要将类的数据成员设置成public

例外struct：数据本身就是接口

### 12懂得何时和如何进行并发性编程

尽量减少共享对象

安全地共享必须共享的对象

避免死锁、活锁和恶性的竞争条件

### 13确保资源为对象所拥有。使用显示的RAII和智能指针

例外：智能指针的过度使用，如在类内部，使用原始指针

## 3. 编码风格：新手要好好看

### 14宁要编译时和连接时错误，也不要运行时错误

充分利用静态检查功能

### 15积极使用const

### 16避免使用宏

例外：#include保护符guard；#ifdef和#if defined；assert实现

### 17避免使用魔数

### 18尽可能局部地声明变量

变量的生存期越短越好

例外：有时将变量提出循环是有好处的；对常量不适用

### 19总是初始化变量

使用默认初始值或?:

使用函数替代复杂的计算流

初始化数组{'\0'}

例外：缓冲区数据、volatile型数据

### 20避免函数过长，避免嵌套过深

尽量紧凑

不要自我重复

优先使用&&

优先使用标准算法

不要根据类型标签进行分支，优先使用多态函数

例外：若一个函数的功能无法合理地重构为多个独立的子任务，那么较长和嵌套较多就是合理的

### 21避免跨编译单元的初始化依赖

尽可能避免使用名字空间级的变量

### 22尽量减少定义性依赖。避免循环依赖

不要过分依赖

不要互相依赖，应依赖于抽象，定义独立的抽象类

例外：类之间的依赖循环不一定是坏事，只要被认为属于同一模块，一起测试，一起发布

### 23头文件应该自给自足

不要包含不需要的头文件

### 24总是编写内部#include保护符，绝不要编写外部#include保护符

## 4. 函数与操作符

### 25正确地选择通过值、指针或引用传递参数

### 26保持重载操作符的自然语义

### 27优先使用算数操作符和赋值操作符的标准形式

要定义a+b，也要定义a+=b

### 28优先使用++和--的标准形式。优先调用前缀形式

### 29考虑重载以避免隐含类型转换

### 30避免重载&& ||  逗号

### 31不要编写依赖于函数参数求值顺序的代码

如Transmogrify(++x, ++x)

## 5. 类设计和继承：最好有OOP理论功底

### 32弄清所要编写的是哪种类

值类；基类；traits类；策略类；异常类；附属类

### 33用小类代替巨类

只体现一个概念，颗粒层次恰到好处

更便于理解，被人使用和重用的可能性也越大

更易于部署

巨类削弱封装性

巨类更难保证正确和错误安全

### 34用组合代替继承

### 35避免从并非要设计成基类的类中继承

### 36优先提供抽象接口

### 37公用继承即可替换性。继承，不是为了重用，而是为了被重用

### 38实施安全的覆盖

### 39考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的

### 40要避免提供隐式转换

### 41将数据成员设为私有的，struct除外

### 42不要公开内部数据

### 43明智地使用Pimpl

理由：C++可访问性和可见性之间的差异

### 44优先编写非成员非友元函数

### 45总是一起提供new和delete

### 46如果提供类专门的new，应该提供所有标准形式（普通、就地和不抛出）

## 6. 构造、析构、拷贝

### 47以同样的顺序定义和初始化成员变量

### 48在构造函数中用初始化代替赋值

### 49避免在构造函数和析构函数中调用虚拟函数

### 50将基类析构函数设为公用且虚拟的，或者保护且非虚拟的

### 51析构函数、释放和交换绝对不能失败

### 52一致地进行复制和销毁

### 53显式地启用或者禁止复制

### 54避免切片，在基类中考虑用克隆代替复制

### 55使用赋值的标准形式

### 56只要可行，就提供不会失败的swap

## 7. 名空间和模块：对大型项目研发有帮助

### 57将类型及非成员函数接口置于同一名字空间中

### 58应该将类型和函数分别置于不同的名字空间中，除非有意想让他们一起工作

### 59不要在头文件中或者#include之前编写名字空间using

### 60要避免在不同的模块中分配与释放内存

### 61不要在头文件中定义具有链接的实体

### 62不要允许异常跨越模块边界传播

### 63在模块的接口中使用具有良好可移植性的类型

## 8. 模板和范型：新手先略过

### 64理智地结合静态多态性和动态多态性

### 65有意地进行显式自定义

### 66不要特化函数模板

### 67不要无意地编写不通用的代码

## 9. 错误处理和异常：要深刻领会

### 68广泛地使用断言记录内部假设和不变式

### 69建设合理的错误处理策略，并严格遵守

### 70区别错误和非错误

### 71设计和编写错误安全代码

### 72优先使用异常报告错误

### 73通过值抛出，通过引用捕获

### 74正确地报告、处理和转换错误

### 75避免使用异常规范

## 10. STL容器和算法：好好看看

### 容器

#### 76默认时使用vector

#### 77用vector和string代替数组

#### 78使用vector和string::c_str与非C++ API交换数据

#### 79在容器中只存储值和智能指针

#### 80用push_back代替其他扩展序列的方式

#### 81多用范围操作，少用单元素操作

#### 82使用公认的惯用法真正地压缩容量，真正地删除元素

swap魔术

erase-remove惯用法

### 算法

#### 83使用带检查的stl实现

#### 84使用算法代替手工编写的循环

#### 85使用正确的STL查找算法

#### 86使用正确的STL排序算法

#### 87使谓词成为纯函数

#### 88算法和比较器的参数应该多用函数对象少用函数

#### 89正确编写函数对象

## 11. 类型安全：与C的缺点有关

### 90避免使用类型分支，多使用多态

### 91依赖类型，而非其表示方式

### 92避免使用reinterpret_cast

### 93避免对指针使用static_cast

### 94避免强制转换const

### 95不要使用C风格的强制转换

### 96不要对非POD进行memcpy或memcmp

### 97不要使用联合重新解释表示方式

### 98不要使用可变长参数(...)

### 99不要使用失效对象，不要使用不安全函数

### 100不要多态地处理数组
