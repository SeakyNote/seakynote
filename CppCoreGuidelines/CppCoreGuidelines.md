# P: Philosophy

### P.1: 在代码中直接表达你的想法

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

### P.2: 用 ISO 标准 C++ 来编码

使用最新版的 C++ 编译器（目前支持 C++20 或 C++17），并打开禁用语言扩展的选项。

### P.3: 表达你的设计意图

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

### P.4: 理想情况下，程序应当是静态类型安全的

* `union` - 使用 `variant`（C++17 提供）
* 强制转换 - 尽可能减少其使用；使用模板有助于这点
* 数组退化 - 使用 `span`
* 范围错误 - 使用 `span`
* 窄化转换 - 尽可能减少其使用

### P.5: 编译期检查优先于运行时检查

为了代码清晰性和性能。 对于编译期识别的错误是不需要编写错误处理的。

### P.6: 应当使无法在编译期进行的检查能够在运行时实施

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

### P.7: 尽早识别运行时错误

避免“神秘的”程序崩溃。 避免能够产生（也许无法识别的）错误结果的程序错误。

### P.8: 不要泄漏任何资源

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。 这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

### P.9: 不要浪费时间或空间

你用的语言是 C++。

### P.10: 不可变数据优先于可变数据

对常量进行推理要比变量简单得多。 不可变的事物是不可能被意外改变的。 不可变性有时候也带来更好地进行优化的机会。 在常量上不会出现数据竞争。

### P.11: 把杂乱的构造封装起来，而别让其散布到代码中

杂乱的代码更有可能隐藏有 Bug 而且难于编写。 而好的接口使用起来更容易和安全。 杂乱的，底层的代码会混杂出更多这样的代码。

### P.12: 适当采用支持工具

许多事情机器都比人做得更好。 对于重复劳动，计算机既不会累也不会厌烦。 相对于重复性的例行任务，我们通常可以做一些更有意义的事情。

### P.13: 适当采用支持程序库

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量； 如果你的大部分工时都必须耗费在实现上的话， 程序库的质量和文档很可能要比你能做到的要好得多。 程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。 一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。 对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。 因此，如果你的应用领域中存在合适的程序库的话，请使用它。

# I: Interfaces

### I.1: 使接口明确

* 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。
* 函数不能对声明于命名空间作用域的变量进行写入操作。

### I.2: 避免非  `const`  全局变量

非  `const`  全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

### I.3: 避免使用单例

单例基本上就是经过伪装的更复杂的全局对象。

### I.4: 使接口严格和强类型化

* 报告将 `void*` 用作参数或返回类型的情况
* 报告使用了多个 `bool` 参数的情况
* 查找使用了过多基础类型的参数的函数。

### I.5: 说明前条件（如果有）

在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

### I.7: 说明后条件

以检测到对返回结果的误解，还可能发现实现中存在错误。

### I.9: 当接口是模板时，用概念来文档化其参数

更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

### I.10: 使用异常来表明无法实施所要求的任务

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。 这是错误的一个主要来源。
我们并不认为“性能”是一种不使用异常的合理理由。
* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，把检查从代码的关键部分中移出去。
* 长期来看，更规整的代码会得到更好的优化。
* 在做出性能相关的声明前一定要小心地进行测量。

### I.11: 决不以原始指针（ `T*` ）或引用（ `T&` ）来传递所有权

如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。

### I.13: 不要只用一个指针来传递数组

(pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

### I.22: 避免全局对象之间进行复杂的初始化

复杂的初始化可能导致未定义的执行顺序。

### I.23: 保持较少的函数参数数量

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。
两个最常见的使得函数具有过多参数的原因是：
1. _缺乏抽象_ 缺少一种抽象，使得一个组合值被以 一组独立的元素的方式进行传递，而不是以一个单独的保证了不变式的对象来传递。 这不仅使其参数列表变长，而且会导致错误， 因为各个成分值无法再被某种获得保证的不变式进行保护。  
2. _违反了“函数单一职责”原则_ 这个函数试图完成多项任务，它可能应当被重构。
多少参数算很多？请使用少于四个参数。 有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

### I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参

相同类型的相邻参数很容易被不小心互换掉。

### I.25: 优先以空抽象类作为类层次的接口

空的（没有非静态成员数据）抽象类要比带有状态的基类更倾向于保持稳定。

### I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。

### I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法

由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议， 对这些实现细节的改动都要求使用了这类的所有用户全部重新编译。而持有指向实现的指针（Pimpl）的 非多态的接口类，则可以将类的用户从其实现的改变隔离开来，其代价是一层间接。

```cpp
//header
class widget {
    class impl;
    std::unique_ptr<impl> pimpl;
public:
    void draw(); // public API that will be forwarded to the implementation
    widget(int); // defined in the implementation file
    ~widget();   // defined in the implementation file, where impl is a complete type
    widget(widget&&) noexcept; // defined in the implementation file
    widget(const widget&) = delete;
    widget& operator=(widget&&) noexcept; // defined in the implementation file
    widget& operator=(const widget&) = delete;
};
```

```cpp
//source
class widget::impl {
    int n; // private data
public:
    void draw(const widget& w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl->draw(*this); }
widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
widget::widget(widget&&) noexcept = default;
widget::~widget() = default;
widget& widget::operator=(widget&&) noexcept = default;
```

### I.30: 将有违规则的部分封装

维持代码简单且安全。 有时候因为逻辑的或者性能的原因，需要使用难看的，不安全的或者易错的技术。 此时，将它们局部化，而不是使其“感染”接口，可以避免更多的程序员团队必须当心其 细节和微妙之处。 如果可能的话，实现复杂度不能通过接口渗透到用户代码之中。
# F: Functions
## F.def: Function definitions
### F.1: 把有意义的操作“打包”成为精心命名的函数
把公共的代码分解出去，将使代码更易于阅读，更可能被重用，并能够对源于复杂代码的错误有所限制。 如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。
### F.2: 一个函数应当实施单一一项逻辑操作
仅实施单一操作的函数易于理解，测试和重用。
- 把具有多个“输出”参数的函数当作有问题的。使用返回值来代替，包括以 `tuple` 用作多个返回值。
- 把无法装入编辑器的一屏之内的“大型”函数当作有问题的。考虑把这种函数分解为较小的恰当命名的子操作。
- 把有七个或更多参数的函数当作有问题的。
### F.3: 保持函数短小简洁
大型函数难于阅读，更有可能包含复杂的代码，而且更有可能含有其作用域超过最低限度的变量。 带有复杂的控制结构的函数更有可能变长，也更有可能隐藏逻辑错误于其中。
- 标记无法“放入一屏”的函数。 一屏有多大？可以试试 60 行，每行 140 个字符；这大致上就是书本页面能够适于阅读的最大值了。
- 标记过于复杂的函数。多复杂算是过于复杂呢？ 应当用圈复杂度来度量。可以试试“多于 10 个逻辑路径”。一个简单的开关算作一条路径。
### F.4: 如果函数可能必须在编译期进行求值，就将其声明为 `constexpr`
需要用 `constexpr` 来告诉编译器允许对其进行编译期求值。
### F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`
有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。 请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。 可是我们还在等。 （显式地，或于类定义体中编写成员函数而隐式地）将其指定为内联能够促进编译器工作得更好。
如果函数超过三条语句，并且可以声明为非内联的（比如类成员函数），请考虑使其非内联。
### F.6: 如果函数必然不会抛出异常，就将其声明为 `noexcept`
如果不打算抛出异常的话，程序就会认为无法处理这种错误，并且应当尽早终止。把函数声明为 `noexcept` 对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。
- 标记不是 `noexcept`，而又不能抛出异常的函数。
- 标记抛出异常的 `swap`，`move`，析构函数，以及默认构造函数。
### F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针
智能指针的传递会转移或者共享所有权，因此应当仅在有意要实现所有权语义时才能使用。 不操作生存期的函数应当接受原始指针或引用。
使用按智能指针传递方式把函数限制为只能服务于使用智能指针的调用方。 需要一个 `widget` 的函数应当能够接受任何 `widget` 对象，而不只是由某种特定种类的智能指针管理其生存期的那些。
智能指针的传递（比如 `std::shared_ptr`）暗含了一些运行时成本。
- 若函数接受可复制的智能指针类型（即重载了 `operator->` 或 `operator*`），但该函数仅调用了：`operator*`、`operator->` 或 `get()`，则给出警告。 建议代之以 `T*` 或 `T&`。
- 对于智能指针类型（重载了 `operator->` 或 `operator*` 的类型）的参数，若它是可复制/可移动的，但从没有从函数体中被复制/移动出来，且从未对其进行修改，且未将其传递给会修改它其他函数，对之进行标记。这意味着并未使用其所有权语义。 建议代之以 `T*` 或 `T&`。
### F.8: 优先采用纯函数
纯函数更容易进行推导，有时候也更易于优化（甚至并行化），有时候还可以进行存储。
### F.9: 未使用的形参应当没有名字
可读性。 抑制未使用形参的警告消息。
### F.10: 若操作可被重用，则应为其命名
文档，可读性，重用机会。
### F.11: 当需要仅在一处使用的简单函数对象时使用无名 lambda
使代码精简，提供比其他方式更好的局部性。
## F.call: Parameter passing
### F.15: 优先采用简单的和传统的信息传递方式
![](assets/Pasted%20image%2020250723214928.png)
![](assets/Pasted%20image%2020250723214946.png)
### F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递
既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。
何谓“复制操作廉价”依赖于机器的架构，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。 当可以廉价复制时，没什么比得过进行复制的简单性和安全性，而且对于小型对象（最多两三个机器字）来说，也比按引用传递更快，因为它不需要在函数中进行一次额外的间接访问。
- 当按值传递的参数的大小大于 `2 * sizeof(void*)` 时给出警告。 建议代之以 `const` 的引用。
- 当按 `const` 引用传递的参数的大小小于或等于 `2 * sizeof(void*)` 时给出警告。建议代之以按值传递。
- 当按 `const` 引用传递的参数被 `move` 时给出警告。
### F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递
让调用者明了这个对象假定将会被改动。
- 对带有指向非 `const` 的引用参数但又_不_向其进行写入的函数给出警告。
- 当按引用传递的非 `const` 参数被进行 `move` 时给出警告。
### F.18: 对于“将被移动（will-move-from）”参数，按 `X&&` 进行传递并对参数 `std::move`
这样做很高效，并且消除了调用点的 BUG：`X&&` 绑定到右值，而要传递左值的话则要求在调用点明确进行 `std::move`。
- 对于所有 `X&&` 参数（其中的 `X` 不是模板类型参数的名字），如果函数体中使用它时没有用 `std::move`，就将其标明。
- 标明对已经被移动过的对象的访问。
- 不要有条件地从对象进行移动。
### F.19: 对于“转发（forward）”参数，按 `TP&&` 进行传递并只对参数 `std::forward`
对于接受 `TP&&` 参数的函数（其中的 `TP` 是模板类型参数的名字），如果函数对它做了任何别的事，而不是在每个静态路径中都正好进行一次 `std::forward`，或者在每个静态路径中对其进行多次 `std::forward` 但限定为不同的数据成员均正好进行一次，就将函数进行标明。
### F.20: 对于“输出（out）”值，采用返回值优先于输出参数
返回值是自我说明的，而 `&` 参数则既可能是输入/输出的也可能是仅输出的，并且倾向于被误用。
适用的情况也包括如标准容器这样的大型对象，它们为性能因素使用了隐式的移动操作，并且避免进行显式的内存管理。
当有多个值要返回时，使用元组或者类似的多成员类型。
对于指代非 `const` 的引用参数，如果其被写入之前未进行过读取，而且其类型能够廉价地返回，则标记它们；它们应当是“输入”的返回值。
### F.21: 要返回多个“输出”值，优先返回结构体
返回值是自我说明为“仅输出”值的。 注意，C++ 是支持多返回值的，按约定使用的是元组式类型（`struct`、`array`、`tuple` 等）， 在调用处使用结构化绑定（C++17）可以获得更多便利。 如果可能则优先使用具名 `struct`。 不过，`tuple` 在变参模板中很有用。
- 输出参数应当被替换为返回值。 输出参数时由函数写入的，调用了非 `const` 成员函数的，或者将它作为非 `const` 参数继续传递的参数。
- 如果可能，`pair` 或 `tuple` 返回类型应当替换为 `struct`。 变参模板中通常无法避免 `tuple`
### F.60: 当“没有参数”是有效的选项时，采用 `T*` 优先于 `T&`
指针（`T*`）可能为 `nullptr`，而引用（`T&`）则不能，不存在合法的“空引用”。 有时候用 `nullptr` 作为一种代表“没有对象”的方式是有用处的，但若是没有这种情况的话，使用引用的写法更简单，而且可能会产生更好的代码。
### F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象
可读性：这样能够明确普通指针的含义。 带来了显著的工具支持。
```cpp
void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // 不好: 不知道 p 是不是指向了 n 个元素；
                    // 应当假定它并非如此，否则应当使用 span<int>
    cout << s;      // 不好: 不知道 s 指向的是不是以零结尾的字符数组；
                    // 应当假定它并非如此，否则应当使用 zstring
    delete q;       // 不好: 不知道 *q 是不是在自由存储中分配的；
                    // 否则应当使用 owner
}
```
更好的做法
```cpp
void use2(span<int> p, zstring s, owner<int*> q)
{
    p[p.size() - 1] = 666; // OK, 会造成范围错误
    cout << s; // OK
    delete q;  // OK
}
```
### F.24: 用 `span<T>` 来代表一个半开序列
非正式和不明确的范围（range）是一种错误来源。
```cpp
void f(span<int> s)
{
    // 范围的遍历（保证正确进行）
    for (int x : s) cout << x << '\n';

    // C 风格的遍历（可能带有检查）
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // 随机访问（可能带有检查）
    s[7] = 9;

    // 截取指针（可能带有检查）
    std::sort(&s[0], &s[s.size() / 2]);
}
```
当对指针参数的访问是以其他整型类型的参数为边界限定时，就给出警告并建议改用 `span`。
### F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权
使用 `unique_ptr` 是安全地传递指针的最廉价的方式。
当函数返回了局部分配了的原始指针时就给出警告。建议改为使用 `unique_ptr` 或 `shared_ptr`。
### F.27: 用 `shared_ptr<T>` 来共享所有权
使用 `std::shared_ptr` 是表示共享所有权的标准方式。其含义是，最后一个拥有者负责删除对象。
### F.42: 返回 `T*` 来（仅仅）给出一个位置
指针就是用来干这个的。 使用 `T*` 来传递所有权其实是一种误用。
- 标记出施加在普通 `T*` 上的 `delete`，`std::free()` 等等。 只有所有者才能被删除。
- 标记出赋值给普通 `T*` 的 `new`，`malloc()` 等等。 只有所有者才应当负责进行删除。
### F.43: 不要（直接或间接）返回指向局部对象的指针或引用
避免由于使用了这种悬挂指针而造成的程序崩溃和数据损坏。
- 编译器通常可以发现返回局部对象 引用，许多情况下也可以发现返回指向局部对象的指针。
- 静态分析可以发现许多常见的确定指针位置的使用模式（因而可以消除掉悬挂指针）
### F.44: 当不想进行复制，而“没有对象被返回”不是有效的选项时，返回 `T&`
语言规则保证 `T&` 会指代对象，因此不需要对其测试 `nullptr`。
```cpp
class Car
{
    array<wheel, 4> w;
    // ...
public:
    wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }
    // ...
};

void use()
{
    Car c;
    wheel& w0 = c.get_wheel(0); // w0 与 c 的生存期相同
}
```
对不存在可能产生 `nullptr` 的 `return` 表达式的函数进行标记。
### F.45: 不要返回 `T&&`
它要求返回对已销毁的临时对象的引用。 `&&` 是吸引临时对象的符号。
对除了 `std::move` 和 `std::forward` 之外的任何把 `&&` 作为返回类型的情况都进行标记。
### F.46: `int` 是 `main()` 的返回类型
这是一条语言规则，但通常被“语言扩展”所违反，因此值得一提。 把 `main`（即程序中的那个全局的 `main`）声明为 `void` 会限制其可移植性。
### F.47: 赋值运算符返回 `T&`
运算符重载的惯例（尤其是对于具体类型来说），是让 `operator=(const T&)` 实施赋值之后返回（非 `const`）的 `*this`。这就确保了与标准库类型之间的一致性，并遵从了 “像 `int` 一样工作”的原则。
```cpp
class Foo
{
 public:
    ...
    Foo& operator=(const Foo& rhs)
    {
      // 复制各个成员。
      ...
      return *this;
    }
};
```
### F.48: 不要用 `return std::move(local)`
返回局部变量会隐式地移动它。 显式的 `std::move` 总是不良的实践，因为它会阻碍可以把移动完全消除掉的返回值优化（RVO）。
### F.49: 不要返回 `const T`
不建议返回 `const` 值。 这种老旧的建议已经过时了；它并不会带来什么价值，而且还会对移动语义造成影响。
```cpp
const vector<int> fct();    // 不好: 这个 "const" 带来的麻烦超过其价值

void g(vector<int>& vx)
{
    // ...
    fct() = vx;   // 被 "const" 所禁止
    // ...
    vx = fct(); // 昂贵的复制："const" 抑制掉了移动语义
    // ...
}
```
标记 `const` 返回值。修正方法：移除 `const` 使其变为返回非 `const` 值。
### F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda
函数不能俘获局部变量且不能在局部作用域中进行定义；当想要这些能力时，如果可能就应当使用 lambda，不行的就用手写的函数对象。另一方面，lambda 和函数对象是不能重载的；如果想要重载，就优先使用函数（让 lambda 重载的变通方案相当繁复）。如果两种方式都不行的话，就优先写一个函数；应当只使用所需的最简工具。
```cpp
// 编写只会接受 int 或 string 的函数
// -- 重载是很自然的
void f(int);
void f(const string&);

// 编写需要俘获局部状态的函数对象，可以出现于
// 语句或者表达式作用域中 -- lambda 更自然
vector<work> v = lots_of_work();
for (int tasknum = 0; tasknum < max; ++tasknum) {
    pool.run([=, &v] {
        /*
        ...
        ... 处理 v 的 1 / max, 即第 tasknum 个部分
        ...
        */
    });
}
pool.join();
```
有名字的非泛型 lambda（比如 `auto x = [](int i) { /*...*/; };`），而其并未发生俘获并且出现于全局作用域，对它们给出警告。代之以编写常规的函数。
### F.51: 如果需要作出选择，采用默认实参应当优先于进行重载
默认实参本就是为一个单一实现提供替代的接口的。 无法保证一组重载函数全部都实现相同的语义。 使用默认实参可以避免出现代码重复。
### F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获
为了效率和正确性，当使用局部的 lambda 时，你基本上总是需要进行按引用俘获。这也包括编写或者调用并行算法的情形，因为它们在返回前会进行联结。
### F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获
指向局部对象的指针和引用不能超出它们的作用域而存活。按引用捕获的 lambda 恰是另外一种保存指向局部对象的引用的地方，因而当它们（或其副本）存活超出作用域的话，也不应该这样做。
- 当捕获列表中包含指代局部声明的变量的引用时给出警告。
- 当捕获列表中包含指代局部声明的变量的引用，而 lambda 被传递给非 `const` 且非局部的上下文时，进行标记。
### F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）
这是容易混淆的。在成员函数里边写 `[=]` 貌似会按值来俘获，但其实会按引用俘获数据成员，因为它实际上按值俘获了不可见的 `this` 指针。如果你确实要这样做的话，请把 `this` 写明。
```cpp
class My_class {
    int x = 0;
    // ...

    void f()
    {
        int i = 0;
        // ...

        auto lambda = [=] { use(i, x); };   // 不好: “貌似”按复制/按值俘获

        x = 42;
        lambda(); // 调用 use(0, 42);
        x = 43;
        lambda(); // 调用 use(0, 43);

        // ...

        auto lambda2 = [i, this] { use(i, x); }; // ok, 最明确并且最不混淆

        // ...
    }
};
```
若指定了默认俘获（如 `=` 或 `&`）的 lambda 俘获列表并且还俘获了 `this` 的情况——无论是如 `[&, this]` 这样显式，还是通过 `[=]` 这样的默认俘获而又在函数体中使用了 `this`——对此进行标识。
### F.55: 不要使用 `va_arg` 参数
从 `va_arg` 中读取时需要假定确实传递了正确类型的参数。 而向变参传递时则需要假定将会读取正确的类型。 这样是很脆弱的，因为其在语言中无法一般性地强制其安全，因而需要靠程序员的纪律来保证其正确。
- 为 `va_list`，`va_start`，或 `va_arg` 的使用给出诊断。
- 如果 vararg 参数的函数并未提供重载以为该参数位置指定更加特定的类型，则当其传递参数时给出诊断。修正：使用别的函数，或标明 `[[suppress("types")]]`。
### F.56: 避免不必要的条件嵌套
浅层嵌套的条件语句使代码容易理解。也会使缩进结构清楚明了。 力求将基础代码放在最外层作用域，除非这样做会搞乱缩进。
```cpp
// 不好：深层嵌套
void foo() {
    ...
    if (x) {
        computeImportantThings(x);
    }
}

// 不好：还有多余的 else。
void foo() {
    ...
    if (!x) {
        return;
    }
    else {
        computeImportantThings(x);
    }
}

// 好：提早返回，无多余 else
void foo() {
    ...
    if (!x)
        return;

    computeImportantThings(x);
}
```
```cpp
// 不好：不必要的条件嵌套
void foo() {
    ...
    if (x) {
        if (y) {
            computeImportantThings(x);
        }
    }
}

// 好：合并条件 + 提早返回
void foo() {
    ...
    if (!(x && y))
        return;

    computeImportantThings(x);
}
```
标记多余的 `else`。 对函数体仅为包含一个代码块的条件语句的函数进行标记。
# C: Classes and class hierarchies
### C.1: 把相关的数据组织到结构中（`struct` 或 `class`）
易理解性。 如果数据之间（以基本的原因而）相关，应当在代码中体现这点。
### C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`
可读性。 易理解性。 `class` 的使用会提醒程序员需要考虑不变式。 这是一种很有用的惯例。
查找所有数据都私有的 `struct` 和带有公开成员的 `class`。
### C.3: 用类来表示接口和实现之间的区别
接口和实现之间的明确区别能够提升可读性并简化维护工作。
### C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员
比成员函数更少的耦合，减少可能由于改动对象状态而造成问题的函数，减少每当改变内部表示时需要进行修改的函数数量。
- 寻找并不直接访问数据成员的非 `virtual` 成员函数。
- 忽略 `virtual` 函数。
- 忽略至少包含一个访问了 `private` 成员的函数的重载集合中的函数。
- 忽略返回 `this` 的函数。
### C.5: 把辅助函数放在其所支持的类相同的命名空间之中
辅助函数是（由类的作者提供的）并不需要直接访问类的内部表示的函数，它们也被当作是类的可用接口的一部分。 把它们和类放在相同的命名空间中，使它们与类的关系更明显，并允许通过基于参数的查找机制找到它们。
- 对接受某一个命名空间中的参数类型的全局函数进行标记。
### C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量
在同一个声明式中混合类型的定义和另一个实体的定义会导致混淆，而且不是必要的。
- 如果类或者枚举的定义式的 `}` 后面没有跟着 `;` 就标记出来。它缺少了 `;`。
### C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`
可读性。 表明有些东西被隐藏或者进行了抽象。 这是一种有用的惯例。
对于声明为 `struct` 的类，当其带有 `private` 或 `protected` 成员时就进行标记。
### C.9: 让成员的暴露最小化
封装。 信息隐藏。 使发生意外访问的机会最小化。 这会简化维护工作。
- 标记 protected 数据。
- 标记混合的 public 和 private 数据。
## C.concrete: Concrete types
### C.10: 优先使用具体类型而不是类继承层次
具体类型在本质上就比类继承层次中的类型更简单： 它们更易于设计，更易于实现，更易于使用，更易于进行推理，更小，也更快。 使用继承层次是需要一些理由（用例）来支持的。
### C.11: 使具体类型正规化
正规类型比不正规的类型更易于理解和进行推导（不正规性会导致理解和使用上花费更多的精力）。

C++ 内建类型都是正规的，标准程序库的一些类型，如 `string`，`vector`，和 `map` 也是如此。可以定义没有赋值和相等比较的具体类，但它们很罕见（理当如此）。
### C.12: 不要令可复制或移动类型的数据成员为 `const` 或引用
`const` 和引用数据成员在可复制或移动类型中没什么用处，还会由于微妙的原因使这种类型变得至少部分地无法复制/无法移动而很难使用。
标记具有任意复制或移动操作的类型中的 `const`，`&`，或者 `&&` 的数据成员。
## C.ctor: Constructors, assignments, and destructors
## C.defop: Default Operations
### C.20: 只要可能，请避免定义任何的默认操作
这样最简单，而且能提供最清晰的语义。
这被称为“零之准则（The rule of zero）”。
### C.21: 如果定义或者 `=delete` 了任何复制、移动或析构函数，请定义或者 `=delete` 它们全部
复制、移动和析构的语义互相之间是紧密相关的，一旦需要声明其中一个，麻烦的是其他的也需要予以考虑。

只要声明了复制、移动或析构函数， 即便是声明为 `=default` 或 `=delete`，也将会抑制掉 移动构造函数和移动赋值运算符的隐式声明。 而声明移动构造函数或移动赋值运算符， 即便是声明为 `=default` 或 `=delete`，也将会导致隐式生成的复制构造函数 或隐式生成的复制赋值运算符被定义为弃置的。 因此，只要声明了它们中的任何一个，就应当将 其他全部都予以声明，以避免出现预期外的效果，比如将所有潜在的移动 都变成了更昂贵的复制操作，或者使类变为只能移动的。

这被称为“五之准则（The rule of five）”。

类中应当要么为每个复制/移动/析构函数都提供一个声明（即便是 `=delete`），要么都不这样做。
### C.22: 使默认操作之间保持一致
默认操作是一个概念上相配合的集合。它们的语义是相互关联的。 如果复制/移动构造和复制/移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。
- 复制/移动构造函数和对应的复制/移动赋值运算符，应当在相同的解引用层次上向相同的数据成员进行写入。
- 在复制/移动构造函数中被写入的任何数据成员，在其他构造函数中也都应当进行初始化。
- 如果复制/移动构造函数对某个数据成员进行了深复制，就应当在析构函数中对这个数据成员进行修改。
- 如果析构函数修改了某个数据成员，在任何复制/移动构造函数或赋值运算符中就都应当对该数据成员进行写入。
## C.dtor: Destructors
### C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数
析构函数是在对象的生存期结束时被隐式执行的。 如果预置的析构函数足堪使用的话，就应当用它。 只有当类需要执行的代码不在其成员的析构函数中时，才需要定义非预置的析构函数。
查找疑似“隐式的资源”，比如指针和引用等。查找带有析构函数的类，即便其所有数据成员都带有自己的析构函数。
### C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放
避免资源泄漏，尤其是错误情形中。
- 当类中所有的指针或引用成员是所有者 （比如通过使用 `gsl::owner` 所断定）时，它们就应当在析构函数中有所引用。
- 当在所有权上没有明确的说法时，为指针或引用成员确定其是否是所有者 （比如，检查构造函数的代码）。
### C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者
大量的代码都是和所有权无关的。
查看原始指针成员和引用成员的初始化，看看是否进行了分配操作。
### C.33: 如果类中带有所有权的指针成员，请定义析构函数
被拥有的对象，必须在拥有它的对象销毁时进行 `delete`。
- 怀疑带有指针数据成员的类。
### C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual
以防止未定义行为。 若析构函数是 public，调用方代码就可以尝试通过基类指针来销毁一个派生类的对象，而如果基类的析构函数是非 virtual，则其结果是未定义的。 若析构函数是 protected，调用方代码就无法通过基类指针进行销毁，而且这个析构函数不需要是 virtual；它应当是 protected 而不是 private，以便它能够在派生类析构函数中执行。 总之，基类的编写者并不知道什么是当进行销毁时要做的适当操作。
- 带有任何虚函数的类的析构函数，应当要么是 public virtual，要么是 protected 且非 virtual。
- 如果某个类公开继承于某个基类，则该基类应当具有要么是 public virtual，要么是 protected 且非 virtual 的析构函数。
### C.36: 析构函数不能失败
一般来说当析构函数可能失败时我们不知道怎样写出没有错误的代码。 标准库要求它所处理的所有的类所带有的析构函数都应当不会因抛出异常而退出。
如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。
### C.37: 使析构函数 `noexcept`
析构函数不能失败。如果析构函数试图抛出异常来退出，这就是一种设计错误，程序最好终止执行。
如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。
## C.ctor: Constructors
### C.40: 如果类具有不变式，请为其定义构造函数
这正是构造函数的用途。
- 对带有自定义的复制操作但没有构造函数的类进行标记（自定义的复制操作是类是否带有不变式的良好指示器）
### C.41: 构造函数应当创建经过完整初始化的对象
构造函数为类设立不变式。类的使用者应当能够假定构造完成的对象是可以使用的。
- 每个构造函数都应当对每个数据成员进行初始化（明确地，通过委派构造函数调用，或者通过默认构造）。
### C.42: 当构造函数无法构造有效对象时，应当抛出异常
留下无效对象不管就是会造成麻烦的做法。
### C.43: 保证可复制类带有默认构造函数
就是说，确保当具体类可复制时它也满足“半正规”类型的其他规定。

许多的语言和程序库设施都依赖于默认构造函数来初始化其各个元素，比如 `T a[10]` 和 `std::vector<T> v(10)`。 对于同时是可复制的类型来说，默认构造函数通常会简化定义一个适当的移动遗留状态的任务。
- 对于可用 `=` 进行复制的类，若没有默认构造函数则对其进行标记。
- 对于可用 `==` 进行比较但不可复制的类进行标记。
### C.44: 尽量让默认构造函数简单且不抛出异常
如果可以设置一个“默认”值同时又不会涉及可能失败的操作的话，就可以简化错误处理以及对移动操作的推理。
- 标记会抛出的默认构造函数
### C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用默认成员初始化式
使用默认成员初始化式，编译器可以据此生成函数。由编译器生成的函数可能更高效。
```cpp
class X1 { // 不好: 未使用成员初始化式
    string s;
    int i;
public:
    X1() :s{"default"}, i{1} { }
    // ...
};
```
```cpp
class X2 {
    string s {"default"};
    int i {1};
public:
    // 使用编译期生成的默认构造函数
    // ...
};
```
默认构造函数应当不只是用常量初始化数据成员。
### C.46: 默认情况下，把单参数的构造函数声明为 `explicit`
用以避免意外的类型转换。
单参数的构造函数应当声明为 `explicit`。有益的单参数非 `explicit` 构造函数在大多数代码库中都是很少见的。对没在“已确认列表”中列出的每个违规都要给出警告。
### C.47: 按成员声明的顺序对数据成员进行定义和初始化
以尽量避免混淆和错误。该顺序正是初始化的发生顺序（而这与成员初始化式的顺序无关）。
```cpp
class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // 不好: 有误导性的初始化式顺序
    // ...
};

Foo x(1); // 意外: x.m1 == x.m2 == 2
```
成员初始化式的列表中应当以成员声明的相同顺序列出各个成员。
### C.48: 对于常量初始化式来说，优先采用默认成员初始化式而不是构造函数中的成员初始化式
明确所有构造函数都将使用相同的值。避免重复。避免可维护性问题。这样做会产生最简短最高效的代码。
- 每个构造函数都应该对所有数据成员进行初始化（明确进行，通过委派构造函数调用，或者通过默认构造）。
- 构造函数的默认实参的出现表明默认成员初始化式可能更合适。
### C.49: 优先进行初始化而不是在构造函数中赋值
初始化语法明确指出所进行的是初始化而不是赋值，它更加精炼和高效。这样也避免了“未设值前就使用”的错误。
### C.50: 当初始化过程中需要体现“虚函数行为”时，请使用工厂函数
当基类对象的状态必须依赖于对象的派生部分的状态时，需要使用虚函数（或等价手段），并最小化造成误用和不完全构造的对象的机会窗口。
```cpp
class B {
public:
    B()
    {
        /* ... */
        f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数
        /* ... */
    }

    virtual void f() = 0;
};
```
```cpp
class B {
protected:
    class Token {};

public:
    explicit B(Token) { /* ... */ }  // 创建不完全初始化的对象
    virtual void f() = 0;

    template<class T>
    static shared_ptr<T> create()    // 创建共享对象的接口
    {
        auto p = make_shared<T>(typename T::Token{});
        p->post_initialize();
        return p;
    }

protected:
    virtual void post_initialize()   // 构造之后立即调用
        { /* ... */ f(); /* ... */ } // 好: 虚函数分派是安全的
};

class D : public B {                 // 某个派生类
protected:
    class Token {};

public:
    explicit D(Token) : B( B::Token{} ) {}
    void f() override { /* ... */ };

protected:
    template<class T>
    friend shared_ptr<T> B::create();
};

shared_ptr<D> p = D::create<D>();  // 创建一个 D 的对象
```
### C.51: 用委派构造函数来表示类中所有构造函数的共同行为
以避免代码重复和意外出现的差异。
```cpp
class Date {   // 不好: 有重复
    int d;
    Month m;
    int y;
public:
    Date(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date(int dd, Month mm)
        :d{dd}, m{mm} y{current_year()}
        { if (!valid(d, m, y)) throw Bad_date{}; }
    // ...
};
```
```cpp
class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int dd, Month mm, year yy)
        :d{dd}, m{mm} y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date2(int dd, Month mm)
        :Date2{dd, mm, current_year()} {}
    // ...
};
```
查找相似的构造函数体。
### C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中
当派生类需要这些构造函数时，重新实现它们既啰嗦又容易出错。
```cpp
class Rec {
    // ... 数据，以及许多不错的构造函数 ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... 没有数据成员 ...
    // ... 许多不错的工具函数 ...
};
```
```cpp
struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {"foo", 7};
int val = r.x;   // 未初始化
```
确保派生类的每个成员都被初始化。
## C.copy: Copy and move
### C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用
这样做简单且高效。如果想对右值进行优化，则可以提供一个接受 && 的重载（参见 F.18）。
```cpp
class Foo {
public:
    Foo& operator=(const Foo& x)
    {
        // 好: 不需要检查自赋值的情况（除非为性能考虑）
        auto tmp = x;
        swap(tmp); // 参见 C.83
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // 用左值赋值：复制
a = f();  // 用右值赋值：可能进行移动
```
如果你想要 `virtual` 的赋值运算符，并了解为何这样做很有问题的话，请不要使其为 `operator=`。请使用一个命名函数，如 `virtual void assign(const Foo&)`。
- 赋值运算符不能为 `virtual`。有怪兽出没！
- 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
- 赋值运算符应当（隐式或者显式）调用所有的基类和成员的赋值运算符。 检查析构函数以分辨类型具有指针语义还是值语义。
### C.61: 复制操作应当进行复制
这正是一般假定所具有的语义。执行 `x = y` 之后，应当有 `x == y`。 进行复制之后，`x` 和 `y` 可以是各自独立的对象（值语义，非指针的内建类型和标准库类型的工作方式），也可以代表某个共享的对象（指针语义，就是指针的工作方式）。
### C.62: 使复制赋值可以安全进行自赋值
如果 `x=x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。
### C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const&`
这样简单而且高效。
- 赋值运算符不能为 `virtual`。有怪兽出没！
- 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
- 移动赋值运算符应当（隐式或者显式）调用所有的基类和成员的移动赋值运算符。
### C.64: 移动操作应当进行移动，并使原对象处于有效状态
这正是一般假定所具有的语义。 执行 `y=std::move(x)` 之后，`y` 的值应当为 `x` 曾经的值，而 `x` 应当处于有效状态。
```cpp
class X {   // OK: 值语义
public:
    X();
    X(X&& a) noexcept;  // 移动 X
    X& operator=(X&& a) noexcept; // 移动赋值 X
    void modify();     // 改变 X 的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

X::X(X&& a) noexcept
    :p{a.p}, sz{a.sz}  // 窃取其表示
{
    a.p = nullptr;     // 设其为“空”
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // OK
} // OK: x 可以销毁
```
检查移动操作中对成员的赋值。如果有默认构造函数的话，则把这些赋值和默认构造函数中的初始化之间进行比较。
### C.65: 使移动赋值可以安全进行自赋值
如果 `x = x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。不过，通常不会有人写出能够变成移动操作的自赋值代码，但它确实是会发生的。不管怎样，`std::swap` 就是利用移动操作来实现的，因此如果你不小心写了 `swap(a, b)` 而 `a` 和 `b` 指代相同的对象的话，未能处理自移动情况将是一种严重而且微妙的错误。
- 在自赋值的情况中，移动赋值运算符不应当使持有已经被 `delete` 或设为 `nullptr` 的指针成员。
- 查看标准库容器类型（包括 `string`）的使用方式，在普通（非性命攸关）使用中将它们当作是安全的。
### C.66: 使移动操作 `noexcept`
能够抛出异常的移动操作将违反大多数人的合理假设。 不会抛出异常的移动操作可以更高效地被标准库和语言设施所利用。
移动操作应当被标为 `noexcept`。
### C.67: 多态类应当抑制公开的移动/复制操作
多态类是定义或继承了至少一个虚函数的类。它很可能要被用作其他具有多态行为的派生类的基类。如果不小心将其按值传递了，如果它带有隐式生成的复制构造函数和赋值的话，它就面临发生切片的风险：只会复制派生类对象的基类部分，但将损坏其多态行为。

如果类中没有数据，则使其复制/移动函数 `=delete`。否则，使它们为受保护的。
```cpp
class B { // 不好: 多态基类并未抑制复制操作
public:
    virtual char m() { return 'B'; }
    // ... 没有提供复制操作，使用预置实现 ...
};

class D : public B {
public:
    char m() override { return 'D'; }
    // ...
};

void f(B& b)
{
    auto b2 = b; // 啊呀，对象切片了；b2.m() 将返回 'B'
}

D d;
f(d);
```
```cpp
class B { // 好: 多态类抑制了复制操作
public:
    B() = default;
    B(const B&) = delete;
    B& operator=(const B&) = delete;
    virtual char m() { return 'B'; }
    // ...
};

class D : public B {
public:
    char m() override { return 'D'; }
    // ...
};

void f(B& b)
{
    auto b2 = b; // ok，编译器能够检测到不恰当的复制并给出警告
}

D d;
f(d);
```
当需要创建多态对象的深拷贝副本时，应当使用 clone() 函数：参见 C.130。
表示异常对象的类应当既是多态的，也可以进行复制构造。
- 对带有公开的复制操作的多态类进行标记。
- 对多态类对象的赋值操作进行标记。
## C.other: Other default operation rules
### C.80: 当需要明确使用缺省语义时，使用 `=default`
编译器能更正确地实现缺省语义，你所实现的这些函数也不会比编译器更好。
用户定义操作的函数体不应当和编译器生成的版本具有同样的语义，因为这样做是多余的。
### C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用 `=delete`
少数情况下是不需要提供默认操作的。
消除一个默认操作，是（应当是）基于类所要达成的语义考虑的。应当对这样的类保持怀疑，但可以维护一个“确认列表”，由人工断言其语义是正确的。
### C.82: 不要在构造函数和析构函数中调用虚函数
其中所调用的函数其实是目前所构造的对象的函数，而不是可能在派生类中覆盖它的函数。 这可能是最易混淆的。 更糟的是，从构造函数或析构函数中直接或间接调用未被实现的纯虚函数的话，还会导致未定义的行为。
- 标记构造函数和析构函数中对虚函数的调用。
### C.83: 考虑为值类型提供 `noexcept` 的 `swap` 函数
`swap` 对于实现许多惯用法都很有用，其范围包括从平滑地进行对象移动，到轻易实现提供了受保证的提交功能的赋值操作以允许编写具有强异常安全性的调用代码。考虑利用 `swap` 来基于复制构造实现复制赋值操作。
- 可非平凡复制的类型应当提供成员 `swap` 或自由 `swap` 函数的重载。
- 当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.84: `swap` 函数不能失败
`swap` 广泛地以假定永不失败的方式被使用，而且如果存在可能失败的 `swap` 函数的话，程序也很难编写为可以正确工作。如果元素类型的 `swap` 会失败的话，标准库的容器和算法也无法正确工作。
当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.85: 使 `swap` 函数 `noexcept`
swap 不能失败。 如果 swap 试图用异常来退出的话，这就是严重的设计错误，程序最好立即终止（terminate）。
当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.86: 使 `==` 对操作数的类型对称，并使之 `noexcept`
不对称的操作数是出人意料的，而且当可能发生类型转换时也是一种错误来源。 `==` 是一项基础操作，程序员应当能够随意使用而不担心失败。
```cpp
struct X {
    string name;
    int number;
};

bool operator==(const X& a, const X& b) noexcept {
    return a.name == b.name && a.number == b.number;
}
```
本条规则适用于所有的常规比较运算符：`!=`，`<`，`<=`，`>`，以及 `>=`。
- 对两个参数类型不同的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。
- 对成员 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。
### C.87: 请当心基类的 `==`
为类层次编写一个傻瓜式的并且有用处的 `==` 是相当困难的。
- 对虚的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，`>=`，以及 `<=>`。
### C.89: 使 `hash` 函数 `noexcept`
哈希容器的使用者都会间接地使用 `hash`，并且不会预期简单的访问操作也会抛出异常。 这是标准库的一条要求。
- 标记可能抛出异常的 `hash`。
### C.90: 依靠构造函数和赋值运算符，不要依靠 `memset` 和 `memcpy`
构造某个类型的实例的标准 C++ 机制是调用其构造函数。如指导方针 C.41所述：构造函数应当创建一个已完全初始化的对象。不应当需要进行如用 `memcpy` 来进行的额外初始化。 为适当地做出一个类的副本并维持类型的不变式，类型将提供复制构造函数和/或复制赋值运算符。使用 `memcpy` 来复制一个非可平凡复制的类型具有未定义的行为。这经常会导致切片，或者数据损坏。
- 对将非可平凡复制类型传递给 `memset` 或 `memcpy` 进行标记。
