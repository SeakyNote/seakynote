# P: Philosophy

### P.1: 在代码中直接表达你的想法

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

### P.2: 用 ISO 标准 C++ 来编码

使用最新版的 C++ 编译器（目前支持 C++20 或 C++17），并打开禁用语言扩展的选项。

### P.3: 表达你的设计意图

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

### P.4: 理想情况下，程序应当是静态类型安全的

* `union` - 使用 `variant`（C++17 提供）
* 强制转换 - 尽可能减少其使用；使用模板有助于这点
* 数组退化 - 使用 `span`
* 范围错误 - 使用 `span`
* 窄化转换 - 尽可能减少其使用

### P.5: 编译期检查优先于运行时检查

为了代码清晰性和性能。 对于编译期识别的错误是不需要编写错误处理的。

### P.6: 应当使无法在编译期进行的检查能够在运行时实施

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

### P.7: 尽早识别运行时错误

避免“神秘的”程序崩溃。 避免能够产生（也许无法识别的）错误结果的程序错误。

### P.8: 不要泄漏任何资源

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。 这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

### P.9: 不要浪费时间或空间

你用的语言是 C++。

### P.10: 不可变数据优先于可变数据

对常量进行推理要比变量简单得多。 不可变的事物是不可能被意外改变的。 不可变性有时候也带来更好地进行优化的机会。 在常量上不会出现数据竞争。

### P.11: 把杂乱的构造封装起来，而别让其散布到代码中

杂乱的代码更有可能隐藏有 Bug 而且难于编写。 而好的接口使用起来更容易和安全。 杂乱的，底层的代码会混杂出更多这样的代码。

### P.12: 适当采用支持工具

许多事情机器都比人做得更好。 对于重复劳动，计算机既不会累也不会厌烦。 相对于重复性的例行任务，我们通常可以做一些更有意义的事情。

### P.13: 适当采用支持程序库

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量； 如果你的大部分工时都必须耗费在实现上的话， 程序库的质量和文档很可能要比你能做到的要好得多。 程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。 一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。 对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。 因此，如果你的应用领域中存在合适的程序库的话，请使用它。

# I: Interfaces

### I.1: 使接口明确

* 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。
* 函数不能对声明于命名空间作用域的变量进行写入操作。

### I.2: 避免非  `const`  全局变量

非  `const`  全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

### I.3: 避免使用单例

单例基本上就是经过伪装的更复杂的全局对象。

### I.4: 使接口严格和强类型化

* 报告将 `void*` 用作参数或返回类型的情况
* 报告使用了多个 `bool` 参数的情况
* 查找使用了过多基础类型的参数的函数。

### I.5: 说明前条件（如果有）

在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

### I.7: 说明后条件

以检测到对返回结果的误解，还可能发现实现中存在错误。

### I.9: 当接口是模板时，用概念来文档化其参数

更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

### I.10: 使用异常来表明无法实施所要求的任务

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。 这是错误的一个主要来源。
我们并不认为“性能”是一种不使用异常的合理理由。
* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，把检查从代码的关键部分中移出去。
* 长期来看，更规整的代码会得到更好的优化。
* 在做出性能相关的声明前一定要小心地进行测量。

### I.11: 决不以原始指针（ `T*` ）或引用（ `T&` ）来传递所有权

如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。

### I.13: 不要只用一个指针来传递数组

(pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

### I.22: 避免全局对象之间进行复杂的初始化

复杂的初始化可能导致未定义的执行顺序。

### I.23: 保持较少的函数参数数量

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。
两个最常见的使得函数具有过多参数的原因是：
1. _缺乏抽象_ 缺少一种抽象，使得一个组合值被以 一组独立的元素的方式进行传递，而不是以一个单独的保证了不变式的对象来传递。 这不仅使其参数列表变长，而且会导致错误， 因为各个成分值无法再被某种获得保证的不变式进行保护。  
2. _违反了“函数单一职责”原则_ 这个函数试图完成多项任务，它可能应当被重构。
多少参数算很多？请使用少于四个参数。 有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

### I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参

相同类型的相邻参数很容易被不小心互换掉。

### I.25: 优先以空抽象类作为类层次的接口

空的（没有非静态成员数据）抽象类要比带有状态的基类更倾向于保持稳定。

### I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。

### I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法

由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议， 对这些实现细节的改动都要求使用了这类的所有用户全部重新编译。而持有指向实现的指针（Pimpl）的 非多态的接口类，则可以将类的用户从其实现的改变隔离开来，其代价是一层间接。

```cpp
//header
class widget {
    class impl;
    std::unique_ptr<impl> pimpl;
public:
    void draw(); // public API that will be forwarded to the implementation
    widget(int); // defined in the implementation file
    ~widget();   // defined in the implementation file, where impl is a complete type
    widget(widget&&) noexcept; // defined in the implementation file
    widget(const widget&) = delete;
    widget& operator=(widget&&) noexcept; // defined in the implementation file
    widget& operator=(const widget&) = delete;
};
```

```cpp
//source
class widget::impl {
    int n; // private data
public:
    void draw(const widget& w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl->draw(*this); }
widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
widget::widget(widget&&) noexcept = default;
widget::~widget() = default;
widget& widget::operator=(widget&&) noexcept = default;
```

### I.30: 将有违规则的部分封装

维持代码简单且安全。 有时候因为逻辑的或者性能的原因，需要使用难看的，不安全的或者易错的技术。 此时，将它们局部化，而不是使其“感染”接口，可以避免更多的程序员团队必须当心其 细节和微妙之处。 如果可能的话，实现复杂度不能通过接口渗透到用户代码之中。
# F: Functions
## F.def: Function definitions
### F.1: 把有意义的操作“打包”成为精心命名的函数
把公共的代码分解出去，将使代码更易于阅读，更可能被重用，并能够对源于复杂代码的错误有所限制。 如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。
### F.2: 一个函数应当实施单一一项逻辑操作
仅实施单一操作的函数易于理解，测试和重用。
- 把具有多个“输出”参数的函数当作有问题的。使用返回值来代替，包括以 `tuple` 用作多个返回值。
- 把无法装入编辑器的一屏之内的“大型”函数当作有问题的。考虑把这种函数分解为较小的恰当命名的子操作。
- 把有七个或更多参数的函数当作有问题的。
### F.3: 保持函数短小简洁
大型函数难于阅读，更有可能包含复杂的代码，而且更有可能含有其作用域超过最低限度的变量。 带有复杂的控制结构的函数更有可能变长，也更有可能隐藏逻辑错误于其中。
- 标记无法“放入一屏”的函数。 一屏有多大？可以试试 60 行，每行 140 个字符；这大致上就是书本页面能够适于阅读的最大值了。
- 标记过于复杂的函数。多复杂算是过于复杂呢？ 应当用圈复杂度来度量。可以试试“多于 10 个逻辑路径”。一个简单的开关算作一条路径。
### F.4: 如果函数可能必须在编译期进行求值，就将其声明为 `constexpr`
需要用 `constexpr` 来告诉编译器允许对其进行编译期求值。
### F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`
有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。 请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。 可是我们还在等。 （显式地，或于类定义体中编写成员函数而隐式地）将其指定为内联能够促进编译器工作得更好。
如果函数超过三条语句，并且可以声明为非内联的（比如类成员函数），请考虑使其非内联。
### F.6: 如果函数必然不会抛出异常，就将其声明为 `noexcept`
如果不打算抛出异常的话，程序就会认为无法处理这种错误，并且应当尽早终止。把函数声明为 `noexcept` 对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。
- 标记不是 `noexcept`，而又不能抛出异常的函数。
- 标记抛出异常的 `swap`，`move`，析构函数，以及默认构造函数。
### F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针
智能指针的传递会转移或者共享所有权，因此应当仅在有意要实现所有权语义时才能使用。 不操作生存期的函数应当接受原始指针或引用。
使用按智能指针传递方式把函数限制为只能服务于使用智能指针的调用方。 需要一个 `widget` 的函数应当能够接受任何 `widget` 对象，而不只是由某种特定种类的智能指针管理其生存期的那些。
智能指针的传递（比如 `std::shared_ptr`）暗含了一些运行时成本。
- 若函数接受可复制的智能指针类型（即重载了 `operator->` 或 `operator*`），但该函数仅调用了：`operator*`、`operator->` 或 `get()`，则给出警告。 建议代之以 `T*` 或 `T&`。
- 对于智能指针类型（重载了 `operator->` 或 `operator*` 的类型）的参数，若它是可复制/可移动的，但从没有从函数体中被复制/移动出来，且从未对其进行修改，且未将其传递给会修改它其他函数，对之进行标记。这意味着并未使用其所有权语义。 建议代之以 `T*` 或 `T&`。
### F.8: 优先采用纯函数
纯函数更容易进行推导，有时候也更易于优化（甚至并行化），有时候还可以进行存储。
### F.9: 未使用的形参应当没有名字
可读性。 抑制未使用形参的警告消息。
### F.10: 若操作可被重用，则应为其命名
文档，可读性，重用机会。
### F.11: 当需要仅在一处使用的简单函数对象时使用无名 lambda
使代码精简，提供比其他方式更好的局部性。
## F.call: Parameter passing
### F.15: 优先采用简单的和传统的信息传递方式
![](assets/Pasted%20image%2020250723214928.png)
![](assets/Pasted%20image%2020250723214946.png)
### F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递
既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。
何谓“复制操作廉价”依赖于机器的架构，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。 当可以廉价复制时，没什么比得过进行复制的简单性和安全性，而且对于小型对象（最多两三个机器字）来说，也比按引用传递更快，因为它不需要在函数中进行一次额外的间接访问。
- 当按值传递的参数的大小大于 `2 * sizeof(void*)` 时给出警告。 建议代之以 `const` 的引用。
- 当按 `const` 引用传递的参数的大小小于或等于 `2 * sizeof(void*)` 时给出警告。建议代之以按值传递。
- 当按 `const` 引用传递的参数被 `move` 时给出警告。
### F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递
让调用者明了这个对象假定将会被改动。
- 对带有指向非 `const` 的引用参数但又_不_向其进行写入的函数给出警告。
- 当按引用传递的非 `const` 参数被进行 `move` 时给出警告。
### F.18: 对于“将被移动（will-move-from）”参数，按 `X&&` 进行传递并对参数 `std::move`
这样做很高效，并且消除了调用点的 BUG：`X&&` 绑定到右值，而要传递左值的话则要求在调用点明确进行 `std::move`。
- 对于所有 `X&&` 参数（其中的 `X` 不是模板类型参数的名字），如果函数体中使用它时没有用 `std::move`，就将其标明。
- 标明对已经被移动过的对象的访问。
- 不要有条件地从对象进行移动。
### F.19: 对于“转发（forward）”参数，按 `TP&&` 进行传递并只对参数 `std::forward`
对于接受 `TP&&` 参数的函数（其中的 `TP` 是模板类型参数的名字），如果函数对它做了任何别的事，而不是在每个静态路径中都正好进行一次 `std::forward`，或者在每个静态路径中对其进行多次 `std::forward` 但限定为不同的数据成员均正好进行一次，就将函数进行标明。
### F.20: 对于“输出（out）”值，采用返回值优先于输出参数
返回值是自我说明的，而 `&` 参数则既可能是输入/输出的也可能是仅输出的，并且倾向于被误用。
适用的情况也包括如标准容器这样的大型对象，它们为性能因素使用了隐式的移动操作，并且避免进行显式的内存管理。
当有多个值要返回时，使用元组或者类似的多成员类型。
对于指代非 `const` 的引用参数，如果其被写入之前未进行过读取，而且其类型能够廉价地返回，则标记它们；它们应当是“输入”的返回值。
### F.21: 要返回多个“输出”值，优先返回结构体
返回值是自我说明为“仅输出”值的。 注意，C++ 是支持多返回值的，按约定使用的是元组式类型（`struct`、`array`、`tuple` 等）， 在调用处使用结构化绑定（C++17）可以获得更多便利。 如果可能则优先使用具名 `struct`。 不过，`tuple` 在变参模板中很有用。
- 输出参数应当被替换为返回值。 输出参数时由函数写入的，调用了非 `const` 成员函数的，或者将它作为非 `const` 参数继续传递的参数。
- 如果可能，`pair` 或 `tuple` 返回类型应当替换为 `struct`。 变参模板中通常无法避免 `tuple`
### F.60: 当“没有参数”是有效的选项时，采用 `T*` 优先于 `T&`
指针（`T*`）可能为 `nullptr`，而引用（`T&`）则不能，不存在合法的“空引用”。 有时候用 `nullptr` 作为一种代表“没有对象”的方式是有用处的，但若是没有这种情况的话，使用引用的写法更简单，而且可能会产生更好的代码。
### F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象
可读性：这样能够明确普通指针的含义。 带来了显著的工具支持。
```cpp
void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // 不好: 不知道 p 是不是指向了 n 个元素；
                    // 应当假定它并非如此，否则应当使用 span<int>
    cout << s;      // 不好: 不知道 s 指向的是不是以零结尾的字符数组；
                    // 应当假定它并非如此，否则应当使用 zstring
    delete q;       // 不好: 不知道 *q 是不是在自由存储中分配的；
                    // 否则应当使用 owner
}
```
更好的做法
```cpp
void use2(span<int> p, zstring s, owner<int*> q)
{
    p[p.size() - 1] = 666; // OK, 会造成范围错误
    cout << s; // OK
    delete q;  // OK
}
```
### F.24: 用 `span<T>` 来代表一个半开序列
非正式和不明确的范围（range）是一种错误来源。
```cpp
void f(span<int> s)
{
    // 范围的遍历（保证正确进行）
    for (int x : s) cout << x << '\n';

    // C 风格的遍历（可能带有检查）
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // 随机访问（可能带有检查）
    s[7] = 9;

    // 截取指针（可能带有检查）
    std::sort(&s[0], &s[s.size() / 2]);
}
```
当对指针参数的访问是以其他整型类型的参数为边界限定时，就给出警告并建议改用 `span`。
### F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权
使用 `unique_ptr` 是安全地传递指针的最廉价的方式。
当函数返回了局部分配了的原始指针时就给出警告。建议改为使用 `unique_ptr` 或 `shared_ptr`。
### F.27: 用 `shared_ptr<T>` 来共享所有权
使用 `std::shared_ptr` 是表示共享所有权的标准方式。其含义是，最后一个拥有者负责删除对象。
### F.42: 返回 `T*` 来（仅仅）给出一个位置
指针就是用来干这个的。 使用 `T*` 来传递所有权其实是一种误用。
- 标记出施加在普通 `T*` 上的 `delete`，`std::free()` 等等。 只有所有者才能被删除。
- 标记出赋值给普通 `T*` 的 `new`，`malloc()` 等等。 只有所有者才应当负责进行删除。
### F.43: 不要（直接或间接）返回指向局部对象的指针或引用
避免由于使用了这种悬挂指针而造成的程序崩溃和数据损坏。
- 编译器通常可以发现返回局部对象 引用，许多情况下也可以发现返回指向局部对象的指针。
- 静态分析可以发现许多常见的确定指针位置的使用模式（因而可以消除掉悬挂指针）
### F.44: 当不想进行复制，而“没有对象被返回”不是有效的选项时，返回 `T&`
语言规则保证 `T&` 会指代对象，因此不需要对其测试 `nullptr`。
```cpp
class Car
{
    array<wheel, 4> w;
    // ...
public:
    wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }
    // ...
};

void use()
{
    Car c;
    wheel& w0 = c.get_wheel(0); // w0 与 c 的生存期相同
}
```
对不存在可能产生 `nullptr` 的 `return` 表达式的函数进行标记。
### F.45: 不要返回 `T&&`
它要求返回对已销毁的临时对象的引用。 `&&` 是吸引临时对象的符号。
对除了 `std::move` 和 `std::forward` 之外的任何把 `&&` 作为返回类型的情况都进行标记。
### F.46: `int` 是 `main()` 的返回类型
这是一条语言规则，但通常被“语言扩展”所违反，因此值得一提。 把 `main`（即程序中的那个全局的 `main`）声明为 `void` 会限制其可移植性。
### F.47: 赋值运算符返回 `T&`
运算符重载的惯例（尤其是对于具体类型来说），是让 `operator=(const T&)` 实施赋值之后返回（非 `const`）的 `*this`。这就确保了与标准库类型之间的一致性，并遵从了 “像 `int` 一样工作”的原则。
```cpp
class Foo
{
 public:
    ...
    Foo& operator=(const Foo& rhs)
    {
      // 复制各个成员。
      ...
      return *this;
    }
};
```
### F.48: 不要用 `return std::move(local)`
返回局部变量会隐式地移动它。 显式的 `std::move` 总是不良的实践，因为它会阻碍可以把移动完全消除掉的返回值优化（RVO）。
### F.49: 不要返回 `const T`
不建议返回 `const` 值。 这种老旧的建议已经过时了；它并不会带来什么价值，而且还会对移动语义造成影响。
```cpp
const vector<int> fct();    // 不好: 这个 "const" 带来的麻烦超过其价值

void g(vector<int>& vx)
{
    // ...
    fct() = vx;   // 被 "const" 所禁止
    // ...
    vx = fct(); // 昂贵的复制："const" 抑制掉了移动语义
    // ...
}
```
标记 `const` 返回值。修正方法：移除 `const` 使其变为返回非 `const` 值。
### F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda
函数不能俘获局部变量且不能在局部作用域中进行定义；当想要这些能力时，如果可能就应当使用 lambda，不行的就用手写的函数对象。另一方面，lambda 和函数对象是不能重载的；如果想要重载，就优先使用函数（让 lambda 重载的变通方案相当繁复）。如果两种方式都不行的话，就优先写一个函数；应当只使用所需的最简工具。
```cpp
// 编写只会接受 int 或 string 的函数
// -- 重载是很自然的
void f(int);
void f(const string&);

// 编写需要俘获局部状态的函数对象，可以出现于
// 语句或者表达式作用域中 -- lambda 更自然
vector<work> v = lots_of_work();
for (int tasknum = 0; tasknum < max; ++tasknum) {
    pool.run([=, &v] {
        /*
        ...
        ... 处理 v 的 1 / max, 即第 tasknum 个部分
        ...
        */
    });
}
pool.join();
```
有名字的非泛型 lambda（比如 `auto x = [](int i) { /*...*/; };`），而其并未发生俘获并且出现于全局作用域，对它们给出警告。代之以编写常规的函数。
### F.51: 如果需要作出选择，采用默认实参应当优先于进行重载
默认实参本就是为一个单一实现提供替代的接口的。 无法保证一组重载函数全部都实现相同的语义。 使用默认实参可以避免出现代码重复。
### F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获
为了效率和正确性，当使用局部的 lambda 时，你基本上总是需要进行按引用俘获。这也包括编写或者调用并行算法的情形，因为它们在返回前会进行联结。
### F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获
指向局部对象的指针和引用不能超出它们的作用域而存活。按引用捕获的 lambda 恰是另外一种保存指向局部对象的引用的地方，因而当它们（或其副本）存活超出作用域的话，也不应该这样做。
- 当捕获列表中包含指代局部声明的变量的引用时给出警告。
- 当捕获列表中包含指代局部声明的变量的引用，而 lambda 被传递给非 `const` 且非局部的上下文时，进行标记。
### F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）
这是容易混淆的。在成员函数里边写 `[=]` 貌似会按值来俘获，但其实会按引用俘获数据成员，因为它实际上按值俘获了不可见的 `this` 指针。如果你确实要这样做的话，请把 `this` 写明。
```cpp
class My_class {
    int x = 0;
    // ...

    void f()
    {
        int i = 0;
        // ...

        auto lambda = [=] { use(i, x); };   // 不好: “貌似”按复制/按值俘获

        x = 42;
        lambda(); // 调用 use(0, 42);
        x = 43;
        lambda(); // 调用 use(0, 43);

        // ...

        auto lambda2 = [i, this] { use(i, x); }; // ok, 最明确并且最不混淆

        // ...
    }
};
```
若指定了默认俘获（如 `=` 或 `&`）的 lambda 俘获列表并且还俘获了 `this` 的情况——无论是如 `[&, this]` 这样显式，还是通过 `[=]` 这样的默认俘获而又在函数体中使用了 `this`——对此进行标识。
### F.55: 不要使用 `va_arg` 参数
从 `va_arg` 中读取时需要假定确实传递了正确类型的参数。 而向变参传递时则需要假定将会读取正确的类型。 这样是很脆弱的，因为其在语言中无法一般性地强制其安全，因而需要靠程序员的纪律来保证其正确。
- 为 `va_list`，`va_start`，或 `va_arg` 的使用给出诊断。
- 如果 vararg 参数的函数并未提供重载以为该参数位置指定更加特定的类型，则当其传递参数时给出诊断。修正：使用别的函数，或标明 `[[suppress("types")]]`。
### F.56: 避免不必要的条件嵌套
浅层嵌套的条件语句使代码容易理解。也会使缩进结构清楚明了。 力求将基础代码放在最外层作用域，除非这样做会搞乱缩进。
```cpp
// 不好：深层嵌套
void foo() {
    ...
    if (x) {
        computeImportantThings(x);
    }
}

// 不好：还有多余的 else。
void foo() {
    ...
    if (!x) {
        return;
    }
    else {
        computeImportantThings(x);
    }
}

// 好：提早返回，无多余 else
void foo() {
    ...
    if (!x)
        return;

    computeImportantThings(x);
}
```
```cpp
// 不好：不必要的条件嵌套
void foo() {
    ...
    if (x) {
        if (y) {
            computeImportantThings(x);
        }
    }
}

// 好：合并条件 + 提早返回
void foo() {
    ...
    if (!(x && y))
        return;

    computeImportantThings(x);
}
```
标记多余的 `else`。 对函数体仅为包含一个代码块的条件语句的函数进行标记。
# C: Classes and class hierarchies
### C.1: 把相关的数据组织到结构中（`struct` 或 `class`）
易理解性。 如果数据之间（以基本的原因而）相关，应当在代码中体现这点。
### C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`
可读性。 易理解性。 `class` 的使用会提醒程序员需要考虑不变式。 这是一种很有用的惯例。
查找所有数据都私有的 `struct` 和带有公开成员的 `class`。
### C.3: 用类来表示接口和实现之间的区别
接口和实现之间的明确区别能够提升可读性并简化维护工作。
### C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员
比成员函数更少的耦合，减少可能由于改动对象状态而造成问题的函数，减少每当改变内部表示时需要进行修改的函数数量。
- 寻找并不直接访问数据成员的非 `virtual` 成员函数。
- 忽略 `virtual` 函数。
- 忽略至少包含一个访问了 `private` 成员的函数的重载集合中的函数。
- 忽略返回 `this` 的函数。
### C.5: 把辅助函数放在其所支持的类相同的命名空间之中
辅助函数是（由类的作者提供的）并不需要直接访问类的内部表示的函数，它们也被当作是类的可用接口的一部分。 把它们和类放在相同的命名空间中，使它们与类的关系更明显，并允许通过基于参数的查找机制找到它们。
- 对接受某一个命名空间中的参数类型的全局函数进行标记。
### C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量
在同一个声明式中混合类型的定义和另一个实体的定义会导致混淆，而且不是必要的。
- 如果类或者枚举的定义式的 `}` 后面没有跟着 `;` 就标记出来。它缺少了 `;`。
### C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`
可读性。 表明有些东西被隐藏或者进行了抽象。 这是一种有用的惯例。
对于声明为 `struct` 的类，当其带有 `private` 或 `protected` 成员时就进行标记。
### C.9: 让成员的暴露最小化
封装。 信息隐藏。 使发生意外访问的机会最小化。 这会简化维护工作。
- 标记 protected 数据。
- 标记混合的 public 和 private 数据。
## C.concrete: Concrete types
### C.10: 优先使用具体类型而不是类继承层次
具体类型在本质上就比类继承层次中的类型更简单： 它们更易于设计，更易于实现，更易于使用，更易于进行推理，更小，也更快。 使用继承层次是需要一些理由（用例）来支持的。
### C.11: 使具体类型正规化
正规类型比不正规的类型更易于理解和进行推导（不正规性会导致理解和使用上花费更多的精力）。

C++ 内建类型都是正规的，标准程序库的一些类型，如 `string`，`vector`，和 `map` 也是如此。可以定义没有赋值和相等比较的具体类，但它们很罕见（理当如此）。
### C.12: 不要令可复制或移动类型的数据成员为 `const` 或引用
`const` 和引用数据成员在可复制或移动类型中没什么用处，还会由于微妙的原因使这种类型变得至少部分地无法复制/无法移动而很难使用。
标记具有任意复制或移动操作的类型中的 `const`，`&`，或者 `&&` 的数据成员。
## C.ctor: Constructors, assignments, and destructors
## C.defop: Default Operations
### C.20: 只要可能，请避免定义任何的默认操作
这样最简单，而且能提供最清晰的语义。
这被称为“零之准则（The rule of zero）”。
### C.21: 如果定义或者 `=delete` 了任何复制、移动或析构函数，请定义或者 `=delete` 它们全部
复制、移动和析构的语义互相之间是紧密相关的，一旦需要声明其中一个，麻烦的是其他的也需要予以考虑。

只要声明了复制、移动或析构函数， 即便是声明为 `=default` 或 `=delete`，也将会抑制掉 移动构造函数和移动赋值运算符的隐式声明。 而声明移动构造函数或移动赋值运算符， 即便是声明为 `=default` 或 `=delete`，也将会导致隐式生成的复制构造函数 或隐式生成的复制赋值运算符被定义为弃置的。 因此，只要声明了它们中的任何一个，就应当将 其他全部都予以声明，以避免出现预期外的效果，比如将所有潜在的移动 都变成了更昂贵的复制操作，或者使类变为只能移动的。

这被称为“五之准则（The rule of five）”。

类中应当要么为每个复制/移动/析构函数都提供一个声明（即便是 `=delete`），要么都不这样做。
### C.22: 使默认操作之间保持一致
默认操作是一个概念上相配合的集合。它们的语义是相互关联的。 如果复制/移动构造和复制/移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。
- 复制/移动构造函数和对应的复制/移动赋值运算符，应当在相同的解引用层次上向相同的数据成员进行写入。
- 在复制/移动构造函数中被写入的任何数据成员，在其他构造函数中也都应当进行初始化。
- 如果复制/移动构造函数对某个数据成员进行了深复制，就应当在析构函数中对这个数据成员进行修改。
- 如果析构函数修改了某个数据成员，在任何复制/移动构造函数或赋值运算符中就都应当对该数据成员进行写入。
## C.dtor: Destructors
### C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数
析构函数是在对象的生存期结束时被隐式执行的。 如果预置的析构函数足堪使用的话，就应当用它。 只有当类需要执行的代码不在其成员的析构函数中时，才需要定义非预置的析构函数。
查找疑似“隐式的资源”，比如指针和引用等。查找带有析构函数的类，即便其所有数据成员都带有自己的析构函数。
### C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放
避免资源泄漏，尤其是错误情形中。
- 当类中所有的指针或引用成员是所有者 （比如通过使用 `gsl::owner` 所断定）时，它们就应当在析构函数中有所引用。
- 当在所有权上没有明确的说法时，为指针或引用成员确定其是否是所有者 （比如，检查构造函数的代码）。
### C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者
大量的代码都是和所有权无关的。
查看原始指针成员和引用成员的初始化，看看是否进行了分配操作。
### C.33: 如果类中带有所有权的指针成员，请定义析构函数
被拥有的对象，必须在拥有它的对象销毁时进行 `delete`。
- 怀疑带有指针数据成员的类。
### C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual
以防止未定义行为。 若析构函数是 public，调用方代码就可以尝试通过基类指针来销毁一个派生类的对象，而如果基类的析构函数是非 virtual，则其结果是未定义的。 若析构函数是 protected，调用方代码就无法通过基类指针进行销毁，而且这个析构函数不需要是 virtual；它应当是 protected 而不是 private，以便它能够在派生类析构函数中执行。 总之，基类的编写者并不知道什么是当进行销毁时要做的适当操作。
- 带有任何虚函数的类的析构函数，应当要么是 public virtual，要么是 protected 且非 virtual。
- 如果某个类公开继承于某个基类，则该基类应当具有要么是 public virtual，要么是 protected 且非 virtual 的析构函数。
### C.36: 析构函数不能失败
一般来说当析构函数可能失败时我们不知道怎样写出没有错误的代码。 标准库要求它所处理的所有的类所带有的析构函数都应当不会因抛出异常而退出。
如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。
### C.37: 使析构函数 `noexcept`
析构函数不能失败。如果析构函数试图抛出异常来退出，这就是一种设计错误，程序最好终止执行。
如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。
## C.ctor: Constructors
### C.40: 如果类具有不变式，请为其定义构造函数
这正是构造函数的用途。
- 对带有自定义的复制操作但没有构造函数的类进行标记（自定义的复制操作是类是否带有不变式的良好指示器）
### C.41: 构造函数应当创建经过完整初始化的对象
构造函数为类设立不变式。类的使用者应当能够假定构造完成的对象是可以使用的。
- 每个构造函数都应当对每个数据成员进行初始化（明确地，通过委派构造函数调用，或者通过默认构造）。
### C.42: 当构造函数无法构造有效对象时，应当抛出异常
留下无效对象不管就是会造成麻烦的做法。
### C.43: 保证可复制类带有默认构造函数
就是说，确保当具体类可复制时它也满足“半正规”类型的其他规定。

许多的语言和程序库设施都依赖于默认构造函数来初始化其各个元素，比如 `T a[10]` 和 `std::vector<T> v(10)`。 对于同时是可复制的类型来说，默认构造函数通常会简化定义一个适当的移动遗留状态的任务。
- 对于可用 `=` 进行复制的类，若没有默认构造函数则对其进行标记。
- 对于可用 `==` 进行比较但不可复制的类进行标记。
### C.44: 尽量让默认构造函数简单且不抛出异常
如果可以设置一个“默认”值同时又不会涉及可能失败的操作的话，就可以简化错误处理以及对移动操作的推理。
- 标记会抛出的默认构造函数
### C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用默认成员初始化式
使用默认成员初始化式，编译器可以据此生成函数。由编译器生成的函数可能更高效。
```cpp
class X1 { // 不好: 未使用成员初始化式
    string s;
    int i;
public:
    X1() :s{"default"}, i{1} { }
    // ...
};
```
```cpp
class X2 {
    string s {"default"};
    int i {1};
public:
    // 使用编译期生成的默认构造函数
    // ...
};
```
默认构造函数应当不只是用常量初始化数据成员。
### C.46: 默认情况下，把单参数的构造函数声明为 `explicit`
用以避免意外的类型转换。
单参数的构造函数应当声明为 `explicit`。有益的单参数非 `explicit` 构造函数在大多数代码库中都是很少见的。对没在“已确认列表”中列出的每个违规都要给出警告。
### C.47: 按成员声明的顺序对数据成员进行定义和初始化
以尽量避免混淆和错误。该顺序正是初始化的发生顺序（而这与成员初始化式的顺序无关）。
```cpp
class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // 不好: 有误导性的初始化式顺序
    // ...
};

Foo x(1); // 意外: x.m1 == x.m2 == 2
```
成员初始化式的列表中应当以成员声明的相同顺序列出各个成员。
### C.48: 对于常量初始化式来说，优先采用默认成员初始化式而不是构造函数中的成员初始化式
明确所有构造函数都将使用相同的值。避免重复。避免可维护性问题。这样做会产生最简短最高效的代码。
- 每个构造函数都应该对所有数据成员进行初始化（明确进行，通过委派构造函数调用，或者通过默认构造）。
- 构造函数的默认实参的出现表明默认成员初始化式可能更合适。
### C.49: 优先进行初始化而不是在构造函数中赋值
初始化语法明确指出所进行的是初始化而不是赋值，它更加精炼和高效。这样也避免了“未设值前就使用”的错误。
### C.50: 当初始化过程中需要体现“虚函数行为”时，请使用工厂函数
当基类对象的状态必须依赖于对象的派生部分的状态时，需要使用虚函数（或等价手段），并最小化造成误用和不完全构造的对象的机会窗口。
```cpp
class B {
public:
    B()
    {
        /* ... */
        f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数
        /* ... */
    }

    virtual void f() = 0;
};
```
```cpp
class B {
protected:
    class Token {};

public:
    explicit B(Token) { /* ... */ }  // 创建不完全初始化的对象
    virtual void f() = 0;

    template<class T>
    static shared_ptr<T> create()    // 创建共享对象的接口
    {
        auto p = make_shared<T>(typename T::Token{});
        p->post_initialize();
        return p;
    }

protected:
    virtual void post_initialize()   // 构造之后立即调用
        { /* ... */ f(); /* ... */ } // 好: 虚函数分派是安全的
};

class D : public B {                 // 某个派生类
protected:
    class Token {};

public:
    explicit D(Token) : B( B::Token{} ) {}
    void f() override { /* ... */ };

protected:
    template<class T>
    friend shared_ptr<T> B::create();
};

shared_ptr<D> p = D::create<D>();  // 创建一个 D 的对象
```
### C.51: 用委派构造函数来表示类中所有构造函数的共同行为
以避免代码重复和意外出现的差异。
```cpp
class Date {   // 不好: 有重复
    int d;
    Month m;
    int y;
public:
    Date(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date(int dd, Month mm)
        :d{dd}, m{mm} y{current_year()}
        { if (!valid(d, m, y)) throw Bad_date{}; }
    // ...
};
```
```cpp
class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int dd, Month mm, year yy)
        :d{dd}, m{mm} y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date2(int dd, Month mm)
        :Date2{dd, mm, current_year()} {}
    // ...
};
```
查找相似的构造函数体。
### C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中
当派生类需要这些构造函数时，重新实现它们既啰嗦又容易出错。
```cpp
class Rec {
    // ... 数据，以及许多不错的构造函数 ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... 没有数据成员 ...
    // ... 许多不错的工具函数 ...
};
```
```cpp
struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {"foo", 7};
int val = r.x;   // 未初始化
```
确保派生类的每个成员都被初始化。
## C.copy: Copy and move
### C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用
这样做简单且高效。如果想对右值进行优化，则可以提供一个接受 && 的重载（参见 F.18）。
```cpp
class Foo {
public:
    Foo& operator=(const Foo& x)
    {
        // 好: 不需要检查自赋值的情况（除非为性能考虑）
        auto tmp = x;
        swap(tmp); // 参见 C.83
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // 用左值赋值：复制
a = f();  // 用右值赋值：可能进行移动
```
如果你想要 `virtual` 的赋值运算符，并了解为何这样做很有问题的话，请不要使其为 `operator=`。请使用一个命名函数，如 `virtual void assign(const Foo&)`。
- 赋值运算符不能为 `virtual`。有怪兽出没！
- 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
- 赋值运算符应当（隐式或者显式）调用所有的基类和成员的赋值运算符。 检查析构函数以分辨类型具有指针语义还是值语义。
### C.61: 复制操作应当进行复制
这正是一般假定所具有的语义。执行 `x = y` 之后，应当有 `x == y`。 进行复制之后，`x` 和 `y` 可以是各自独立的对象（值语义，非指针的内建类型和标准库类型的工作方式），也可以代表某个共享的对象（指针语义，就是指针的工作方式）。
### C.62: 使复制赋值可以安全进行自赋值
如果 `x=x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。
### C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const&`
这样简单而且高效。
- 赋值运算符不能为 `virtual`。有怪兽出没！
- 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
- 移动赋值运算符应当（隐式或者显式）调用所有的基类和成员的移动赋值运算符。
### C.64: 移动操作应当进行移动，并使原对象处于有效状态
这正是一般假定所具有的语义。 执行 `y=std::move(x)` 之后，`y` 的值应当为 `x` 曾经的值，而 `x` 应当处于有效状态。
```cpp
class X {   // OK: 值语义
public:
    X();
    X(X&& a) noexcept;  // 移动 X
    X& operator=(X&& a) noexcept; // 移动赋值 X
    void modify();     // 改变 X 的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

X::X(X&& a) noexcept
    :p{a.p}, sz{a.sz}  // 窃取其表示
{
    a.p = nullptr;     // 设其为“空”
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // OK
} // OK: x 可以销毁
```
检查移动操作中对成员的赋值。如果有默认构造函数的话，则把这些赋值和默认构造函数中的初始化之间进行比较。
### C.65: 使移动赋值可以安全进行自赋值
如果 `x = x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。不过，通常不会有人写出能够变成移动操作的自赋值代码，但它确实是会发生的。不管怎样，`std::swap` 就是利用移动操作来实现的，因此如果你不小心写了 `swap(a, b)` 而 `a` 和 `b` 指代相同的对象的话，未能处理自移动情况将是一种严重而且微妙的错误。
- 在自赋值的情况中，移动赋值运算符不应当使持有已经被 `delete` 或设为 `nullptr` 的指针成员。
- 查看标准库容器类型（包括 `string`）的使用方式，在普通（非性命攸关）使用中将它们当作是安全的。
### C.66: 使移动操作 `noexcept`
能够抛出异常的移动操作将违反大多数人的合理假设。 不会抛出异常的移动操作可以更高效地被标准库和语言设施所利用。
移动操作应当被标为 `noexcept`。
### C.67: 多态类应当抑制公开的移动/复制操作
多态类是定义或继承了至少一个虚函数的类。它很可能要被用作其他具有多态行为的派生类的基类。如果不小心将其按值传递了，如果它带有隐式生成的复制构造函数和赋值的话，它就面临发生切片的风险：只会复制派生类对象的基类部分，但将损坏其多态行为。

如果类中没有数据，则使其复制/移动函数 `=delete`。否则，使它们为受保护的。
```cpp
class B { // 不好: 多态基类并未抑制复制操作
public:
    virtual char m() { return 'B'; }
    // ... 没有提供复制操作，使用预置实现 ...
};

class D : public B {
public:
    char m() override { return 'D'; }
    // ...
};

void f(B& b)
{
    auto b2 = b; // 啊呀，对象切片了；b2.m() 将返回 'B'
}

D d;
f(d);
```
```cpp
class B { // 好: 多态类抑制了复制操作
public:
    B() = default;
    B(const B&) = delete;
    B& operator=(const B&) = delete;
    virtual char m() { return 'B'; }
    // ...
};

class D : public B {
public:
    char m() override { return 'D'; }
    // ...
};

void f(B& b)
{
    auto b2 = b; // ok，编译器能够检测到不恰当的复制并给出警告
}

D d;
f(d);
```
当需要创建多态对象的深拷贝副本时，应当使用 clone() 函数：参见 C.130。
表示异常对象的类应当既是多态的，也可以进行复制构造。
- 对带有公开的复制操作的多态类进行标记。
- 对多态类对象的赋值操作进行标记。
## C.other: Other default operation rules
### C.80: 当需要明确使用缺省语义时，使用 `=default`
编译器能更正确地实现缺省语义，你所实现的这些函数也不会比编译器更好。
用户定义操作的函数体不应当和编译器生成的版本具有同样的语义，因为这样做是多余的。
### C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用 `=delete`
少数情况下是不需要提供默认操作的。
消除一个默认操作，是（应当是）基于类所要达成的语义考虑的。应当对这样的类保持怀疑，但可以维护一个“确认列表”，由人工断言其语义是正确的。
### C.82: 不要在构造函数和析构函数中调用虚函数
其中所调用的函数其实是目前所构造的对象的函数，而不是可能在派生类中覆盖它的函数。 这可能是最易混淆的。 更糟的是，从构造函数或析构函数中直接或间接调用未被实现的纯虚函数的话，还会导致未定义的行为。
- 标记构造函数和析构函数中对虚函数的调用。
### C.83: 考虑为值类型提供 `noexcept` 的 `swap` 函数
`swap` 对于实现许多惯用法都很有用，其范围包括从平滑地进行对象移动，到轻易实现提供了受保证的提交功能的赋值操作以允许编写具有强异常安全性的调用代码。考虑利用 `swap` 来基于复制构造实现复制赋值操作。
- 可非平凡复制的类型应当提供成员 `swap` 或自由 `swap` 函数的重载。
- 当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.84: `swap` 函数不能失败
`swap` 广泛地以假定永不失败的方式被使用，而且如果存在可能失败的 `swap` 函数的话，程序也很难编写为可以正确工作。如果元素类型的 `swap` 会失败的话，标准库的容器和算法也无法正确工作。
当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.85: 使 `swap` 函数 `noexcept`
swap 不能失败。 如果 swap 试图用异常来退出的话，这就是严重的设计错误，程序最好立即终止（terminate）。
当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。
### C.86: 使 `==` 对操作数的类型对称，并使之 `noexcept`
不对称的操作数是出人意料的，而且当可能发生类型转换时也是一种错误来源。 `==` 是一项基础操作，程序员应当能够随意使用而不担心失败。
```cpp
struct X {
    string name;
    int number;
};

bool operator==(const X& a, const X& b) noexcept {
    return a.name == b.name && a.number == b.number;
}
```
本条规则适用于所有的常规比较运算符：`!=`，`<`，`<=`，`>`，以及 `>=`。
- 对两个参数类型不同的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。
- 对成员 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。
### C.87: 请当心基类的 `==`
为类层次编写一个傻瓜式的并且有用处的 `==` 是相当困难的。
- 对虚的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，`>=`，以及 `<=>`。
### C.89: 使 `hash` 函数 `noexcept`
哈希容器的使用者都会间接地使用 `hash`，并且不会预期简单的访问操作也会抛出异常。 这是标准库的一条要求。
- 标记可能抛出异常的 `hash`。
### C.90: 依靠构造函数和赋值运算符，不要依靠 `memset` 和 `memcpy`
构造某个类型的实例的标准 C++ 机制是调用其构造函数。如指导方针 C.41所述：构造函数应当创建一个已完全初始化的对象。不应当需要进行如用 `memcpy` 来进行的额外初始化。 为适当地做出一个类的副本并维持类型的不变式，类型将提供复制构造函数和/或复制赋值运算符。使用 `memcpy` 来复制一个非可平凡复制的类型具有未定义的行为。这经常会导致切片，或者数据损坏。
- 对将非可平凡复制类型传递给 `memset` 或 `memcpy` 进行标记。
## C.con: Containers and other resource handles
### C.100: 定义容器的时候要遵循 STL
大多数 C++ 程序员都熟悉 STL 容器，而且它们具有本质上十分健全的设计。
### C.101: 为容器提供值语义
常规对象的理解和推理要比非常规对象更加简单。 使人感觉熟悉。
如果有意义的话，要使容器满足 `Regular`（概念）。 尤其是，确保对象与自身的副本比较时相等。
### C.102: 为容器提供移动操作
容器都有变大的趋势；没有移动构造函数和复制构造函数的对象 进行到处移动可以很昂贵，因而趋使人们转而传递指向它的指针， 从而带来资源管理方面的问题。
用户可以合理地假设返回一个标准程序库风格的容器是廉价的。
### C.103: 为容器提供一个初始化式列表构造函数
人们期望能够以一组值来初始化一个容器。 使人感觉熟悉。
### C.104: 为容器提供一个将之置空的默认构造函数
使其满足 `Regular`。
```cpp
vector<Sorted_sequence<string>> vs(100);    // 100 个 Sorted_sequence，值均为 ""
```
### C.109: 当资源包装类具有指针语义时，应提供 `*` 和 `->`
这正是对指针所预期的行为， 使人感觉熟悉。
## C.hier: Class hierarchies (OOP)
### C.120: 使用类层次来表达具有天然层次化结构的概念
直接在代码中表达想法可以简化理解和维护工作。应当保证各个基类所表达的想法与全部派生类型精确匹配，并且确实找不到比使用继承所带来的紧耦合方式更好的表达方式。
当单纯使用数据成员就能搞定时请_不要_使用继承。这种情况通常意味着派生类型需要覆盖某个基类虚函数或者需要访问某个受保护成员。
- 寻找带有许多不干别的只会抛出异常的成员的类。
- 对非公用基类 `B` 的每次使用进行标记，其中派生类 `D` 并未覆盖 `B` 的某个虚函数，或访问某个受保护成员，而 `B` 并非以下情况：为空，为 `D` 的模板参数或参数包组，或者为以 `D` 所特化的类模板。
### C.121: 如果基类被用作接口的话，应使其成为纯抽象类
不包含数据的类更加稳定（更不脆弱易变）。 接口通常都应当全部由公开的纯虚函数和一个预置的或为空的虚析构函数组成。
- 对任何含有数据成员同时带有并非从基类继承的可被覆盖（非 `final`）的虚函数的类给出警告。
### C.122: 当需要完全区分接口和实现时，应当用抽象类作为接口
诸如在 ABI（连接）边界这种地方。
```cpp
struct Device {
    virtual ~Device() = default;
    virtual void write(span<const char> outbuf) = 0;
    virtual void read(span<char> inbuf) = 0;
};

class D1 : public Device {
    // ... 数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};

class D2 : public Device {
    // ... 不同的数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};
```
使用者可以通过由 `Device` 所提供的接口来互换地使用 `D1` 和 `D2`。 而且，只要其访问一直是通过 `Device` 进行的话，也可以以与老版本二进制不兼容的方式来更新 `D1` 和 `D2`。
## C.hierclass: Designing classes in a hierarchy
### C.126: 抽象类通常并不需要用户编写的构造函数
通常抽象类并没有任何需要由构造函数来初始化的对象。
对带有构造函数的抽象类进行标记。
### C.127: 带有虚函数的类应当带有虚的或受保护的析构函数
带有虚函数的类通常是通过指向基类的指针来使用的。一般来说，最后一个使用者必须在基类指针上执行 `delete`，这常常是通过基类智能指针来做到的，因而析构函数应当为 `public` 和 `virtual`。而不那么常见的情况是当并不打算支持通过基类指针来删除时，这时析构函数应当为 `protected` 和非 `virtual`
- 带有任何虚函数的类的析构函数应当要么是 `public` 和 `virtual`，要么是 `protected` 和非 `virtual` 的。
- 把对带有虚函数但没有虚析构函数的类的 `delete` 标记出来。
### C.128: 虚函数应当指明 `virtual`、`override`、`final` 三者之一
可读性。 检测错误。 明确写下的 `virtual`、`override` 或 `final` 是自说明的，并使编译器可以检查到基类和派生类之间的类型和/或名字的不匹配。不过写出超过一个则不仅多余而且是潜在的错误来源。
可以遵循简单明确的含义：
- `virtual` 刚好仅仅表明“这是一个新的虚函数”。
- `override` 刚好仅仅表明“这是一个非最终覆盖函数”。
- `final` 刚好仅仅表明“这是一个最终覆盖函数”。

- 比较基类和派生类中的虚函数的名字，并对并未进行覆盖的相同名字的使用进行标记。
- 对既没有 `override` 也没有 `final` 的覆盖函数进行标记。
- 对函数声明中使用 `virtual`、`override` 和 `final` 中超过一个的情况进行标记。
### C.129: 当设计类层次时，应区分实现继承和接口继承
接口中的实现细节会使接口变得脆弱； 就是说，当实现被改变时其用户不得不进行重新编译。 基类中的数据增加了基类实现的复杂性，而且会导致代码的重复。
定义：
- 接口继承，是使用继承来把用户和实现进行分离， 特别是允许添加和修改派生类而不影响基类的用户。
- 实现继承，是使用继承来简化新设施的实现， 通过将有用的操作提供给相关的新操作的实现者（有时候称作“差异式编程”）。
纯粹的接口类只是一组纯虚函数。
在早期的 OOP 时代（比如 80 和 90 年代），实现继承和接口继承通常是混在一起的， 而不良习惯则很难改掉。 即便是现在，这种混合在旧代码和老式的教学材料中也不少见。
对两种继承进行区分的重要性随着以下情形而增长：
- 类层次的大小（比如几十个派生类），
- 类层次的使用时期（比如几十年），以及
- 使用这个类层次的独立团体的数量 （比如，可能对分发和更新某个基类造成困难）
如何才能同时获得接口类层次的稳定类层次的好处和实现继承的实现重用的好处呢？ 一种流行的技巧是双类层次。 有许多实现双类层次的方式；这里，我们使用一种多重继承形式。
首先规划一个接口类的层次：
```cpp
class Shape {   // 纯接口
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};

class Circle : public virtual Shape {   // 纯接口
public:
    virtual int radius() = 0;
    // ...
};
```
为使这个接口有用处，我们必须提供其实现类（我们这里用相同的名字，但放入 `Impl` 命名空间）：
```cpp
class Impl::Shape : public virtual ::Shape { // 实现
public:
    // 构造函数，析构函数
    // ...
    Point center() const override { /* ... */ }
    Color color() const override { /* ... */ }

    void rotate(int) override { /* ... */ }
    void move(Point p) override { /* ... */ }

    void redraw() override { /* ... */ }

    // ...
};
```
现在 `Shape` 是一个贫乏的具有一个实现的类的例子， 但还请谅解，因为这只是用来展现一种针对更复杂的类层次的技巧的简单例子。
```cpp
class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // 实现
public:
    // 构造函数，析构函数

    int radius() override { /* ... */ }
    // ...
};
```
我们可以通过添加一个 `Smiley` 类来扩展它
```cpp
class Smiley : public virtual Circle { // 纯接口
public:
    // ...
};

class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // 实现
public:
    // 构造函数，析构函数
    // ...
}
```
这里有两个类层次：
- 接口：Smiley -> Circle -> Shape
- 实现：Impl::Smiley -> Impl::Circle -> Impl::Shape
由于每个实现都同时派生于其接口和其实现基类，我们因此获得了一个晶格（DAG）：
```
Smiley     ->         Circle     ->  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -> Impl::Circle -> Impl::Shape
```
我们曾经说过，这只是用来构造双类层次的一种方式。
可以直接使用实现类层次，而不用通过抽象接口来进行。
```cpp
void work_with_shape(Shape&);

int user()
{
    Impl::Smiley my_smiley{ /* args */ };   // 创建具体的形状
    // ...
    my_smiley.some_member();        // 直接使用实现类
    // ...
    work_with_shape(my_smiley);     // 通过抽象接口使用实现
    // ...
}
```
这种做法在实现类带有并未由抽象接口提供的成员时， 或者当直接使用某个成员具有优化机会（比如当实现成员函数为 `final`）时，比较有用。
分离接口和实现的另一个（相关的）技巧是 Pimpl。
在提供公共的功能时，我们通常需要在作为（有实现的）基类函数和（在某个实现命名空间中的） 自由函数之间进行选择。 基类能够提供更简短的写法，以及更容易访问（基类中的）共享数据， 但所付出的是其功能将仅能被这个类层次的用户所使用。
- 若派生类向基类转换的基类同时具有数据和虚函数，则对其进行标记 （但排除在派生类成员中对基类成员的调用）。
### C.130: 多态类的深拷贝；优先采用虚函数 `clone` 来替代公开复制构造/赋值
由于切片的问题，不鼓励多态类的复制操作，参见 C.67。如果确实需要复制语义的话，应当进行深复制：提供一个虚 clone 函数，它复制的是真正的最终派生类型，并返回指向新对象的具有所有权的指针，而且在派生类中它返回的也是派生类型（利用协变返回类型）。
```cpp
class B {
public:
    B() = default;
    virtual ~B() = default;
    virtual gsl::owner<B*> clone() const = 0;
protected:
     B(const B&) = default;
     B& operator=(const B&) = default;
     B(B&&) noexcept = default;
     B& operator=(B&&) noexcept = default;
    // ...
};

class D : public B {
public:
    gsl::owner<D*> clone() override
    {
        return new D{*this};
    }
};
```
通常来说，推荐使用智能指针来表示所有权（参见 R.20）。不过根据语言规则，协变返回类型不能是智能指针：当 `B::clone` 返回 `unique_ptr<B>` 时 `D::clone` 不能返回 `unique_ptr<D>`。因此，你得在所有覆盖函数中统一都返回 `unique_ptr<B>`，或者也可以使用指导方针支持库中的 `owner<>` 工具类。
### C.131: 避免无价值的取值和设值函数
无价值的取值和设值函数没有提供语义价值；让数据项自己 `public` 是一样的。
```cpp
class Point {   // 不好：啰嗦
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // 没有有行为的成员函数
};
```
应当考虑把这个类变为 `struct`——就是一组没有行为的变量，全部都是公开数据而没有成员函数。
```cpp
struct Point {
    int x {0};
    int y {0};
};
```
对大量仅提供单纯的成员访问而没有其他语义的 `get` 和 `set` 成员函数进行标记。
### C.132: 请勿无理由地使函数 `virtual`
多余的 `virtual` 会增加运行时间和对象代码的大小。 虚函数可以被覆盖，因此派生类中可能因此发生错误。 虚函数保证会在模板化的层次中造成代码重复。
- 对带有虚函数但没有派生类的类进行标记。
- 对所有成员函数都为虚函数并带有实现的类进行标记。
### C.133: 避免 `protected` 数据
`protected` 数据是复杂性和错误的一种来源。 `protected` 数据会把不变式的陈述搞复杂。 `protected` 数据天生违反了避免把数据放入基类的指导原则，而这样通常还会导致不得不采用虚继承。
对带有 `protected` 数据的类进行标记。
### C.134: 确保所有非 `const` 数据成员有相同的访问级别
防止出现会导致错误的逻辑混乱。 当非 `const` 数据成员的访问级别不同时，这个类型就会在它应当做什么上出现混乱。 这个类型是用来维持某个不变式的类型，还是仅仅集合了一组值而已？
对包含具有不同访问级别的非 `const` 数据成员的类给出标记。
### C.135: 用多继承来表达多个不同的接口
并非所有的类都应当支持全部的接口，而且并非所有的调用方都应当处理所有的操作。 尤其应当把巨大的接口拆解为可以被某个给定派生类所支持的不同的行为“方面”。
```cpp
class iostream : public istream, public ostream {   // 充分简化
    // ...
};
```
`istream` 提供了输入操作的接口；`ostream` 提供了输出操作的接口。 `iostream` 提供了 `istream` 和 `ostream` 接口的并集，以及在单个流上同时允许二者所需的同步操作。
这是非常常见的继承的用法，因为需要同一个实现提供多个不同接口是很常见的， 而通常把这种接口组织到一个单根层次中都是不容易的或者不自然的。
这样的接口通常都是抽象类。
### C.136: 用多继承来表达一些实现特性的合并
一些形式的混元（Mixin）带有状态，并通常会有对其状态提供的操作。 如果这些操作是虚的，就必须进行继承，而如果不是虚的，使用继承也可以避免例行代码和转发函数。
### C.137: 用 `virtual` 基类以避免过于通用的基类
允许共享的数据和接口的分离。 避免将所有共享数据都被放到一个终极基类之中。
```cpp
struct Interface {
    virtual void f();
    virtual int g();
    // ... 没有数据 ...
};

class Utility {  // 带有数据
    void utility1();
    virtual void utility2();    // 定制点
public:
    int x;
    int y;
};

class Derive1 : public Interface, virtual protected Utility {
    // 覆盖了 Iterface 的函数
    // 可能覆盖 Utility 的虚函数
    // ...
};

class Derive2 : public Interface, virtual protected Utility {
    // 覆盖了 Iterface 的函数
    // 可能覆盖 Utility 的虚函数
    // ...
};
```
如果许多派生类都共享了显著的“实现细节”，弄一个 `Utility` 出来就是有意义的。
对接口和实现混合的层次进行标记。
### C.138: 用 `using` 来为派生类和其基类建立重载集合
没有 using 声明的话，派生类的成员函数将会隐藏全部其所继承的重载集合。
不好：
```cpp
#include <iostream>
class B {
public:
    virtual int f(int i) { std::cout << "f(int): "; return i; }
    virtual double f(double d) { std::cout << "f(double): "; return d; }
    virtual ~B() = default;
};
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
};
int main()
{
    D d;
    std::cout << d.f(2) << '\n';   // 打印 "f(int): 3"
    std::cout << d.f(2.3) << '\n'; // 打印 "f(int): 3"
}
```
好：
```cpp
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
    using B::f; // 展露了 f(double)
};
```
诊断名字隐藏情况
### C.139: 对类运用 `final` 应当保守
用 `final` 类来把类层次封闭很少是由于逻辑上的原因而必须的，并可能破坏掉类层次的可扩展性。
标记出所有在类上使用的 `final`。
### C.140: 不要在虚函数和其覆盖函数上提供不同的默认参数
这会造成混乱：覆盖函数是不会继承默认参数的。
```cpp
class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};

Derived d;
Base& b = d;

b.multiply(10);  // 这两次调用将会调用相同的函数，但分别
d.multiply(10);  // 使用不同的默认实参，因此获得不同的结果
```
对虚函数默认参数中，如果其在基类和派生类的声明中是不同的，则对其进行标记。
## C.hier-access: Accessing objects in a hierarchy
### C.145: 通过指针和引用来访问多态对象
如果类带有虚函数的话，你（通常）并不知道你所使用的函数是由哪个类提供的。
对所有切片都进行标记。
### C.146: 当无法避免在类层次上进行导航时应使用 `dynamic_cast`
`dynamic_cast` 是运行时检查。
- 对所有用 `static_cast` 来进行向下转换进行标记，其中也包括实施 `static_cast` 的 C 风格的强制转换。
### C.147: 当查找所需类的失败被当做一种错误时，应当对引用类型使用 `dynamic_cast`
对引用进行的强制转换，所表达的意图是最终会获得一个有效对象，因此这种强制转换必须成功。如果无法成功的话，`dynamic_cast` 将会抛出异常。
### C.148: 当查找所需类的失败被当做一种有效的可能情况时，应当对指针类型使用 `dynamic_cast`
`dynamic_cast` 转换允许测试指针是否指向某个其类层次中包含给定类的多态对象。由于其找不到类时仅会返回空值，因而可以在运行时予以测试。这允许编写的代码可以基于其结果而选择不同的代码路径。
- 除非在指针类型 `dynamic_cast` 的结果上进行了空值测试，否则就对该指针的解引用给出警告。
### C.149: 用 `unique_ptr` 或 `shared_ptr` 来避免忘记对以 `new` 所创建的对象进行 `delete` 的情况
避免资源泄漏。
- 标记用 `new` 的结果来对裸指针所进行的初始化。
- 标记对局部变量的 `delete`。
### C.150: 用 `make_unique()` 来构建由 `unique_ptr` 所拥有的对象
### C.151: 用 `make_shared()` 来构建由 `shared_ptr` 所拥有的对象
### C.152: 禁止把指向派生类对象的数组的指针赋值给指向基类的指针
对所得到的基类指针进行下标操作，将导致无效的对象访问并且可能造成内存损坏。
- 对任何的数组退化和基类向派生类转换之间的组合进行标记。
- 应当将数组作为 `span` 而不是指针来进行传递，而且不能让数组的名字在放入 `span` 之前经手派生类向基类的转换。
### C.153: 优先采用虚函数而不是强制转换
虚函数调用安全，而强制转换易错。 虚函数调用达到全派生函数，而强制转换可能达到某个中间类 而得到错误的结果（尤其是当类层次在维护中被修改之后）。
## C.over: Overloading and overloaded operators
### C.160: 定义运算符应当主要用于模仿传统用法
最小化意外情况。
```cpp
class X {
public:
    // ...
    X& operator=(const X&); // 定义赋值的成员函数
    friend bool operator==(const X&, const X&); // == 需要访问其内部表示
                                                // 执行 a = b 之后将有 a == b
    // ...
};
```
这里维持了传统的语义：副本之间相等。
```cpp
X operator+(X a, X b) { return a.v - b.v; }   // 不好: 让 + 执行减法
```
### C.161: 对于对称的运算符应当采用非成员函数
如果使用的是成员函数的话，就需要两个才行。 如果为（比如）`==` 采用的不是非成员函数的话，`a == b` 和 `b == a` 就会存在微妙的差别。
```cpp
bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }
```
标记成员运算符函数。
### C.162: 重载的操作之间应当大体上是等价的
让逻辑上互相等价的操作对不同的参数类型使用不同的名字会带来混乱，导致在函数名字中编码类型信息，并妨碍泛型编程。
### C.163: 应当仅对大体上等价的操作进行重载
让逻辑上不同的函数使用相同的名字会带来混乱，并导致在泛型编程时发生错误。
### C.164: 避免隐式转换运算符
隐式类型转换可以很基础（比如 `double` 向 `int`），但经常会导致意外（比如 `String` 到 C 风格的字符串）。
```cpp
struct S1 {
    string s;
    // ...
    operator char*() { return s.data(); } // 不好，可能会引起以外
};

struct S2 {
    string s;
    // ...
    explicit operator char*() { return s.data(); }
};

void f(S1 s1, S2 s2)
{
    char* x1 = s1;     // 可以，但在许多情况下会引起意外
    char* x2 = s2;     // 错误，这通常是一件好事
    char* x3 = static_cast<char*>(s2); // 我们可以明确（在你的头脑里）
}
```
可能在任意的难以发现的上下文里发生令人惊讶且可能具有破坏性的隐式转换，例如，
```cpp
S1 ff();

char* g()
{
    return ff();
}
```
由`ff()`返回的字符串在返回它的指针之前被销毁。
标记所有的非显式转换运算符。
### C.165: 为定制点采用 `using`
以便找到在一个独立的命名空间中所定义的函数对象或函数，它们对一个一般性函数进行了“定制”。
```cpp
void f3(N::X& a, N::X& b)
{
    using std::swap;  // 使得 std::swap 可用
    swap(a, b);        // 如果存在 N::swap 则调用之，否则为 std::swap
}
```
### C.166: 一元 `&` 的重载只能作为某个智能指针或引用系统的一部分而提供
`&` 运算符在 C++ 中很基本。 C++ 语义中的很多部分都假定了其默认的含义。
```cpp
class Ptr { // 一种智能指针
    Ptr(X* pp) : p(pp) { /* 检查 */ }
    X* operator->() { /* 检查 */ return p; }
    X operator[](int i);
    X operator*();
private:
    T* p;
};

class X {
    Ptr operator&() { return Ptr{this}; }
    // ...
};
```
如果用户定义了 `&` 而并未同时为其结果类型定义 `->`，则进行警告。
### C.167: 应当为带有传统含义的操作提供运算符
可读性。约定。可重用性。支持泛型代码。
```cpp
void cout_my_class(const My_class& c) // 含糊，并非传统约定，非泛型
{
    std::cout << /* 此处为类成员 */;
}

std::ostream& operator<<(std::ostream& os, const my_class& c) // OK
{
    return os << /* 此处为类成员 */;
}
```
大多数运算符都有很强烈和活跃的含义约定用法，比如
- 比较：`==`，`!=`，`<`，`<=`，`>`，`>=`，以及 `<=>`
- 算术操作：`+`，`-`，`*`，`/`，以及 `%`
- 访问操作：`.`，`->`，一元 `*`，以及 `[]`
- 赋值：`=`
请勿定义违反约定的用法，请勿为它们发明自己的名字。
### C.168: 应当在操作数所在的命名空间中定义重载运算符
可读性。 通过 ADL 寻找运算符的能力。 避免不同命名空间中的定义之间不一致。
```cpp
namespace N {
    struct S { };
    S operator+(S, S);   // OK: 和 S 在相同的命名空间，甚至紧跟着 S
}

N::S s;

S r = s + s;  // 通过 ADL 找到了 N::operator+()
```
- 对并非处于其操作数的命名空间中的运算符的定义进行标记。
### C.170: 当想要重载 lambda 时，应当使用泛型 lambda
无法通过定义两个带有相同名字的不同 lambda 来进行重载。
```cpp
void f(int);
void f(double);
auto f = [](char);   // 错误: 无法重载变量和函数

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // 错误: 无法重载变量

auto h = [](auto) { /* ... */ };   // OK
```
## C.union: Unions
### C.180: 采用 `union` 用以节省内存
`union` 可以让一块内存在不同的时间用于不同类型的数据。 因此，当我们有几个不可能同时使用的对象时，可以用它来节省内存。
### C.181: 避免“裸” `union`
裸联合体（naked union）是没有相关的指示其持有哪个成员（如果有）的指示器的联合体， 程序员必须保持对它的跟踪。 裸联合体是类型错误的一种来源。
可以使用 C++17 的 `variant`类型
### C.182: 利用匿名 `union` 实现带标记联合体
设计良好的带标记联合体是类型安全的。 匿名联合体可以简化这种带有 (tag, union) 对的类的定义。
### C.183: 不要将 `union` 用于类型双关
取一个 `union` 曾写入的成员不同类型的成员是未定义的行为。 这种双关是不可见的，或者至少比具名强制转换更难于找出。 使用 `union` 的类型双关是一种错误来源。
# Enum: Enumerations
### Enum.1: 优先采用 `enum` 而不是宏
宏不遵守作用域和类型规则。而且，宏的名字在预处理中就被移除，因而通常不会出现在如调试器这样的工具中。
标记定义整数值的宏。
### Enum.2: 采用枚举来表示相关的具名常量的集合
枚举展示其枚举符之间是有关联的，且可以用作具名类型。
- 当 `switch` 语句的 `case` 标签并未覆盖枚举的全部枚举符时，对其进行标记。
- 当 `switch` 语句的 `case` 覆盖了枚举的几个枚举符，但没有 `default` 时，对其进行标记。
### Enum.3: 优先采用 `class enum` 而不是“普通”`enum`
最小化意外情况：传统的 `enum` 太容易转换为 `int` 了。
对所有非 `class enum` 定义进行警告。
### Enum.4: 针对安全和简单的用法来为枚举定义操作
便于使用并避免犯错。
```cpp
enum Day { mon, tue, wed, thu, fri, sat, sun };

Day& operator++(Day& d)
{
    return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);
}

Day today = Day::sat;
Day tomorrow = ++today;
```
对重复出现的强制转换回枚举的表达式进行标记。
### Enum.5: 请勿为枚举符采用 `ALL_CAPS` 命名方式
避免和宏之间发生冲突
标记 ALL_CAPS 风格的枚举符。
### Enum.6: 避免使用无名枚举
如果无法对枚举命名的话，它的值之间就是没有关联的。
代之以使用 `constexpr` 值。
对无名枚举进行标记。
### Enum.7: 仅在必要时才为枚举指定其底层类型
缺省情况的读写都是最简单的。 `int` 是缺省的整数类型。 `int` 是和 C 的 `enum` 相兼容的。
### Enum.8: 仅在必要时才指定枚举符的值
这是最简单的。 避免了枚举符值发生重复。 缺省情况会提供一组连续的值，并有利于 `switch` 语句的实现。
- 标记重复的枚举值
- 对明确指定的全部连续的枚举符的值进行标记。
# R: Resource management
### R.1: 利用资源句柄和 RAII（资源获取即初始化）来自动管理资源
避免资源泄漏和人工资源管理的复杂性。 C++ 语言确保的构造函数/析构函数对称性，反映了资源的获取/释放函数对（比如 `fopen`/`fclose`，`lock`/`unlock`，以及 `new`/`delete` 等）的对称性本质。 每当需要处理某个需要成对儿的获取/释放函数调用的资源时，应当将资源封装到保证这种配对调用的对象之中——在构造函数中获取资源，并在其析构函数中释放它。
### R.2: 接口中的原生指针（仅）代表个体对象
最好用某个容器类型（比如 `vector`，拥有数据），或者用 `span`（不拥有数据）来表示数组。 这些容器和视图都带有足够的信息来进行范围检查。
- 对并非来自容器、视图或迭代器的指针进行的指针算术（包括 `++`）进行标记。 这条规则对比较老的代码库实施时，可能会产生巨量的误报。
- 对把数组名被传递为单纯的指针进行标记。
### R.3: 原生指针（`T*`）没有所有权
对此（C++ 标准中和大多数代码中都）没有异议，大多数原生指针都是无所有权的。 我们希望将有所有权的指针标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。
- 当 `new` 的返回值被赋值给原生指针时，给出警告。
- 当函数所返回的对象是在函数中所分配的，并且它具有移动构造函数时，给出警告。 建议代之以按值返回。
### R.4: 原生引用（`T&`）没有所有权
对此（C++ 标准中和大多数代码中都）没有异议，大多数原生引用都是无所有权的。 我们希望将所有者都标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。
### R.5: 优先采用有作用域的对象，避免不必要的堆分配
有作用域的对象是局部对象、全局对象，或者成员。 它们也意味着在其所在作用域或者所在对象之外无须花费单独的分配和回收成本。 有作用域对象的成员自身也是有作用域的，有作用域对象的构造函数和析构函数负责管理其成员的生存期。
- 【中级】 如果分配了某个对象，又在函数内的所有路径中都进行了回收，则给出警告。建议它应当被代之以一个局部的栈对象。
- 【简单】 当局部的 `Unique_pointer` 或 `Shared_pointer` 在其生存期结束前未被移动、复制、赋值或 `reset`，则给出警告。
##### 例外
如果你的栈空间受限，那么创建一个局部的 `const unique_ptr<BigObject>` 来把对象从存储于栈改为存储于堆的做法是没问题的。
### R.6: 避免非 `const` 的全局变量
## R.alloc: Allocation and deallocation
### R.10: 避免 `malloc()` 和 `free()`
`malloc()` 和 `free()` 并不支持构造和销毁，而且无法同 `new` 和 `delete` 之间进行混用。
对 `malloc` 和 `free` 的使用进行标记。
### R.11: 避免显式调用 `new` 和 `delete`
由 `new` 所返回的指针应当属于一个资源句柄（它将调用 `delete`）。 若由 `new` 所返回的指针被赋值给普通的裸指针，那么这个对象就可能会泄漏。
对任何 `new` 和 `delete` 的显式使用都给出警告。建议代之以 `make_unique`。
### R.12: 显式资源分配的结果应当立即交给一个管理对象
如果不这样做的话，当发生异常或者返回时就可能造成泄露。
```cpp
void func(const string& name)
{
    ifstream f{name};   // 打开文件
    vector<char> buf(1024);
    // ...
}
```
对文件句柄（在 `ifstream` 中）的使用是简单、高效而且安全的。
- 将用于初始化指针的显式分配标记出来。
### R.13: 单个表达式语句中至多进行一次显式资源分配
如果在一条语句中进行两次显式资源分配的话就可能发生资源泄漏，这是因为许多的子表达式（包括函数参数）的求值顺序都是未指明的。
```cpp
// 不好：可能会泄漏
fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));
```
这是异常不安全的，因为编译器可能会把两个用以创建函数的两个参数的表达式重新排序。 特别是，编译器是可以交错执行这两个表达式的： 它可能会首先为两个对象都（通过调用 `operator new`）进行内存分配，然后再试图调用二者的 `Widget` 构造函数。 一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！
最佳的方案是使用返回所有者对象的工厂函数，而完全避免显式的分配：
```cpp
fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // 最佳
```
- 将包含多次显式资源分配的表达式标记出来。
### R.14: 避免使用 `[]` 形参，优先使用 `span`
数组会退化为指针，因而丢失其大小信息，并留下了发生范围错误的机会。 使用 `span` 来保留大小信息。
```cpp
void f(int[]);          // 不建议的做法

void f(int*);           // 对多个对象不建议的做法
                        // （指针应当指向单个对象，不要进行下标运算）

void f(gsl::span<int>); // 好，建议的做法
```
标记出 `[]` 参数。代之以使用 `span`。
### R.15: 总是同时重载相匹配的分配、回收函数对
不然的话就出现不匹配的操作，并导致混乱。
```cpp
class X {
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
};
```
标记出不完全的操作对。
## R.smart: Smart pointers
### R.20: 用 `unique_ptr` 或 `shared_ptr` 表示所有权
它们可以避免资源泄漏。
如果 `new` 的返回值被赋值给了原生指针，就给出警告。如果返回带所有权原始指针的函数的结果被赋值给了原生指针，就给出警告。
### R.21: 优先采用 `unique_ptr` 而不是 `shared_ptr`，除非需要共享所有权
`unique_ptr` 概念上要更简单且更可预测（知道它何时会销毁），而且更快（不需要暗中维护引用计数）。
如果函数所使用的 `Shared_pointer` 的对象是函数之内所分配的，而且既不会将这个 `Shared_pointer` 返回，也不会将其传递给其他接受 `Shared_pointer` 的函数的话，就给出警告。建议代之以 `unique_ptr`。
### R.22: 使用 `make_shared()` 创建 `shared_ptr`
`make_shared` 为构造提供了更精炼的语句。 它也提供了一个机会，通过把 `shared_ptr` 的使用计数和对象相邻放置，来消除为引用计数进行独立的内存分配操作。 它也保证（C++17 前的代码中的）了复杂表达式中的异常安全性。
如果 `shared_ptr` 从 `new` 的结果而不是 `make_shared` 进行构造，就给出警告。
### R.23: 使用 `make_unique()` 创建 `unique_ptr`
如果 `unique_ptr` 从 `new` 的结果而不是 `make_unique` 进行构造，就给出警告。
### R.24: 使用 `std::weak_ptr` 来打断 `shared_ptr` 的循环引用
`shared_ptr` 是基于引用计数的，而带有循环的结构中的引用计数不可能变为零，因此我们需要一种机制 来打破带有循环的结构。
### R.30: 以智能指针为参数，仅用于明确表达生存期语义
### R.31: 非 `std` 的智能指针，应当遵循 `std` 的行为模式
下面段落中的规则同样适用于第三方和自定义的其他种类的智能指针，而且对于诊断引发导致了性能和正确性问题的一般性的智能指针错误来说也是非常有帮助的。 你将会期望你所使用的所有智能指针都遵循这些规则。
任何重载了一元 `*` 和 `->` 的类型（无论主模板还是特化）都被当成是智能指针：
- 如果它可以复制，则将其当做一种具有引用计数的 `Shared_ptr`。
- 如果它不能复制，则将其当做一种唯一的 `Unique_ptr`。
### R.32: `unique_ptr<widget>` 参数用以表达函数假定获得 `widget` 的所有权
以这种方式使用 `unique_ptr` 同时说明并强制施加了函数调用时的所有权转移。
```cpp
void sink(unique_ptr<widget>); // 获得这个 widget 的所有权

void uses(widget*);            // 仅仅使用了这个 widget
```
- 如果函数以左值引用接受 `Unique_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
### R.33: `unique_ptr<widget>&` 参数用以表达函数对该 `widget` 重新置位
以这种方式使用 `unique_ptr` 同时说明并强制施加了函数调用时的重新置位语义。
所谓“重新置位（Reseat）”的含义是“让指针或智能指针指代某个不同的对象”。
```cpp
void reseat(unique_ptr<widget>&); // “将要”或“可能”重新置位指针
```
- 如果函数以左值引用接受 `Unique_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
### R.34: 用 `shared_ptr<widget>` 参数表达共享所有权
这样做明确了函数的所有权共享语义。
```cpp
class WidgetUser
{
public:
    // WidgetUser 将会共享这个 widget 的所有权
    explicit WidgetUser(std::shared_ptr<widget> w) noexcept:
        m_widget{std::move(w)} {}
    // ...
private:
    std::shared_ptr<widget> m_widget;
};
```
- 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 〔基础〕 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。
### R.35: `shared_ptr<widget>&` 参数用以表达函数可能会对共享的指针重新置位
这样做明确了函数的重新置位语义。
```cpp
void ChangeWidget(std::shared_ptr<widget>& w)
{
    // 这将会改变调用方的 widget
    w = std::make_shared<widget>(widget{});
}
```
- 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。
### R.36: `const shared_ptr<widget>&` 参数用以表达它可能将保留一个对对象的引用
```cpp
void share(shared_ptr<widget>);            // 共享——“将会”保持一个引用计数

void reseat(shared_ptr<widget>&);          // “可能”重新置位指针

void may_share(const shared_ptr<widget>&); // “可能”保持一个引用计数
```
- 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
- 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。
### R.37: 不要把来自某个智能指针别名的指针或引用传递出去
违反这条规则，是导致引用计数的丢失和出现悬挂指针的首要原因。 函数应当优先向其调用链中传递原生指针和引用。 在调用树的顶层，原生指针或引用是从用以保持对象存活的智能指针中获得的。 我们需要确保这个智能指针不会在调用树的下面被疏忽地进行重置或者重新赋值。
为了做到这点，有时候需要获得智能指针的一个局部副本，它可以确保在函数及其调用树的执行期间维持对象存活。
考虑下面的代码：
```cpp
// 全局（静态或堆）对象，或者有别名的局部对象 ...
shared_ptr<widget> g_p = ...;

void f(widget& w)
{
    g();
    use(w);  // A
}

void g()
{
    g_p = ...; // 噢，如果这就是这个 widget 的最后一个 shared_ptr 的话，这会销毁这个 widget
}
```
下面的代码是不应该通过代码评审的：
```cpp
void my_code()
{
    // 不好: 传递的是从非局部的智能指针中获得的指针或引用
    //       而这可能会在 f 或其调用的函数中的某处被不经意地重置掉
    f(*g_p);

    // 不好: 原因相同，只不过将其作为“this”指针传递
    g_p->func();
}
```
修正很简单——获取该指针的一个局部副本，为调用树“保持一个引用计数”：
```cpp
void my_code()
{
    // 很廉价: 一次增量就搞定了整个函数以及下面的所有调用树
    auto pin = g_p;

    // 好: 传递的是从局部的无别名智能指针中获得的指针或引用
    f(*pin);

    // 好: 原因相同
    pin->func();
}
```

- 如果从非局部或局部但潜在具有别名的智能指针变量（`Unique_pointer` 或 `Shared_pointer`）中所获取的指针或引用，被用于进行函数调用，则给出警告。如果智能指针是一个 `Shared_pointer`，则建议代之以获取该智能指针的一个局部副本并从中获取指针或引用。
# ES: Expressions and statements
### ES.1: 优先采用标准库而不是其他的库或者“手工自制代码”
使用程序库的代码要远比直接使用语言功能特性的代码易于编写，更为简短，更倾向于更高的抽象层次，而且程序库代码假定已经经过测试。 ISO C++ 标准库是最广为了解而且经过最好测试的程序库之一。 它是任何 C++ 实现的一部分。
### ES.2: 优先采用适当的抽象而不是直接使用语言功能特性
“适当的抽象”（比如程序库或者类），更加贴近应用的概念而不是语言概念，将带来更简洁的代码，而且更容易进行测试。
### ES.3: 避免重复（DRY），避免冗余代码
重复或者冗余的代码会干扰编码意图，导致对逻辑的理解变得困难，并使维护变得困难，以及一些其他问题。它经常出现于拷贝粘贴式编程中。
只要合适就使用标准算法，而不是编写自己的实现。
- 采用静态分析器。它至少会找出一些重复的代码构造。
- 代码评审
## ES.dcl: Declarations
### ES.5: 保持作用域尽量小
可读性。最小化资源持有率。避免值的意外误用。
- 对声明于循环之外，且在循环之后不再使用的循环变量进行标记。
- 当诸如文件句柄和锁这样的昂贵资源超过 N 行未被使用时进行标记（对某个适当的 N）。
### ES.6: 在 for 语句的初始化式和条件中声明名字以限制其作用域
可读性。 将循环变量的可见性限制到循环范围内。 避免在循环之后将循环变量用于其他目的。 最小化资源持有率。
```cpp
void use()
{
    for (string s; cin >> s;)
        v.push_back(s);

    for (int i = 0; i < 20; ++i) {   // 好: i 局部于 for 循环
        // ...
    }

    if (auto pc = dynamic_cast<Circle*>(ps)) {   // 好: pc 局部于 if 语句
        // ... 处理 Circle ...
    }
    else {
        // ... 处理错误 ...
    }
}
```
- 若在 `for` 语句中修改的变量是在循环之外声明的，但并未在循环之外使用，则给出警告。
- 对声明与循环之前，且在循环之后用于某个无关用途的循环变量进行标记。
### ES.7: 保持常用的和局部的名字尽量简短，而让非常用的和非局部的名字较长
可读性。减低在无关的非局部名字之间发生冲突的机会。
检查局部和非局部的名字的长度。同时考虑函数的长度。
### ES.8: 避免使用看起来相似的名字
代码清晰性和可读性。太过相似的名字会拖慢理解过程并增加出错的可能性。
- 用一个已知的易混淆字母和数字组合的列表来对名字进行检查。
- 当变量、函数或枚举符的声明隐藏了在相同作用域中所声明的类或枚举时，给出警告。
### ES.9: 避免 `ALL_CAPS` 式的名字
这样的名字通常是用于宏的。因此，`ALL_CAPS` 这样的名字可能遭受意外的宏替换。
对所有的 ALL CAPS 进行标记。对于老代码，则接受宏名字的 ALL CAPS 而标记所有的非 ALL CAPS 的宏名字。
### ES.10: 每条声明中（仅）声明一个名字
每行一条声明的做法增加可读性并可避免与 C++ 的文法 相关的错误。这样做也为更具描述性的行尾注释留下了 空间。
对具有多个声明符的变量或常量的声明式（比如 `int* p, q;`）进行标记。
### ES.11: 使用 `auto` 来避免类型名字的多余重复
- 单纯的重复既麻烦又易错。
- 当使用 `auto` 时，所声明的实体的名字是处于声明的固定位置的，这增加了可读性。
- 函数模板声明的返回类型可能是某个成员类型。
对声明中多余的类型名字进行标记。
### ES.12: 不要在嵌套作用域中重用名字
这样很容易把所用的是哪个变量搞混。 会造成维护问题。
- 对嵌套局部作用域中的名字重用进行标记。
- 对成员函数中将成员名重用为局部变量进行标记。
- 对把全局名字重用为局部变量或成员的名字进行标记。
- 对在派生类中重用（除函数名之外的）基类成员名进行标记。
### ES.20: 坚持为对象进行初始化
避免发生“设值前使用”的错误及其所关联的未定义行为。 避免由复杂的初始化的理解所带来的问题。 简化重构。
- 标记出每个未初始化的变量。 不要对具有默认构造函数的自定义类型的变量进行标记。
- 检查未初始化的缓冲区是否在声明后_立即_进行了写入。 将未初始化变量作为一个非 `const` 的引用参数进行传递可以被假定为向变量进行的写入。
### ES.21: 不要在确实需要使用变量（或常量）之前就引入它
可读性。限制变量可以被使用的范围。
对离其首次使用很远的声明进行标记。
### ES.22: 要等到获得了用以初始化变量的值之后才声明变量
可读性。限制变量可以被使用的范围。避免“设值前使用”的风险。初始化通常比赋值更加高效。
- 如果具有默认初始化的声明在其首次被读取前就进行赋值，则对其进行标记。
- 对于任何在未初始化变量之后且在其使用之前进行的复杂计算进行标记。
### ES.23: 优先使用 `{}` 初始化式语法
优先使用 `{}`。`{}` 初始化的规则比其他形式的初始化更简单，更通用，更少歧义，而且更安全。
仅当你确定不存在窄化转换时才可使用 `=`。对于内建算术类型，`=` 仅和 `auto` 一起使用。
避免 `()` 初始化，它会导致解析中的歧义。
对于容器来说，存在用 `{...}` 给出元素列表而用 `(...)` 给出大小的传统做法
- 当使用 `=` 初始化算术类型并发生窄化转换时予以标记。
- 当使用 `()` 初始化语法但实际上是声明式时予以标记。（许多编译器已经可就此给出警告。）
### ES.24: 用 `unique_ptr<T>` 来保存指针
使用 `std::unique_ptr` 是避免泄漏的最简单方法。它是可靠的，它 利用类型系统完成验证所有权安全性的大部分工作，它 增加可读性，而且它没有或近乎没有运行时成本。
寻找作为这些函数的目标的原生指针：`new`，`malloc()`，或者可能返回这类指针的函数。
### ES.25: 应当将对象声明为 `const` 或 `constexpr`，除非后面需要修改其值
这样的话你就不会误改掉这个值。而且这种方式可能会给编译器的带来优化机会。
查看变量是不是真的被改动过，若并非如此就进行标记。 不幸的是，也许不可能检测出某个非 `const` 是不是有意要改动，还是仅仅是没被改动而已。
### ES.26: 不要用一个变量来达成两个不相关的目的
可读性和安全性。
标记被重复使用的变量。
### ES.27: 使用 `std::array` 作为栈上的数组
它们是可读的，而且不会隐式转换为指针。 它们不会和内建数组的非标准扩展相混淆。
- 对具有非常量界的数组（C 风格的 VLA）作出标记。
- 对具有非局部的常量界的数组作出标记。
### ES.28: 为复杂的初始化（尤其是 `const` 变量）使用 lambda
它可以很好地封装局部的初始化，包括对仅为初始化所需的临时变量进行清理，而且避免了创建不必要的非局部而且无法重用的函数。它对于应当为 `const` 的变量也可以工作，不过必须先进行一些初始化。
```cpp
widget x;   // 应当为 const, 不过:
for (auto i = 2; i <= N; ++i) {          // 这是由 x 的
    x += some_obj.do_something_with(i);  // 初始化所需的
}                                        // 一段任意长的代码
// 自此开始，x 应当为 const，不过我们无法在这种风格的代码中做到这点
```
```cpp
const widget x = [&] {
    widget val;                                // 假定 widget 具有默认构造函数
    for (auto i = 2; i <= N; ++i) {            // 这是由 x 的
        val += some_obj.do_something_with(i);  // 初始化所需的
    }                                          // 一段任意长的代码
    return val;
}();
```
最多是某种启发式方案。查找跟随某个未初始化变量之后的循环中向其赋值。
### ES.30: 不要用宏来操纵程序文本
宏是 BUG 的一个主要来源。 宏不遵守常规的作用域和类型规则。 宏保证会让人读到的东西和编译器见到的东西不一样。 宏使得工具的建造复杂化。
见到并非仅用于源代码控制（比如 `#ifdef`）的宏时应当大声尖叫。
### ES.31: 不要用宏来作为常量或“函数”
宏是 BUG 的一个主要来源。 宏不遵守常规的作用域和类型规则。 宏不遵守常规的参数传递规则。 宏保证会让人读到的东西和编译器见到的东西不一样。 宏使得工具的建造复杂化。
见到并非仅用于源代码控制（比如 `#ifdef`）的宏时应当大声尖叫。
### ES.32: 对所有的宏名采用 `ALL_CAPS` 命名方式
遵循约定。可读性。区分宏。
见到小写的宏时应当大声尖叫。
### ES.33: 如果必须使用宏的话，请为之提供唯一的名字
宏并不遵守作用域规则。
对较短的宏名给出警告。
### ES.34: 不要定义（C 风格的）变参函数
它并非类型安全。 而且需要杂乱的满是强制转换和宏的代码才能正确工作。
- 对 C 风格的变参函数的定义作出标记。
- 对 `#include <cstdarg>` 和 `#include <stdarg.h>` 作出标记。
## ES.expr: Expressions
### ES.40: 避免复杂的表达式
复杂的表达式是易错的。
```cpp
// 不好: 在子表达式中藏有赋值
while ((c = getc()) != -1)

// 不好: 在一个子表达式中对两个非局部变量进行了赋值
while ((cin >> c1, cin >> c2), c1 == c2)

// 有改善，但可能仍然过于复杂
for (char c1, c2; cin >> c1 >> c2 && c1 == c2;)

// OK: 若 i 和 j 并非别名
int x = ++i + ++j;

// OK: 若 i != j 且 i != k
v[i] = v[j] + v[k];

// 不好: 子表达式中“隐藏”了多个赋值
x = a + (b = f()) + (c = g()) * 7;

// 不好: 依赖于经常被误解的优先级规则
x = a & b + c * d && e ^ f == 7;

// 不好: 未定义行为
x = x++ + x++ + ++x;
```
### ES.41: 对运算符优先级不保准时应使用括号
避免错误。可读性。不是每个人都能记住运算符表格。
- 当按位逻辑运算符合其他运算符组合时进行标记。
- 当赋值运算符不是最左边的运算符时进行标记。
### ES.42: 保持单纯直接的指针使用方式
复杂的指针操作是一种重大的错误来源。
- 对任何在指针类型的表达式上进行的产生指针类型的值的算术运算进行标记。
- 对任何数组类型的表达式或变量（无论是静态数组还是 `std::array`）上进行索引的表达式，若其索引不是值为从 `0` 到数组上界之内的编译期常量表达式，则进行标记。
- 对任何可能依赖于从数组类型向指针类型的隐式转换的表达式进行标记。
### ES.43: 避免带有未定义的求值顺序的表达式
你没办法搞清楚这种代码会做什么。可移植性。 即便它做到了对你可能有意义的事情，它在别的编译器（比如你的编译器的下个版本）或者不同的优化设置中也可能会做出不同的事情。
```cpp
v[i] = ++i;   //  其结果是未定义的
```
可以由优秀的分析器检测出来。
### ES.44: 不要对函数参数求值顺序有依赖
因为这种顺序是未定义的。
```cpp
int i = 0;
f(++i, ++i);
```
可以由优秀的分析器检测出来。
### ES.45: 避免“魔法常量”，采用符号化常量
表达式中内嵌的无名的常量很容易被忽略，而且经常难于理解
标记代码中的字面量。让 `0`，`1`，`nullptr`，`\n`，`""`，以及某个确认列表中的其他字面量通过检查。
### ES.46: 避免丢失数据（窄化、截断）的算术转换
窄化转换会销毁信息，通常是不期望发生的。
这条规则不适用于按语境转换为 bool 的情形：
```cpp
if (ptr) do_something(*ptr);   // OK：ptr 被用作条件
bool b = ptr;                  // 不好：发生窄化
```
- 标记出所有的浮点向整数转换。
- 标记出所有的 `long`->`char`。
- 在函数参数上发生的窄化转换特别值得怀疑。
### ES.47: 使用 `nullptr` 而不是 `0` 或 `NULL`
可读性。最小化意外：`nullptr` 不可能和 `int` 混淆。 `nullptr` 还有一个严格定义的（非常严格）类型，且因此 可以在类型推断可能在 `NULL` 或 `0` 上犯错的场合中仍能 正常工作。
对用作指针的 `0` 和 `NULL` 进行标记。可以用简单的程序变换来达成这种变换。
### ES.48: 避免强制转换
强制转换是众所周知的错误来源，它们使得一些优化措施变得不可靠。
- 对包括向 `void` 在内的所有 C 风格强制转换进行标记。
- 对使用 `Type(value)` 的函数风格强制转换进行标记。应代之以使用不会发生窄化的 `Type{value}`。
- 对指针类型之间的同一强制转换，若其中的源类型和目标类型相同(#Pro-type-identitycast)则进行标记。
- 对可以作为隐式转换显式指针强制转换进行标记。
### ES.49: 当必须使用强制转换时，使用具名的强制转换
可读性。避免错误。 具名的强制转换比 C 风格或函数风格的强制转换更加特殊，允许编译器捕捉到某些错误。
具名的强制转换包括：
- `static_cast`
- `const_cast`
- `reinterpret_cast`
- `dynamic_cast`
- `std::move` // `move(x)` 是指代 `x` 的右值引用
- `std::forward` // `forward<T>(x)` 是指代 `x` 的左值或右值引用（取决于 `T`）

- 对包括向 `void` 在内的所有 C 风格强制转换进行标记。
- 对使用 `Type(value)` 的函数风格强制转换进行标记。应代之以使用不会发生窄化的 `Type{value}`。
- 禁用 `reinterpret_cast`。
- 对于在算术类型之间使用 `static_cast` 时给出警告。
### ES.50: 不要强制掉 `const`
这是在 `const` 上说谎。 若变量确实声明为 `const`，修改它将导致未定义的行为。
- 标记 `const_cast`。
### ES.55: 避免发生对范围检查的需要
无法溢出的构造是不会溢出的（而且通常运行得更快）
查找显式的范围检查，并启发式地给出替代方案建议。
### ES.56: 仅在确实需要明确移动某个对象到别的作用域时才使用 `std::move()`
我们用移动而不是复制，以避免发生重复并提升性能。
一次移动通常会遗留一个空对象，这可能令人意外甚至很危险，因此我们试图避免从左值进行移动（它们可能随后会被访问到）。
- 对于 `std::move(x)` 的使用，当 `x` 是右值，或者语言已经将其当做右值，这包括 `return std::move(local_variable);` 以及在按值返回的函数上的 `std::move(f())`，进行标记
- 当没有接受 `const S&` 的函数重载来处理左值时，对接受 `S&&` 参数的函数进行标记。
- 若实参经过 `std::move` 传递给形参则进行标记，除非形参的类型为右值引用 `X&&`，或者类型是只能移动的而该形参为按值传递。
- 当对转发引用（`T&&` 其中 `T` 为模板参数类型）使用 `std::move` 时进行标记。应当代之以使用 `std::forward`。
- 当对并非非 const 右值引用的变量使用 `std::move` 时进行标记。（这是前一条规则的更一般的情况，以覆盖非转发的情况。）
- 当对右值引用（`X&&` 其中 `X` 为非模板形参类型）使用 `std::forward` 时进行标记。应当代之以使用 `std::move`。
- 当对并非转发引用使用 `std::forward` 时进行标记。（这是前一条规则的更一般的情况，以覆盖非移动的情况。）
- 如果对象潜在地被移动走之后的下一个操作是 `const` 操作的话，则进行标记；首先应当交错进行一个非 `const` 操作，最好是赋值，以首先对对象的值进行重置。
### ES.60: 避免在资源管理函数之外使用 `new` 和 `delete`
应用程序代码中的直接资源管理既易错又麻烦。
通常也被称为“禁止裸 `new`！”规则。
对裸的 `new` 和裸的 `delete` 进行标记。
### ES.61: 用 `delete[]` 删除数组，用 `delete` 删除非数组对象
这正是语言的要求，而且不匹配的删除将导致资源释放的错误以及内存破坏。
- 标记相同作用域中不匹配的 `new` 和 `delete`。
- 标记出现在构造函数/析构函数对之中的 `new` 和 `delete`。
### ES.62: 不要在不同的数组之间进行指针比较
这样做的结果是未定义的。
### ES.63: 不要产生切片
切片——亦即使用赋值或初始化而只对对象的一部分进行复制——通常会导致错误， 这是因为对象总是被当成是一个整体。 在罕见的进行蓄意的切片的代码中，其代码会让人意外。
```cpp
class Shape { /* ... */ };
class Circle : public Shape { /* ... */ Point c; int r; };

Circle c { {0, 0}, 42 };
Shape s {c};    // 仅复制构造了 Circle 中的 Shape 部分
s = c;          // 仅复制赋值了 Circle 中的 Shape 部分

void assign(const Shape& src, Shape& dest)
{
    dest = src;
}
Circle c2 { {1, 1}, 43 };
assign(c, c2);   // 噢，传递的并不是整个状态
assert(c == c2); // 如果提供复制操作，就也得提供比较操作，
                 //   但这里很可能返回 false
```
如果确实需要切片的话，应当为之定义一个明确的操作。 这会避免读者产生混乱。 例如：
```cpp
class Smiley : public Circle {
    public:
    Circle copy_circle();
    // ...
};

Smiley sm { /* ... */ };
Circle c1 {sm};  // 理想情况下由 Circle 的定义所禁止
Circle c2 {sm.copy_circle()};
```
针对切片给出警告。
### ES.64: 使用 `T{e}` 写法来进行构造
对象构造语法 `T{e}` 明确了所需进行的构造。 对象构造语法 `T{e}` 不允许发生窄化。 `T{e}` 是唯一安全且通用的由表达式 `e` 构造一个 `T` 类型的值的表达式。 强制转换的写法 `T(e)` 和 `(T)e` 既不安全也不通用。
标记 C 风格的 `(T)e` 和函数式风格的 `T(e)` 强制转换。
### ES.65: 不要解引用无效指针
解引用如 `nullptr` 这样的无效指针是未定义的行为，通常会导致程序立刻崩溃， 产生错误结果，或者内存被损坏。
- 当对指向已经超出作用域的对象的指针进行解引用时进行标记
- 当对可能已经通过赋值 `nullptr` 而无效的指针进行解引用时进行标记
- 当对可能已经因 `delete` 而无效的指针进行解引用时进行标记
- 当对指向可能已经失效的容器元素的指针进行解引用时进行标记
## ES.stmt: Statements
### ES.70: 面临选择时，优先采用 `switch` 语句而不是 `if` 语句
- 可读性。
- 效率：`switch` 与常量进行比较，且通常比一个 `if`-`then`-`else` 链中的一系列测试获得更好的优化。
- `switch` 可以启用某种启发式的一致性检查。例如，是否某个 `enum` 的所有值都被覆盖了？如果没有的话，是否存在 `default`？
对以 `if`-`then`-`else` 链条（仅）和常量进行比较的情况进行标记。
### ES.71: 面临选择时，优先采用范围式 `for` 语句而不是普通 `for` 语句
可读性。避免错误。效率。
查看循环，如果一个传统的循环仅会查看序列中的各个元素，而且其对这些元素所做的事中没有发生副作用，则将该循环重写为范围式的 `for` 循环。
### ES.72: 当存在显然的循环变量时，优先采用 `for` 语句而不是 `while` 语句
可读性：循环的全部逻辑都“直观可见”。循环变量的作用域是有限的。
### ES.73: 当没有显然的循环变量时，优先采用 `while` 语句而不是 `for` 语句
对和 `for` 的条件不相关的 `for` 初始化式和 `for` 增量部分进行标记。
### ES.74: 优先在 `for` 语句的初始化部分中声明循环变量
### ES.75: 避免使用 `do` 语句
可读性，避免错误。 其终止条件处于尾部（而这可能会被忽略），且其条件不会在第一时间进行检查。
标记 `do` 语句。
### ES.76: 避免 `goto`
可读性，避免错误。存在对于人类更好的控制结构；`goto` 是用于机器生成的代码的。
##### 例外
跳出嵌套循环。 这种情况下应当总是向后跳出。
```cpp
for (int i = 0; i < imax; ++i)
    for (int j = 0; j < jmax; ++j) {
        if (a[i][j] > elem_max) goto finished;
        // ...
    }
finished:
// ...
```
##### 示例，不好
有相当数量的代码采用 C 风格的 goto-exit 惯用法：
```cpp
void f()
{
    // ...
        goto exit;
    // ...
        goto exit;
    // ...
exit:
    // ... 公共的清理代码 ...
}
```
这是对析构函数的一种专门模仿。 应当将资源声明为带有清理的析构函数的包装类。
- 标记 `goto`。更好的做法是标记出除了从嵌套内层循环中跳出到紧跟一组嵌套循环之后的语句的 `goto` 以外的所有 `goto`。
### ES.77: 尽量减少循环中使用的 `break` 和 `continue`
在不平凡的循环体中，容易忽略掉 `break` 或 `continue`。
循环中的 `break` 和 `switch` 语句中的 `break` 的含义有很大的区别， （而且循环中可以有 `switch` 语句，`switch` 的 `case` 中也可以有循环）。
### ES.78: 不要依靠 `switch` 语句中的隐含直落行为
总是以 `break` 来结束非空的 `case`。意外地遗漏 `break` 是一种相当常见的 BUG。 蓄意的控制直落（fall through）是维护的噩梦，应该罕见并被明确标示出来。
单个语句带有多个 `case` 标签是可以的
在 `case` 标签中使用返回语句也是可以的
##### 例外
在罕见的直落被视为合适行为的情况中。应当明确标示，并使用 `[[fallthrough]]` 标注：
```cpp
switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    [[fallthrough]];
case Error:
    display_error_window();
    break;
}
```
### ES.79: `default`（仅）用于处理一般情况
代码清晰性。 提升错误检测的机会。
针对某个枚举的 `switch` 语句，若其未能处理其所有枚举符且没有 `default`，则对其进行标记。 这样做对于某些代码库可能会产生大量误报；此时，可以仅标记那些处理了大多数情况而不是所有情况的 `switch` 语句 （这正是第一个 C++ 编译器曾经的策略）。
### ES.84: 不要试图声明没有名字的局部变量
没有这种东西。 我们眼里看起来像是个无名变量的东西，对于编译器来说是一条由一个将会立刻离开作用域的临时对象所组成的语句。
标记出仅有临时对象的语句。
### ES.85: 让空语句显著可见
可读性。
```cpp
for (i = 0; i < max; ++i);   // 不好: 空语句很容易被忽略
v[i] = f(v[i]);

for (auto x : v) {           // 好多了
    // 空
}
v[i] = f(v[i]);
```
对并非块语句且不包含注释的空语句进行标记。
### ES.86: 避免在原生的 `for` 循环中修改循环控制变量
循环控制的第一行应当允许对循环中所发生的事情进行正确的推理。同时在循环的重复表达式和循环体之中修改循环计数器，是发生意外和 BUG 的一种经常性来源。
```cpp
for (int i = 0; i < 10; ++i) {
    // 未改动 i -- ok
}

for (int i = 0; i < 10; ++i) {
    //
    if (/* 某种情况 */) ++i; // 不好
    //
}

bool skip = false;
for (int i = 0; i < 10; ++i) {
    if (skip) { skip = false; continue; }
    //
    if (/* 某种情况 */) skip = true;  // 有改善: 为两个概念使用了两个变量。
    //
}
```
如果变量在循环控制的重复表达式和循环体中都潜在地进行更新（存在非 `const` 使用），则进行标记。
### ES.87: 请勿在条件上添加多余的 `==` 或 `!=`
这样可避免啰嗦，并消除了发生某些错误的机会。 有助于使代码风格保持一致性和协调性。
```cpp
// 这些都表示“当 p 不是 nullptr 时”
if (p) { ... }            // 好
if (p != 0) { ... }       // !=0 是多余的；不好：不要对指针用 0
if (p != nullptr) { ... } // !=nullptr 是多余的，不建议如此
```
```cpp
if (auto pc = dynamic_cast<Circle*>(ps)) { ... } // 执行是按照 ps 指向某种 Circle 来进行的，好

if (auto pc = dynamic_cast<Circle*>(ps); pc != nullptr) { ... } // 不建议如此
```
明确地将整数和 `0` 进行比较通常并非是多余的。 因为（与指针和布尔值相反），整数通常都具有超过两个的有效值。 此外 `0`（零）还经常会用于代表成功。 因此，最好明确地进行比较。
```cpp
void f(int i)
{
    if (i)            // 可疑
    // ...
    if (i == success) // 可能更好
    // ...
}
```
```cpp
// 这些都表示“当 p 为 nullptr 时”
if (!p) { ... }           // 好
if (p == 0) { ... }       // ==0 是多余的；不好：不要对指针用 0
if (p == nullptr) { ... } // ==nullptr 是多余的，不建议如此
```
## Arithmetic
### ES.100: 不要进行有符号和无符号混合运算
避免错误的结果。
不幸的是，C++ 使用有符号整数作为数组下标，而标准库使用无符号整数作为容器下标。 这妨碍了一致性。
- 编译器已知这种情况，有些时候会给出警告。
- （避免噪声）有符号/无符号的混合比较，若其一个实参是 `sizeof` 或调用容器的 `.size()` 而另一个是 `ptrdiff_t`，则不要进行标记。
### ES.101: 使用无符号类型进行位操作
无符号类型支持位操作而没有符号位的意外。
### ES.102: 使用有符号类型进行算术运算
因为大多数算术都假定是有符号的； 当 `y > x` 时，`x - y` 都会产生负数，除了罕见的情况下你确实需要模算术。
- 对混合有符号和无符号算术进行标记。
- 对将无符号算术的结果作为有符号数赋值或打印进行标记。
- 对负数字面量（比如 `-2`）用作容器下标进行标记。
- （避免噪声）有符号/无符号的混合比较，若其一个实参是 `sizeof` 或调用容器的 `.size()` 而另一个是 `ptrdiff_t`，则不要进行标记。
### ES.103: 避免上溢出
上溢出通常会让数值算法变得没有意义。 将值增加超过其最大值将导致内存损坏和未定义的行为。
```cpp
int a[10];
a[10] = 7;   // 不好，数组边界上溢出

for (int n = 0; n <= 10; ++n)
    a[n] = 9;   // 不好，数组边界上溢出
```
```cpp
int n = numeric_limits<int>::max();
int m = n + 1;   // 不好，数值上溢出
```
```cpp
int area(int h, int w) { return h * w; }

auto a = area(10'000'000, 100'000'000);   // 不好，数值上溢出
```
### ES.104: 避免下溢出
将值减小超过其最小值将导致内存损坏和未定义的行为。
### ES.105: 避免除整数零
其结果是未定义的，很可能导致程序崩溃。
这同样适用于 `%`。
- 对以可能为零的整型值的除法进行标记。
### ES.106: 不要试图用 `unsigned` 来防止负数值
选用 `unsigned` 意味着对于包括模算术在内的整数的常规行为的许多改动， 它将抑制掉与溢出有关的警告， 并打开了与混合符号相关的错误的大门。 使用 `unsigned` 并不会真正消除负数值的可能性。
- 使用有符号整数并检查 `x >= 0`
- 使用某个正整数类型
- 使用某个整数子值域类型
- `Assert(-1 < x)`
```cpp
struct Positive {
    int val;
    Positive(int x) :val{x} { Assert(0 < x); }
    operator int() { return val; }
};

int f(Positive arg) { return arg; }

int r1 = f(2);
int r2 = f(-2);  // 抛出异常
```
### ES.107: 不要对下标使用 `unsigned`，优先使用 `gsl::index`
避免有符号和无符号混乱。 允许更好的优化。 允许更好的错误检测。 避免 `auto` 和 `int` 有关的陷阱。
```cpp
vector<int> vec = /*...*/;

for (int i = 0; i < vec.size(); i += 2)                    // 可能不够大
    cout << vec[i] << '\n';
for (unsigned i = 0; i < vec.size(); i += 2)               // 有回绕的风险
    cout << vec[i] << '\n';
for (auto i = 0; i < vec.size(); i += 2)                   // 可能不够大
    cout << vec[i] << '\n';
for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // 啰嗦
    cout << vec[i] << '\n';
for (auto i = vec.size()-1; i >= 0; i -= 2)                // BUG
    cout << vec[i] << '\n';
for (int i = vec.size()-1; i >= 0; i -= 2)                 // 可能不够大
    cout << vec[i] << '\n';
```
```cpp
vector<int> vec = /*...*/;

for (gsl::index i = 0; i < vec.size(); i += 2)             // ok
    cout << vec[i] << '\n';
for (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // ok
    cout << vec[i] << '\n';
```
内建数组允许有符号的下标。 标准库容器使用无符号的下标。 因此没有完美的兼容解决方案（除非将来某一天，标准库容器改为使用有符号下标了）。 鉴于无符号和混合符号方面的已知问题，最好坚持使用（有符号）并且足够大的整数，而 `gsl::index` 保证了这点。

- 非常麻烦，因为标准库容器已经搞错了。
- （避免噪声）有符号/无符号的混合比较，若其一个实参是 `sizeof` 或调用容器的 `.size()` 而另一个是 `ptrdiff_t`，则不要进行标记。
# Per: Performance
### Per.1: 请勿进行无理由的优化
如果没有必要优化的话，这样做的结果就是更多的错误和更高的维护成本。
### Per.2: 请勿进行不成熟的优化
经过精心优化的代码通常比未优化的代码更大而且更难修改。
### Per.3: 请勿对非性能关键的代码进行优化
对程序中并非性能关键的部分进行的优化，对于系统性能是没有效果的。
### Per.4: 不能假定复杂代码一定比简单代码更快
简单的代码可能会非常快。优化器在简单代码上有时候会发生奇迹。
### Per.5: 不能假定低级代码一定比高级代码更快
低级代码有时候会妨碍优化。优化器在高级代码上有时候会发生奇迹。
### Per.6: 请勿不进行测量就作出性能评断
性能领域充斥各种错误认识和伪习俗。 现代的硬件和优化器并不遵循这些幼稚的假设；即便是专家也会经常感觉意外。
要进行高质量的性能测量是很难的，而且需要采用专门的工具。
有些使用了 Unix 的 `time` 或者标准库的 `<chrono>` 的简单的微基准测量，有助于打破大多数明显的错误认识。 如果确实无法精确地测量完整系统的话，至少也要尝试对一些关键操作和算法进行测量。 性能剖析可以帮你发现系统的哪些部分是性能关键的。 你很可能会感觉意外。
### Per.7: 设计应当允许优化
因为我们经常需要对最初的设计进行优化。 因为忽略后续改进的可能性的设计是很难修改的。
### Per.10: 依赖静态类型系统
类型违规，弱类型（比如 `void*`），以及低级代码（比如把序列当作独立字节进行操作）等会让优化器的工作变得困难很多。简单的代码通常比手工打造的复杂代码能够更好地优化。
### Per.11: 把计算从运行时转移到编译期
减少代码大小和运行时间。 通过使用常量来避免数据竞争。 编译时捕获错误（并因而消除错误处理代码）。
- 找出可以（但尚不）是 constexpr 的简单函数。
- 找出调用时其全部实参均为常量表达式的函数。
- 找出可以为 constexpr 的宏。
### Per.12: 消除多余的别名
### Per.13: 消除多余的间接
### Per.14: 最小化分配和回收的次数
### Per.15: 请勿在关键逻辑分支中进行分配
### Per.16: 使用紧凑的数据结构
性能通常都是由内存访问次数所决定的。
### Per.17: 在时间关键的结构中应当先声明最常用的成员
### Per.18: 空间即时间
性能通常都是由内存访问次数所决定的。
### Per.19: 进行可预测的内存访问
性能对于 Cache 的性能非常敏感，而 Cache 算法则更喜欢对相邻数据进行的（通常是线性的）简单访问行为。
```cpp
int matrix[rows][cols];

// 不好
for (int c = 0; c < cols; ++c)
    for (int r = 0; r < rows; ++r)
        sum += matrix[r][c];

// 好
for (int r = 0; r < rows; ++r)
    for (int c = 0; c < cols; ++c)
        sum += matrix[r][c];
```
### Per.30: 避免在关键路径中进行上下文切换
# CP: Concurrency and parallelism
### CP.1: 假定你的代码将作为多线程程序的一部分而运行
很难说现在或者未来什么时候会不会需要使用并发。 代码是会被重用的。 程序的其他使用了线程的部分可能会使用某个未使用线程的程序库。 请注意这条规则对于程序库代码来说最紧迫，而对独立的应用程序来说则最不紧迫。 不过，久而久之，代码片段可能出现在意想不到的地方。
### CP.2: 避免数据竞争
不这样的话，则任何东西都不保证能工作，而且可能出现微妙的错误。
有些事是可能做到的，至少要做一些事。 有一些商用和开源的工具试图处理这种问题， 但要注意的是任何工具解决方案都有其成本和盲点。 静态工具通常会有许多漏报，而动态工具则通常有显著的成本。 我们希望有更好的工具。 使用多个工具可以找到比单个工具更多的问题。
还有其他方式可以缓解发生数据竞争的机会：
- 避免全局数据
- 避免 `static` 变量
- 更多地使用栈上的具体类型（且不要过多地把指针到处传递）
- 更多地使用不可变数据（字面量，`constexpr`，以及 `const`）
### CP.3: 最小化可写数据的明确共享
如果不共享可写数据的话，就不会发生数据竞争。 越少进行共享，你就越少有机会忘掉对访问进行同步（而发生数据竞争）。 越少进行共享，你就越少有机会需要等待锁定（并改进性能）。
### CP.4: 以任务而不是线程的角度思考
`thread` 是一种实现概念，一种针对机器的思考方式。 任务则是一种应用概念，有时候你可以使任务和其他任务并发执行。 应用概念更容易进行推理。
### CP.8: 不要为同步而使用 `volatile`
和其他语言不同，C++ 中的 `volatile` 并不提供原子性，不会在线程之间进行同步， 而且不会防止指令重排（无论编译器还是硬件）。 它和并发完全没有关系。
### CP.9: 只要可行，就使用工具对并发代码进行验证
经验表明，让并发代码正确是特别难的， 而编译期检查、运行时检查和测试在找出并发错误方面， 并没有如同在顺序代码中找出错误时那么有效。 一些微妙的并发错误可能会造成显著的不良后果，包括内存破坏，死锁，和安全漏洞等。
对于特定的应用，应用的构建者来选择哪些支持工具是有价值的。
## CP.con: Concurrency
### CP.20: 使用 RAII，绝不使用普通的 `lock()`/`unlock()`
避免源于未释放的锁定的令人讨厌的错误。
### CP.21: 用 `std::lock()` 或 `std::scoped_lock` 来获得多个 `mutex`
避免在多个 `mutex` 上造成死锁。
### CP.22: 绝不在持有锁的时候调用未知的代码（比如回调）
如果不了解代码做了什么，就有死锁的风险。
- 当持有非递归的 `mutex` 时调用虚函数则进行标记。
- 当持有非递归的 `mutex` 时调用回调则进行标记。
### CP.23: 把联结的 `thread` 看作是有作用域的容器
为了维护指针安全性并避免泄漏，需要考虑 `thread` 所使用的指针。 如果 `thread` 联结了，我们可以安全地把指向这个 `thread` 所在作用域及其外围作用域中的对象的指针传递给它。
确保 `joining_thread` 不会 `detach()`。 之后，可以实施（针对局部对象的）常规的生存期和所有权强制实施方案。
### CP.24: 把 `thread` 看作是全局的容器
为了维护指针安全性并避免泄漏，需要考虑 `thread` 所使用的指针。 如果 `thread` 脱离了，我们只可以安全地把指向静态和自由存储的对象的指针传递给它。
当试图将局部变量传递给可能 `detach()` 的线程时进行标记。
### CP.25: 优先采用 `gsl::joining_thread` 而不是 `std::thread`
`joining_thread` 是一种在其作用域结尾处进行联结的线程。 脱离的线程很难进行监管。 确保脱离的线程（和潜在脱离的线程）中没有错误则更加困难。
标记 `std::thread` 的使用：
- 建议使用 `gsl::joining_thread` 或 C++20 的 `std:jthread`.
- 建议当其脱离时使其“外放所有权”到某个外围作用域中。
- 如果不明确线程是联结还是脱离，则给出警告。
### CP.26: 不要 `detach()` 线程
通常，需要存活超出线程创建的作用域的情况是来源于 `thread` 的任务所决定的， 但用 `detach` 来实现这点将造成更加难于对脱离的线程进行监控和通信。 特别是，要确保线程按预期完成或者按预期的时间存活变得更加困难（虽然不是不可能）。
标记 `detach()`。
### CP.31: 少量数据在线程之间按值传递，而不是通过引用或指针传递
对少量数据进行复制和访问要比使用某种锁定机制进行共享更廉价。 复制天然会带来唯一所有权（简化代码），并消除数据竞争的可能性。
### CP.32: 用 `shared_ptr` 在无关的 `thread` 之间共享所有权
如果线程之间是无关的（就是说，互相不知道是否在相同作用域中，或者一个的生存期在另一个之内）， 而它们需要共享需要删除的自由存储内存，`shared_ptr`（或者等价物）就是唯一的 可以保证正确删除的安全方式。
### CP.40: 最小化上下文切换
上下文切换是昂贵的。
### CP.41: 最小化线程的创建和销毁
线程创建是昂贵的。
### CP.42: 不要无条件地 `wait`
没有条件的 `wait` 可能会丢失唤醒，或者唤醒时只会发现无事可做。
对所有没有条件的 `wait` 进行标记。
### CP.43: 最小化临界区的时间耗费
获取 `mutex` 时耗费的时间越短，其他 `thread` 不得不等待的机会就会越少， 而 `thread` 的挂起和恢复是昂贵的。
一般来说是不可能的。 对“裸” `lock()` 和 `unlock()` 进行标记。
### CP.44: 记得为 `lock_guard` 和 `unique_lock` 命名
无名的局部对象时临时对象，会立刻离开作用域。
标记所有的无名 `lock_guard` 和 `unique_lock`。
### CP.50: `mutex` 要和其所保护的数据一起定义，只要可能就使用 `synchronized_value<T>`
对于读者来说，数据应该且如何被保护应当是显而易见的。这可以减少锁定错误的互斥体，或者互斥体未能被锁定的机会。
使用 `synchronized_value<T>` 保证了数据都带有互斥体，并且当访问数据时锁定正确的互斥体。
## CP.coro: Coroutines
### CP.51: 不要使用作为协程的有俘获 lambda 表达式
对于普通 lambda 来说正确的使用模式，对于协程 lambda 来说是高危的。很明显的变量俘获模式将会造成在首个挂起点之后访问已释放的内存，即便是带引用计数的智能指针和可复制类型也是如此。
lambda 表达式会产生一个带有存储的闭包对象，它通常在运行栈上，并会在某个时刻离开作用域。当闭包对象离开作用域时，它所俘获的也会离开作用域。普通 lambda 的执行在这个时间点都已经完成了，因此这并不是问题。闭包 lambda 则可能会在闭包对象已经销毁之后从挂起中恢复执行，而在这时其所有俘获都将变为“释放后使用”的内存访问。
标记作为协程且具有非空俘获列表的 lambda 表达式。
### CP.52: 不要在持有锁或其它同步原语时跨越挂起点
这种模式会导致明显的死锁风险。某些种类的等待允许当前线程在异步操作完成前实施一些额外的工作。如果持有锁的线程实施了需要相同的所的工作，那它就会因为试图获取它已经持有的锁而发生死锁。
如果协程在某个与获得所的线程不同的另一个线程中完成，那就是未定义行为。即使协程中明确返回其原来的线程，仍然有可能在协程恢复之前抛出异常，并导致其锁定防护对象（lock guard）未能销毁。
标记所有未能在协程挂起前销毁的锁定防护。
### CP.53: 协程的形参不能按引用传递
一旦协程到达其第一个如 `co_await` 这样的挂起点，其同步执行的部分就会返回。这个位置之后，所有按引用传递的形参都是悬挂引用。此后对它们的任何使用都是未定义行为，可能包括向已释放的内存进行写入。
标记协程的所有引用形参。
## CP.mess: Message passing
### CP.60: 使用 `future` 从并发任务返回值
`future` 为异步任务保持了常规函数调用的返回语义。 它没有显式的锁定，而且正确的（值）返回和错误的（异常）返回都能被简单处理。
### CP.61: 使用 `async()` 来产生并发任务
R.12 告诉我们要避免原始所有权指针，与此相似， 我们也要尽可能避免原始线程和原始承诺（promise）。应使用诸如 std::async 之类的工厂函数， 它将处理线程的产生和重用，而不会讲原始线程暴露给你自己的代码。
## CP.free: Lock-free programming
### CP.100: 除非绝对必要，请勿使用无锁编程
无锁编程容易出错，要求专家级的语言特性、机器架构和数据结构知识。
### CP.101: 不要信任你的硬件-编译器组合
无锁编程所使用的底层硬件接口，是属于最难正确实现的， 而且属于最可能会发生最微妙的兼容性问题的领域。 如果你为了性能而进行无锁编程的话，你应当进行回归检查。
准备强有力的规则，使得当硬件，操作系统，编译器，和程序库发生任何改变都能重复测试以进行覆盖。
### CP.102: 仔细研究文献
除了原子和少数其他的标准模式之外，无锁编程真的是只有专家才懂的议题。 在发布无锁代码给其他人使用之前，应当先成为一名专家。
### CP.110: 不要为初始化编写你自己的双检查锁定
从 C++11 开始，静态局部变量是以线程安全的方式初始化的。当和 RAII 模式结合时，静态局部变量可以取代为初始化自己编写双检查锁定的需求。`std::call_once` 也可以达成相同的目的。请使用 C++11 的静态局部变量或者 `std::call_once` 来代替自己为初始化编写的双检查锁定。
### CP.111: 当确实需要双检查锁定时应当采用惯用的模式
双检查锁定是很容易被搞乱的。如果确实需要编写自己的双检查锁定，而不顾规则 CP.110: 不要为初始化编写你自己的双检查锁定和规则 CP.100: 除非绝对必要，请勿使用无锁编程，那么应当采用惯用的模式。
使用双检查锁定模式而不违反CP.110: 不要为初始化编写你自己的双检查锁定的情形，出现于当某个非线程安全的动作既困难也罕见，并且存在某个快速且线程安全的测试可以用于保证该动作并不需要实施的情况，但反过来的情况则无法保证。
## CP.etc: Etc. concurrency rules
### CP.200: `volatile` 仅用于和非 C++ 内存进行通信
`volatile` 用于涉指那些与“非 C++”代码之间共享的对象，或者不遵循 C++ 内存模型的硬件。
- 对 `volatile T` 的局部变量和数据成员进行标记；几乎肯定你应当用 `atomic<T>` 进行代替。
# E: Error handling
### E.1: 在设计中尽早开发错误处理策略
在一个系统中改造翻新一种一致且完整的处理错误和资源泄漏的策略是很难的。
### E.2: 通过抛出异常来明示函数无法完成其所赋予的任务
让错误处理有系统性，强健，而且避免重复。
### E.3: 仅使用异常来进行错误处理
以保持错误处理和“常规代码”互相分离。 C++ 实现都倾向于基于假定异常的稀有而进行优化。
### E.4: 围绕不变式来设计错误处理策略
要使用一个对象，它必须处于某个（正式或非正式通过不变式所定义的）有效的状态，而要从错误中恢复，每个还未销毁的对象也必须处于有效的状态。
### E.5: 让构造函数建立不变式，若其无法做到则抛出异常
遗留仍未建立不变式的对象将会带来麻烦。 不是任何成员函数都可以对其进行调用。
对带有 `private` 状态但没有（公开，受保护或私有的）构造函数的类进行标记。
### E.6: 使用 RAII 来避免泄漏
资源泄漏通常是不可接受的。 手工的资源释放很易出错。 RAII（Resource Acquisition Is Initialization，资源获取即初始化）是最简单，最系统化的避免泄漏方案。
当我们所编写的程序不能使用异常时应当怎么办呢？ 首先应当质疑这项假设；到处都有许多反异常的错误认识。 据我们所知，只有少量正当理由：
- 我们所在的系统太小，支持异常将会吃掉我们的 2K 内存的大部分。
- 我们所在的是硬实时系统，而且我们没有工具能保证异常会在所需时间内处理掉。
- 我们所在的系统中有成吨的遗留代码以难于理解的方式大量地使用指针 （尤其是没有可识别的所有权策略），因此异常可能会造成泄露。
- 我们的 C++ 异常机制的实现不合理地糟糕 （很慢，很耗内存，对于动态链接库无法正确工作，等等）。 请向你的实现的供应商提出意见；如果没有用户提出意见，就不会出现改进。
- 如果我们质疑经理的古老智慧的话会被炒鱿鱼。
以上原因中只有第一条才是基础问题，因此一旦可能的话，还是要用异常来实现 RAII，或者设计你的 RAII 对象永不失败。 当无法使用异常时，可以模拟 RAII。 就是说，系统化地在对象构造之后检查其有效性，并且仍然在析构函数中释放所有的资源。
### E.7: 明示前条件
避免接口错误。
### E.8: 明示后条件
避免接口错误。
### E.12: 当函数不可能或不能接受以 `throw` 来退出时，使用 `noexcept`
使错误处理系统化，强健，且高效。
### E.13: 不要在作为某个对象的直接所有者时抛出异常
这可能导致一次泄漏。
```cpp
void leak(int x)   // 请勿如此: 可能泄漏
{
    auto p = new int{7};
    if (x < 0) throw Get_me_out_of_here{};  // 可能泄漏 *p
    // ...
    delete p;   // 可能不会执行到这里
}
```
### E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常
自定义类型可以把有关某个错误的信息更好地传递给处理器。 这些信息可以编码到类型自身中，而类型则不大可能会和其他人的异常造成冲突。
```cpp
throw 7; // 不好

throw "something bad";  // 不好

throw std::exception(); // 不好 - 未提供信息
```
从 `std::exception` 派生，能够获得选择捕获特定异常或者通过 `std::exception` 进行通盘处理的灵活性：
```cpp
class MyException: public std::runtime_error
{
public:
    MyException(const string& msg) : std::runtime_error(msg) {}
    // ...
};

// ...

throw MyException("something bad");  // 好
```
异常可以不必派生于 `std::exception`：
```cpp
class MyCustomError final {};  // 并未派生于 std::exception

// ...

throw MyCustomError{};  // 好 - 处理器必须捕获这个类型（或 ...）
```
当检测位置没有可以添加的有用信息时，可以使用派生于 `exception` 的库类型作为通用类型：
```cpp
throw std::runtime_error{"something bad"}; // 好

// ...

throw std::invalid_argument("i is not even"); // 好
```
也可以使用 `enum` 类：
```cpp
enum class alert {RED, YELLOW, GREEN};

throw alert::RED; // 好
```
识别针对内建类型和 `std::exception` 的 `throw`。
### E.15: 按值抛出并按引用捕获类型层次中的异常
按值（而非指针）抛出并按引用捕获，能避免进行复制，尤其是基类子对象的切片。
- 对按值捕获具有虚函数的类型进行标记。
- 对抛出原始指针进行标记。
### E.16: 析构函数，回收函数，`swap`，以及异常类型的复制/移动构造决不能失败
如果析构函数，`swap`，内存回收，或者尝试复制/移动异常对象时会失败，就是说如果它会通过异常而退出，或者根本不会实施其所需的动作，我们就将不知道应当如何编写可靠的程序。
- 回收函数，包括 `operator delete`，必须为 `noexcept`。
- `swap` 函数必须为 `noexcept`。
- 大多数的析构函数都是缺省隐含为 `noexcept` 的。
- 而且，应该使移动操作为 noexcept。
- 当编写用作异常类型的类型时，确保其复制构造函数为 `noexcept`。一般来说我们没法机制化地强制这一点，因为我们并不了解一个类型是否有意作为一种异常类型。
- 尝试避免抛出复制构造函数不为 `noexcept` 的类型。一般来说我们没法机制化地强制这一点，因为即便 `throw std::string(...)` 也可能抛异常，虽然实际上并不会。

- 识别会 `throw` 的析构函数，回收操作，和 `swap`。
- 识别不为 `noexcept` 的这类操作。
### E.17: 不要试图在每个函数中捕获每个异常
如果函数无法对异常进行有意义的恢复动作，其捕获这个异常就导致复杂性和浪费。 要让异常传播直到遇到一个可以处理它的函数。 要用 RAII 来处理栈回溯路径上的清理操作。
- 标记嵌套的 `try` 块。
- 对带有过高的 `try` 块/函数比率的源代码文件进行标记。
### E.18: 最小化对 `try`/`catch` 的显式使用
`try`/`catch` 很啰嗦，而且非平凡的使用是易错的。 `try`/`catch` 可以作为对非系统化和/或低级的资源管理或错误处理的一个信号。
### E.19: 当没有合适的资源包装时，使用 `final_action` 对象来表达清理动作
GSL 提供的 finally 要比 try/catch 更不啰嗦且难于搞错。
finally 没有 try/catch 那样混乱，但它仍然比较专门化。 优先采用适当的资源管理对象。 万不得已考虑使用 finally。
检测 `goto exit;`。
### E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理
即便没有异常，RAII 通常仍然是最佳且最系统化的处理资源的方式。
### E.26: 当不能抛出异常时，考虑采取快速失败
如果你无法做好错误恢复的话，至少你可以在发生更多后续的损害之前摆脱出来。
### E.27: 当不能抛出异常时，系统化地使用错误代码
系统化地使用任何错误处理策略都能最小化忘记处理错误的机会。
### E.28: 避免基于全局状态（比如 `errno`）的错误处理
全局状态难于管理，且易于忘记检查。 你上次检查 `printf()` 的返回值是什么时候了？
### E.30: 请勿使用异常说明
异常说明使得错误处理变得脆弱，隐含一些运行时开销，并且已经从 C++ 标准中被删除了。
### E.31: 恰当地对 `catch` 子句排序
`catch` 子句是以其出现顺序依次求值的，而其中一个可能会隐藏掉另一个。
```cpp
void f()
{
    // ...
    try {
            // ...
    }
    catch (Base& b) { /* ... */ }
    catch (Derived& d) { /* ... */ }
    catch (...) { /* ... */ }
    catch (std::exception& e) { /* ... */ }
}
```
若 `Derived` 派生自 `Base` 则 `Derived` 的处理器永远不会被执行。 “捕获任何东西”的处理器保证 `std::exception` 的处理器永远不会被执行。
标记出所有的“隐藏处理器”。
# Con: Constants and immutability
### Con.1: 缺省情况下，对象应当是不可变的
不可变对象更易于进行推理，应仅当需要改动对象的值时，才使之为非 `const` 对象。 避免出现意外造成的或者很难发觉的值的改变。
- 标记未发生改动的非 `const` 变量（排除参数以避免误报，排除被返回的局部变量）
### Con.2: 缺省情况下，成员函数应当为 `const`
除非成员函数会改变对象的可观察状态，否则它应当标记为 `const`。 这样做更精确地描述了设计意图，具有更佳的可读性，编译器可以识别更多的错误，而且有时能够带来更多的优化机会。
- 如果未标记为 `const` 的成员函数并未对任何数据成员实施非 `const` 操作的话，对其进行标记。
### Con.3: 缺省情况下，应当传递指向 `const` 对象的指针或引用
避免所调用的函数意外地改变了这个值。 如果被调用的函数不会改动状态的话，对程序的推理将变得容易得多。
- 如果函数并未修改以指向非 `const` 的指针或引用传递的对象，则对其进行标记。
- 如果函数（利用强制转换）修改了以指向 `const` 的指针或引用传递的对象，则对其进行标记。
### Con.4: 构造之后不再改变其值的对象应当以 `const` 来定义
避免意外地改变对象的值。
- 标记并未被修改的非 `const` 变量。
### Con.5: 以 `constexpr` 来定义可以在编译期计算的值
更好的性能，更好的编译期检查，受保证的编译期求值，竞争条件可能性为零。
- 对带有常量表达式初始化式的 `const` 定义进行标记。
# T: Templates and generic programming
## T.gp: Generic programming
### T.1: 用模板来提升代码的抽象层次
通用性。重用。效率。鼓励用户类型的定义一致性。
- 对带有“过于简单”的要求（诸如不用概念而直接使用特定的运算符）的算法进行标记。
- 不要对“过于简单”的概念本身进行标记；它们也许只不过是更有用的概念的构造块。
### T.2: 用模板来表达适用于许多参数类型的算法
通用性。最小化源代码数量。互操作性。重用。
### T.3: 用模板来表达容器和范围
容器需要一种元素类型，而将之表示为一个模板参数则是通用的，可重用的，且类型安全的做法。 这样也避免了采用脆弱的或者低效的变通手段。约定：这正是 STL 的做法。
- 对出现于低级实现代码之外的 `void*` 和强制转换进行标记。
### T.5: 结合泛型和面向对象技术来增强它们的能力，而不是它们的成本
泛型和面向对象技术是互补的。
## T.concepts: Concept rules
## T.con-use: Concept use
### T.10: 为所有模板实参指明概念
正确性和可读性。 针对模板参数所假定的含义（包括语法和语义），是模板接口的基础部分。 使用概念能够显著改善模板的文档和错误处理。 为模板参数指定概念是一种强力的设计工具。
对没有概念的模板类型参数进行标记。
### T.11: 尽可能采用标准概念
“标准”概念（即由 GSL 和 ISO 标准自身所提供的概念)， 避免了我们思考自己的概念，它们比我们匆忙中能够想出来的要好得多，而且还提升了互操作性。
- 查找无约束的参数，使用“非常规”或非标准的概念的模板，以及使用“自造的”又没有公理的概念的目标。
### T.12: 对于局部变量，优先采用概念名而不是 `auto`
`auto` 是最弱的概念。概念的名字会比仅用 `auto` 传达出更多的意义。
### T.13: 对于简单的单类型参数概念，优先采用简写形式
可读性。直接表达意图。
- 当人们从 `<typename T>` 和 `<class T>` 写法进行转换时，使用简短形式是不可行的。
- 之后，如果声明中首先引入了一个 `typename`，之后又用简单的单类型参数概念对其进行约束的话，就对其进行标记。
## T.concepts.def: Concept definition rules
### T.20: 避免没有有意义的语义的“概念”
概念是用于表现语义的观念的，比如“数”，元素的“范围”，以及“全序的”等等。 简单的约束，比如“带有 `+` 运算符”和“带有 `>` 运算符”，是无法独立进行有意义的运用的， 而仅应当被用作有意义的概念的构造块，而不是在用户代码中使用。
- 对在其他 `concept` 的定义之外使用的单操作 `concept` 进行标记。
- 对表现为模拟单操作 `concept` 的 `enable_if` 的使用进行标记。
### T.21: 为概念提出一组完整的操作要求
易于理解。 提升互操作性。 帮助实现者和维护者。
- 如果类所支持的运算符是运算符集合的“奇异”子集，比如有 `==` 但没有 `!=` 或者有 `+` 但没有 `-`，就对其进行标记。 确实，`std::string` 也是“奇异”的，但要修改它太晚了。
### T.22: 为概念指明公理
有意义或有用的概念都有语义上的含义。 以非正式、半正式或正式的方式表达这些语义可以使概念对于读者更加可理解，而且对其进行表达的工作也能发现一些概念上的错误。 对语义的说明是一种强大的设计工具。
- 在概念定义的代码注释中寻找单词“axiom”。
### T.23: 通过添加新的使用模式，从更一般情形的概念中区分出提炼后的概念
否则编译器是无法自动对它们进行区分的。
- 对与已经出现的另一个概念具有完全相同的要求的概念进行标记（它们中不存在更精炼的概念）。
### T.24: 用标签类或特征类来区分仅在语义上存在差别的概念
要求相同的语法但具有不同语义的两个概念之间会造成歧义，除非程序员对它们进行区分。
- 编译器会将对相同的概念的有歧义的使用标记出来。
- 对相同的概念定义进行标记。
### T.25: 避免互补性的约束
清晰性。可维护性。 用否定来表达的具有互补要求的函数是很脆弱的。
- 对带有 `C<T>` 和 `!C<T>` 约束的函数对进行标记。
### T.26: 优先采用使用模式而不是简单的语法来定义概念
其定义更可读，而且更直接地对应于用户需要编写的代码。 其中同时兼顾了类型转换。你再不需要记住所有的类型特征的名字。
## Template interfaces
### T.40: 使用函数对象向算法传递操作
函数对象比“普通”的函数指针能够向接口传递更多的信息。 一般来说，传递函数对象比传递函数指针能带来更好的性能。
- 标记以函数指针作为模板参数。
- 标记将函数指针作为模板的参数进行传递（存在误报风险）。
### T.41: 在模板的概念上仅提出基本的性质要求
保持接口的简单和稳定。
### T.42: 使用模板别名来简化写法并隐藏实现细节
提升可读性。 隐藏实现。 注意，模板别名取代了许多用于计算类型的特征。 它们也可以用于封装一个特征。
- 将 `using` 声明之外用于消除歧义的 `typename` 进行标记。
### T.43: 优先使用 `using` 而不是 `typedef` 来定义别名
提升可读性：使用 `using` 时，新名字在前面，而不是被嵌在声明中的什么地方。 通用性：`using` 可用于模板别名，而 `typedef` 无法轻易作为模板。 一致性：`using` 在语法上和 `auto` 相似。
```cpp
typedef int (*PFI)(int);   // OK, 但很别扭

using PFI2 = int (*)(int);   // OK, 更好

template<typename T>
typedef int (*PFT)(T);      // 错误

template<typename T>
using PFT2 = int (*)(T);   // OK
```
- 标记 `typedef` 的使用。不过这样会出现大量的“命中” :-(
### T.44: （如果可行）使用函数模板来对类模板的参数类型进行推断
显式写出模板参数类型既麻烦又无必要。
```cpp
tuple<int, string, double> t1 = {1, "Hamlet", 3.14};   // 明确类型
auto t2 = make_tuple(1, "Ophelia"s, 3.14);         // 更好；推断类型
```
注意，C++17 将允许模板参数直接从构造函数参数进行推断，而使这条规则变得多余
```cpp
tuple t1 = {1, "Hamlet"s, 3.14}; // 推断为：tuple<int, string, double>
```
当显式指定的类型与所使用的类型精确匹配时进行标记。
### T.46: 要求模板参数至少是半正规的
可读性。 避免意外和错误。 大多数用法都支持这样做。
`SemiRegular` 要求可以默认构造。
- 对并非至少为 `SemiRegular` 的类型进行标记。
### T.47: 避免用常用名字命名高度可见的无约束模板
无约束的模板参数和任何东西都能完全匹配，因此这样的模板相对于需要少量转换的更特定类型来说可能更优先。 而当使用 ADL 时，这一点将会更加麻烦和危险。 而常用的名字则会让这种问题更易于出现。
如果定义模板的命名空间中同样定义了具体的类型，就对其进行标记（可能在我们有概念支持之前都是不可行的）。
### T.48: 如果你的编译器不支持概念的话，可以用 `enable_if` 来模拟
因为这是我们没有直接的概念支持时能够做到的最好的方式。 `enable_if` 可被用于有条件地定义函数，以及用于在一组函数中进行选择。
### T.49: 尽可能避免类型擦除
类型擦除通过在一个独立的编译边界之后隐藏类型信息而招致一层额外的间接。
## T.def: Template definitions
### T.60: 最小化模板的上下文依赖性
便于理解。 最小化源于意外依赖的错误。 便于创建工具。
### T.61: 请勿对成员进行过度参数化（SCARY）
不依赖于模板参数的成员，除非给定某个特定的模板参数，否则也是无法使用的。 这样会限制其使用，而且通常会增加代码大小。
- 对并未依赖于全部模板形参的成员类型进行标记。
- 对并未依赖于全部模板形参的成员函数进行标记。
- 对并未依赖于全部模板形参的 lambda 表达式或变量模板进行标记。
### T.62: 将无依赖的类模板成员置于一个非模板基类之中
可以在使用基类成员时不需要指定模板参数，也不需要模板实例化。
### T.64: 用特化来提供类模板的其他实现
模板定义了通用接口。 特化是一种为这个接口提供替代实现的强大机制。
### T.65: 用标签分派来提供函数的其他实现
- 模板定义了通用接口。
- 标签派发允许我们基于参数类型的特定性质选择不同的实现。
- 性能。
### T.68: 在模板中用 `{}` 而不是 `()` 以避免歧义
`()` 会带来文法歧义。
```cpp
template<typename T, typename U>
void f(T t, U u)
{
    T v1(T(u));    // 错误：啊，v1 是函数而不是变量
    T v2{u};       // 清晰：显然是变量
    auto x = T(u); // 不清晰：构造还是强制转换？
}

f(1, "asdf"); // 不好：从 const char* 强制转换为 int
```
- 标记 `()` 初始化式。
- 标记函数风格的强制转换。
### T.69: 在模板中，请勿进行未限定的非成员函数调用，除非有意将之作为定制点
- 仅提供预计之内的灵活性。
- 避免源于意外的环境改变的威胁。

- 在模板中，如果非成员函数的无限定调用传递了具有依赖类型的变量，而在该模板的命名空间中存在相同名字的非成员函数，则对其进行标记。
## T.temp-hier: Template and hierarchy rules
### T.80: 请勿不成熟地对类层次进行模板化
使一个带有许多函数，尤其是有许多虚函数的类层次进行模板化，会导致代码膨胀。
- 对依赖于模板参数的虚函数进行标记。
### T.81: 请勿混合类层次和数组
派生类的数组可以隐式地“退化”成指向基类的指针，并带来潜在的灾难性后果。
```cpp
void maul(Fruit* p)
{
    *p = Pear{};     // 把一个 Pear 放入 *p
    p[1] = Pear{};   // 把一个 Pear 放入 p[1]
}

Apple aa [] = { an_apple, another_apple };   // aa 包含的是 Apple （显然！）

maul(aa);
Apple& a0 = &aa[0];   // 是 Pear 吗？
Apple& a1 = &aa[1];   // 是 Pear 吗？
```
- 对这种恐怖的东西进行检测！
### T.83: 请勿声明虚的成员函数模板
C++ 是不支持这样做的。 如果支持的话，就只能等到连接时才能生成 VTBL 了。 而且一般来说，各个实现还要搞定动态连接的问题。
编译器会处理这个问题。
### T.84: 使用非模板的核心实现来提供 ABI 稳定的接口
提升代码的稳定性。 避免代码爆炸。
## T.var: Variadic template rules
### T.100: 当需要可以接受可变数量的多种类型参数的函数时，使用变参模板
变参模板是做到这点的最通用的机制，而且既高效又类型安全。请不要使用 C 的变参。
- 对用户代码中 `va_arg` 的使用进行标记。
### T.103: 请勿对同质参数列表使用变参模板
存在更加正规的给出同质序列的方式，比如使用 `initializer_list`。
## T.meta: Template metaprogramming (TMP)
### T.120: 仅当确实需要时才使用模板元编程
模板元编程很难做对，它会拖慢编译速度，而且通常很难维护。 不过，现实世界有些例子中模板元编程提供了比其他专家级的汇编代码替代方案还要更好的性能。 而且，也存在现实世界的例子用模板元编程做到比运行时代码更好地表达基本设计意图的情况。 例如，当确实需要在编译期进行 AST 操作时，（比如说对矩阵操作进行可选的折叠），C++ 中可能没有其他的实现方式。
### T.121: 模板元编程主要用于模拟概念机制
不能使用 C++20 时，我们需要用 TMP 来模拟它。 对概念给出要求的用例（比如基于概念进行重载）是 TMP 的最常见（而且最简单）的用法。
### T.122: 用模板（通常为模板别名）来在编译期进行类型运算
模板元编程是在编译期进行类型生成的受到直接支持和部分正规化的唯一方式。
### T.123: 用 `constexpr` 函数来在编译期进行值运算
函数是用于表达计算一个值的最显然和传统的方式。 通常 `constexpr` 函数都比其他的替代方式具有更少的编译期开销。
- 对产生值的模板元程序进行标记。它们应当被替换成 `constexpr` 函数。
### T.124: 优先使用标准库的模板元编程设施
标准中所定义的设施，诸如 `conditional`，`enable_if`，以及 `tuple` 等，是可移植的，可以假定为大家所了解。
### T.125: 当需要标准库之外的模板元编程设施时，使用某个现存程序库
要搞出高级的 TMP 设施是很难的，而使用一个库则可让你进入某个（有希望收到支持的）社区。 只有当确实不得不编写自己的“高级 TMP 支持”时，才应当这样做。
## Other template rules
### T.143: 请勿编写并非有意非泛型的代码
一般性。可重用性。请勿无必要地陷入技术细节之中；请使用最广泛可用的设施。
用 `!=` 而不是 `<` 来比较迭代器；`!=` 可以在更多对象上正常工作，因为它并未蕴含有序性。
```cpp
for (auto i = first; i < last; ++i) {   // 通用性较差
    // ...
}

for (auto i = first; i != last; ++i) {   // 好; 通用性较强
    // ...
}
```
当然，范围式 `for` 在符合需求的时候当然是更好的选择。

使用能够提供所需功能的最接近基类的类。
```cpp
class Base {
public:
    Bar f();
    Bar g();
};

class Derived1 : public Base {
public:
    Bar h();
};

class Derived2 : public Dase {
public:
    Bar j();
};

// 不好，除非确实有特别的原因来将之仅限制为 Derived1 对象
void my_func(Derived1& param)
{
    use(param.f());
    use(param.g());
}

// 好，仅使用 Base 的接口，且保证了这个类型
void my_func(Base& param)
{
    use(param.f());
    use(param.g());
}
```
- 对使用 `<` 而不是 `!=` 的迭代器比较进行标记。
- 当存在 `x.empty()` 或 `x.is_empty()` 时，对 `x.size() == 0` 进行标记。`empty()` 比 `size()` 能够对于更多的容器工作，因为某些容器是不知道自己的大小的，甚至概念上就是大小无界的。
- 如果函数接受指向更加派生的类型的指针或引用，但仅使用了在某个基类中所声明的函数，则对其进行标记。
### T.144: 请勿特化函数模板
根据语言规则，函数模板是无法被部分特化的。函数模板可以被完全特化，不过你基本上需要的都是进行重载而不是特化——因为函数模板特化并不参与重载，它们的行为和你想要的可能是不同的。少数情况下，应当通过你可以进行适当特化的类模板来进行真正的特化。
- 标记出所有的函数模板特化。代之以函数重载。
### T.150: 用 `static_assert` 来检查类是否与概念相符
当你打算使一个类符合某个概念时，应该提早进行验证以减少麻烦。
# CPL: C-style programming
### CPL.1: 优先使用 C++ 而不是 C
C++ 提供更好的类型检查和更多的语法支持。 它能为高层的编程提供更好的支持，而且通常会产生更快速的代码。
使用 C++ 编译器。
### CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译
- 当使用某种将代码作为 C 来编译的构建模式时进行标记。
	- C++ 将会确保代码是合法的 C++ 代码，除非使用了 C 扩展的编译器选项。
### CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的代码中使用 C++
C++ 比 C 的表达能力更强，而且为许多种类的编程都提供了更好的支持。
# SF: Source files
### SF.2: 头文件不能含有对象定义或非内联的函数定义
对受制于唯一定义规则的实体的包含将导致连接错误。
头文件必须仅包含：
- `#include` 其他的头文件（可能包括包含防卫宏）
- 模板
- 类定义
- 函数声明
- `extern` 声明
- `inline` 函数定义
- `constexpr` 定义
- `const` 定义
- `using` 别名定义
根据以上白名单来检查。
### SF.3: 对在多个源文件中使用的任何声明，都应使用头文件
可维护性。可读性。
- 对并未放入 `.h` 而在其他源文件中的实体声明进行标记。
### SF.4: 在文件中的其他所有声明之前包含头文件
最小化上下文的依赖并增加可读性。
### SF.5: `.cpp` 文件必须包含定义了它的接口的一个或多个头文件
这使得编译器可以提早进行一致性检查。
### SF.6: `using namespace` 指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如 `std`），或者在局部作用域中使用
`using namespace` 可能造成名字冲突，因而应当节制使用。 然而，将用户代码中的每个命名空间中的名字都进行限定并不总是能够做到（比如在转换过程中） 而且有时候命名空间非常基础，并且在代码库中广为使用，坚持进行限定将使其既啰嗦又分散注意力。
### SF.7: 请勿在头文件中的全局作用域使用 `using namespace`
这样做使 `#include` 一方无法有效地进行区分并使用其他方式。这还可能使所 `#include` 的头文件之间出现顺序依赖，它们以不同次序包含时可能具有不同的意义。
一个例外是 `using namespace std::literals;`。若要在头文件中使用 字符串字面量，则必须如此，而且根据规则——用户必须以 `operator""_x` 来命名他们自己的 UDL——它们并不会与标准库相冲突。
标记头文件的全局作用域中的 `using namespace`。
### SF.8: 为所有的头文件使用 `#include` 防卫宏
避免文件被多次 `#include`。
为避免包含防卫宏的冲突，不要仅使用文件名来命名防卫宏。 确保还要包含一个关键词和好的区分词，比如头文件所属的程序库 或组件的名字。
标记没有 `#include` 防卫的 `.h` 文件。
一些实现提供了如 `#pragma once` 这样的厂商扩展作为包含防卫宏的替代。 这并非标准且不可移植。它向程序中注入了宿主机器的文件系统的语义， 而且把你锁定到某个特定厂商。 我们的建议是编写 ISO C++
### SF.9: 避免源文件的循环依赖
循环会使理解变得困难，并拖慢编译速度。 它们还会使（当其可用时）向利用语言支持的模块进行转换工作变得复杂。
要消除循环依赖；请勿仅仅用 `#include` 防卫宏来试图打破它们。
```cpp
// file1.h:
#include "file2.h"

// file2.h:
#include "file3.h"

// file3.h:
#include "file1.h"
```
对任何循环依赖进行标记。
### SF.10: 避免依赖于隐含地 `#include` 进来的名字
避免意外。 避免当 `#include` 的头文件改变时改变一条 `#include`。 避免意外地变为依赖于所包含的头文件中的实现细节和逻辑上独立的实体。
```cpp
#include <iostream>
using namespace std;

void use()
{
    string s;
    cin >> s;               // 好
    getline(cin, s);        // 错误：getline() 未定义
    if (s == "surprise") {  // 错误：== 未定义
        // ...
    }
}
```
一些头文件正是用于从一些头文件中合并一组声明。
用户只用一条 `#include` 就可以获得整组的声明了
本条反对隐式包含的规则并不防止这种特意的聚集包含。
### SF.11: 头文件应当是自包含的
易用性，头文件应当易于使用，且单独包含即可正常工作。 头文件应当对其所提供的功能进行封装。 避免让头文件的使用方来管理它的依赖项。
以一项测试来验证头文件自身可通过编译，或者一个仅包含了该头文件的 cpp 文件可通过编译。
### SF.12: 对相对于包含文件的文件优先采用引号形式的 `#include`，其他情况下采用角括号形式
标准 向编译器提供了对于实现 使用角括号（`<>`）或引号（`""`）语法的 `#include` 的两种形式的灵活性。 各厂商利用了这点并采用了不同的搜索算法和指定包含路径的方法。
无论如何，指导方针是使用引号形式来（从同一个组件或项目中）包含那些存在于某个相对于含有这条 `#include` 语句的文件的相对路径中的文件，其他情况尽可能使用角括号形式。这样做鼓励明确表现出文件与包含它的文件之间的局部性，或当需要某种不同的搜索算法的情形。这样一眼就可以很容易明白头文件是从某个局部相对文件包含的，还是某个标准库头文件或别的搜索路径（比如另一个程序库或一组常用包含路径）中的某个头文件。
```cpp
// foo.cpp:
#include <string>                // 来自标准程序库，要求使用 <> 形式
#include <some_library/common.h> // 从另一个程序库中包含的，并非出于局部相对位置的文件；使用 <> 形式
#include "foo.h"                 // 处于同一项目中局部相对于 foo.cpp 的文件，使用 "" 形式
#include "util/util.h"           // 处于同一项目中局部相对于 foo.cpp 的文件，使用 "" 形式
#include <component_b/bar.h>     // 通过搜索路径定位到的处于同一项目中的文件，使用 <> 形式
```
检测按 `""` 引用的头文件是否可以按 `<>` 引用。
### SF.13: 在 `#include` 语句中使用可移植的标识符
标准并未指定编译器是怎样从 `#include` 指令中的标识符唯一定位头文件的，它也没有指定由什么构成唯一性。例如，实现是否将标识符视为大小写敏感，或标识符是否是到头文件的文件系统路径，以及若是如此，文件系统路径的层次是如何分隔的。
为了最大化 `#include` 指令跨编辑器的可移植性，指导方案是：
- 使用大小写敏感的头文件标识符，与标准、规范、实现或提供头文件的文件的定义保持一致。
- 当头文件标识符是层次化文件路径时，使用前向斜杠 `/` 分隔路径组分，因为这是最广泛接受的路径分隔字符。
```cpp
// 好例子
#include <vector>
#include <string>
#include "util/util.h"

// 坏例子
#include <VECTOR>        // 不好：标准程序库定义的头文件标识为 <vector>，而非 <VECTOR>
#include <String>        // 不好：标准程序库定义的头文件标识为 <string>，而非 <String>
#include "Util/Util.H"   // 不好：存在于文件系统中的头文件是 "util/util.h"
#include "util\util.h"   // 不好：如果实现将 `\u` 判读为转义序列，或者 '\' 不是有效路径分隔符时，这无法工作
```
只可能在头文件标识符大小写敏感且仅支持 `/` 为文件路径分隔符的实现上予以强制。
### SF.20: 用 `namespace` 表示逻辑结构
### SF.21: 请勿在头文件中使用无名（匿名）命名空间
在头文件中使用无名命名空间差不多都是一个 BUG。
- 对头文件中所使用的任何匿名命名空间进行标记。
### SF.22: 为所有的内部/不导出的实体使用无名（匿名）命名空间
外部实体无法依赖于嵌套的无名命名空间中的实体。 考虑将实现源文件中的所有定义都放入无名命名空间中，除非它定义的是一个“外部/导出”实体。
# SL: The Standard Library
### SL.1: 尽可能使用程序库
节约时间。避免重复发明轮子。 避免重复他人的工作。 如果其他人的工作有了改进，则可以从中获得好处。 当你进行了改进之后可以帮助其他人。
### SL.2: 优先使用标准库而不是其他程序库
了解标准库的人更多。 相对于你自己的代码或者大多数其他程序库来说，标准库更加倾向于稳定，进行了良好维护，而且广泛可用。
### SL.3: 请勿向命名空间 `std` 中添加非标准实体
向 `std` 中添加东西可能会改变本来是遵循标准的代码的含义。 添加到 `std` 的东西可能会与未来版本的标准产生冲突。
### SL.4: 以类型安全的方式使用标准库
因为，很显然，违反这条规则将导致未定义的行为，内存损坏，以及其他所有种类的糟糕的错误。
## SL.con: Containers
### SL.con.1: 优先采用 STL 的 `array` 或 `vector` 而不是 C 数组
C 数组不那么安全，而且相对于 `array` 和 `vector` 也没有什么优势。 对于定长数组，应使用 `std::array`，它传递给函数时并不会退变为指针并丢失其大小信息。 而且，和内建数组一样，栈上分配的 `std::array` 会在栈上保存它的各个元素。 对于变长数组，应使用 `std::vector`，它还可以改变大小并处理内存分配。
- 如果 C 数组的声明所在的函数或类也声明了 STL 的某个容器（这是为了避免在老式的非 STL 代码中的大量警告噪音），则对其进行标记。修正：最少要把 C 数组改成 `std::array`。
### SL.con.2: 除非有理由使用别的容器，否则默认情况应优先采用 STL 的 `vector`
`vector` 和 `array` 是仅有的能够提供以下各项优势的标准容器：
- 最快的通用访问（随机访问，还包括对于向量化友好性）；
- 最快的默认访问模式（从头到尾或从尾到头方式是对预读器友好的）；
- 最少的空间耗费（连续布局中没有每个元素的开销，而且是 cache 友好的）。
通常你都需要对容器进行元素的添加和删除，因此默认应当采用 `vector`；如果并不需要改动容器的大小的话，则应采用 `array`。
即便其他容器貌似更加合适，比如 `map` 的 O(log N) 查找性能，或者 `list` 的中部高效插入，对于几个 KB 以内大小的容器来说，`vector` 仍然经常性能更好。
如果你有正当的理由来使用别的容器的话，就请使用它。例如：
- 若 `vector` 满足你的需求，但你并不需要容器大小可变，则应当代之以 `array`。    
- 若你需要支持字典式查找的容器并保证 O(K) 或 O(log N) 的查找效率，而且容器将会比较大（超过几个 KB），你需要经常进行插入使得维护有序的 `vector` 的开销不大可行，则请代之以使用 `unordered_map` 或者 `map`。
### SL.con.3: 避免边界错误
越过已分配的元素的范围进行读写，通常都会导致糟糕的错误，不正确的结果，程序崩溃，以及安全漏洞。
### SL.con.4: 请勿对非可平凡复制的实参使用 `memset` 或 `memcpy`
这样做会破坏对象语义（例如，其会覆写掉 `vptr`）。
- 对在不可平凡复制的类型使用这些函数进行标记
## SL.str: String
### SL.str.1: 使用 `std::string` 以拥有字符序列
`string` 能够正确处理资源分配，所有权，复制，渐进扩容，并提供许多有用的操作。
C++17 中，我们可以使用 `string_view` 而不是 `const string&` 作为参数，以允许调用方更大的灵活性。
### SL.str.2: 使用 `std::string_view` 或 `gsl::span<char>` 以指代字符序列
`std::string_view` 或 `gsl::span<char>` 提供了简易且（潜在）安全的对字符序列的访问，并与序列的分配和存储方式无关。
### SL.str.3: 使用 `zstring` 或 `czstring` 以指代 C 风格、以零结尾的字符序列
可读性。 明确意图。 普通的 `char*` 可以是指向单个字符的指针，指向字符数组的指针，指向 C 风格（零结尾）字符串的指针，甚或是指向小整数的指针。 对这些情况加以区分能够避免误解和 BUG。
- 标记在 `char*` 上使用的 `[]`
- 标记在 `char*` 上使用的 `delete`
- 标记在 `char*` 上使用的 `free()`
### SL.str.4: 使用 `char*` 以指代单个字符
现存代码中对 `char*` 的各种不同用法，是一种主要的错误来源。
```cpp
char arr[] = {'a', 'b', 'c'};

void print(const char* p)
{
    cout << p << '\n';
}

void use()
{
    print(arr);   // 运行时错误；可能非常糟糕
}
```
数组 `arr` 并非 C 风格字符串，因为它不是零结尾的。
- 标记在 `char*` 上使用的 `[]`
### SL.str.5: 使用 `std::byte` 以指代并不必须表示字符的字节值
用 `char*` 来表示指向不一定是字符的东西的指针会造成混乱， 并会妨碍有价值的优化。
### SL.str.10: 当需要实施相关于文化地域的操作时，使用 `std::string`
`std::string` 支持标准库的 `locale` 功能
### SL.str.11: 当需要改动字符串时，使用 `gsl::span<char>` 而不是 `std::string_view`
`std::string_view` 是只读的。
### SL.str.12: 为作为标准库的 `string` 类型的字符串字面量使用后缀 `s`
直接表达想法能够最小化犯错机会。
```cpp
auto pp1 = make_pair("Tokyo", 9.00);         // {C 风格字符串,double} 有意如此？
pair<string, double> pp2 = {"Tokyo", 9.00};  // 稍微啰嗦
auto pp3 = make_pair("Tokyo"s, 9.00);        // {std::string,double}    // C++14
pair pp4 = {"Tokyo"s, 9.00};                 // {std::string,double}    // C++17
```
## SL.io: Iostream
### SL.io.1: 仅在必要时才使用字符层面的输入
除非你确实仅处理单个的字符，否则使用字符级的输入将导致用户代码实施潜在易错的 且潜在低效的从字符进行标记组合的工作。
```cpp
char c;
char buf[128];
int i = 0;
while (cin.get(c) && !isspace(c) && i < 128)
    buf[i++] = c;
if (i == 128) {
    // ... 处理过长的字符串 ....
}
```
更好的做法（简单得多而且可能更快）：
```cpp
string s;
s.reserve(128);
cin>>s;
```
而且可能并不需要 `reserve(128)`。
### SL.io.2: 当进行读取时，总要考虑非法输入
错误通常最好尽快处理。 如果输入无效，所有的函数都必须编写为对付不良的数据（而这并不现实）。
### SL.io.3: 优先使用 iostream 进行 I/O
`iosteam` 安全，灵活，并且可扩展。
##### 讨论：`iostream` vs. `printf()` 家族
人们通常说（并且通常是正确的）`printf` 家族比 `iostream` 有两个优势： 格式化的灵活性和性能。 这需要与 `iostream` 在处理用户定义类型方面的扩展性，针对安全性的违反方面的韧性， 隐含的内存管理，以及 `locale` 处理等优势之间进行权衡。
如果需要 I/O 性能的话，你几乎总能做到比 `printf()` 更好。
`gets()`，使用 `%s` 的 `scanf()`，和使用 `%s` 的 `printf()` 在安全性方面冒风险（容易遭受缓冲区溢出问题而且通常很易错）。 C11 定义了一些“可选扩展”，它们对其实参进行一些额外检查。 如果您的 C 程序库中包含 `gets_s()`、`scanf_s()` 和 `printf_s()`，它们也许是更安全的替代方案，但仍然并非是类型安全的。
可选地标记 `<cstdio>` 和 `<stdio.h>`。
### SL.io.10: 除非你使用了 `printf` 族函数，否则要调用 `ios_base::sync_with_stdio(false)`
`iostreams` 和 `printf` 风格的 I/O 之间的同步是由代价的。 `cin` 和 `cout` 默认是与 `printf` 相同步的。
```cpp
int main()
{
    ios_base::sync_with_stdio(false);
    // ... 使用 iostreams ...
}
```
### SL.io.50: 避免使用 `endl`
`endl` 操纵符大致相当于 `'\n'` 和 `"\n"`； 其最常用的情况只不过会以添加多余的 `flush()` 的方式拖慢程序。 与 `printf` 式输出相比，这种拖慢程度是比较显著的。
```cpp
cout << "Hello, World!" << endl;    // 两次输出操作和一次 flush
cout << "hello, World!\n";          // 一次输出操作且没有 flush
```
## SL.C: The C Standard Library
### SL.C.1: 请勿使用 setjmp/longjmp
`longjmp` 会忽略析构函数，由此使得依赖于 RAII 的所有资源管理策略全部失效。
标记出现的所有 `longjmp` 和 `setjmp`
# A: Architectural ideas
### A.1: 分离稳定的代码和不稳定的代码
对较不稳定的代码进行隔离，有助于其单元测试，接口改进，重构，以及最终弃用。
### A.2: 将潜在可复用的部分作为程序库
程序库是一些共同进行维护，文档化，并发布的声明式和定义式的集合体。 程序库可以是一组头文件（“仅有头文件的程序库”），或者一组头文件加上一组目标文件构成。 你可以静态或动态地将程序库连接到程序中，或者你还可以 `#included` 仅头文件的库。
### A.4: 程序库之间不能有循环依赖
- 循环依赖导致构建过程变得复杂。
- 循环依赖难于理解，可能会引入不确定性（未定义行为）。
一个程序库可以在它的组件的定义之间包含循环引用。
不过，程序库不能对依赖于它的其他程序库产生依赖。
# NR: Non-Rules and myths
### NR.1: 请勿坚持认为声明都应当放在函数的最上面
“所有声明都在开头”的规则，是来自不允许在语句之后对变量和常量进行初始化的老编程语言的遗产。 这样做会导致更长的程序，以及更多由于未初始化的或者错误初始化的变量所导致的错误。
```cpp
int use(int x)
{
    int i;
    char c;
    double d;

    // ... 做一些事 ...

    if (x < i) {
        // ...
        i = f(x, d);
    }
    if (i < x) {
        // ...
        i = g(x, c);
    }
    return i;
}
```
未初始化变量和其使用点的距离越长，出现 BUG 的机会就越大。 幸运的是，编译器可以发现许多“设值前使用”的错误。 不幸的是，编译器无法捕捉到所有这样的错误，而且一些 BUG 并不都像这个小例子中的这样容易发现。
### NR.2: 请勿坚持使函数中只保留一个 `return` 语句
单返回规则会导致不必要地复杂的代码，并引入多余的状态变量。 特别是，单返回规则导致更难在函数开头集中进行错误检查。
- 保持函数短小简单。
- 随意使用多个 `return` 语句（以及抛出异常）。
### NR.3: 请勿避免使用异常
一般有四种主要的不用异常的理由：
- 异常是低效的
- 异常会导致泄漏和错误
- 异常的性能无法预测
- 异常处理的运行时支持耗费过多空间
我们没有能够满足所有人的解决这个问题的办法。 无论如何，针对异常的讨论已经持续了四十多年了。 一些语言没有异常就无法使用，而另一些并不支持异常。 这在使用和不使用异常的方面都造成了强大的传统，并导致激烈的争论。
不过，我们可以简要说明，为什么我们认为对于通用编程以及这里的指导方针的情况来说， 异常是最佳的候选方案。 简单的论据，无论支持还是反对，都是缺乏说服力的。 确实存在一些特殊的应用，其中异常就是不合适的。 （例如，硬实时系统，且缺乏可靠的对于异常处理的耗费进行估计的支持）。
我们依次来考虑针对异常的主要反对观点：
- 异常是低效的： 和什么相比？ 当进行比较时，请确保处理了同样的错误集合，并且它们都进行了等价的处理。 尤其是，不要对一个见到异常就立刻终止的程序和一个在记录错误日志之前 小心地进行资源清理的程序之间进行比较。 确实，某些系统的异常处理实现很糟糕；有时候，这样的实现迫使我们使用 其他错误处理方案，但这并不是异常的基本问题。 当使用某个有效的论据时——无论什么样的上下文——请小心你能拿出确实提供了所讨论的问题的 内部情况的健全的数据。
- 异常会导致泄漏和错误。 不会。 如果你的程序是一大堆乱糟糟的指针而没有总体的资源管理策略， 那么无论你干什么都会有问题。 如果你的系统是由上百万行这样的代码构成的， 那你可能是无法使用异常的， 不过这是一个有关过度和放纵的使用指针的问题，而不是异常的问题。 我们的观点是，你需要用 RAII 来让基于异常的错误处理变得简单且安全——比其他方案都要更简单和安全。
- 异常的性能无法预测。 如果你是在硬实时系统上，而你必须确保一个任务要在给定的时间内完成， 你需要一些工具来支撑这样的保证。 就我们所知，还没有出现这样的工具（至少对大多数程序员没有）。
- 异常处理的运行时支持耗费过多空间。 小型（通常为嵌入式）系统中可能如此。 不过在放弃异常之前，请考虑采用统一的利用错误码的错误处理将耗费的空间有多少， 以及错误未被捕获将造成的损失由多少。
许多（可能是大多数）的和异常有关的问题都源自于需要和杂乱的老代码进行交互的历史性原因。
而支持使用异常的基本论点是：
- 它们把错误返回和普通返回进行了清晰的区分
- 它们无法被忘记或忽略
- 它们可以系统化地使用
请记住
- 异常是用于报告错误的（C++ 中；其他语言可能有异常的不同用法）。
- 异常不是用于可以局部处理的错误的。
- 不要试图在每个函数中捕获每一种异常（这样做是冗长的，臃肿的，而且会导致代码缓慢）。
- 异常不是用于那些当发生无法恢复的错误之后需要立即终止模块或系统的错误的。
### NR.4: 请勿坚持把每个类定义放在其自己的源文件中
将每个类都放进其自己的文件所导致的文件数量难于管理，并会拖慢编译过程。 单个的类很少是一种良好的维护和发布的逻辑单位。
- 使用命名空间来包含逻辑上聚合的类和函数。
### NR.5: 请勿采用两阶段初始化
将初始化拆分为两步会导致不变式的弱化， 更复杂的代码（必须处理半构造对象）， 以及错误（当未能一致地正确处理半构造对象时）。
```cpp
// 老式传统风格：有许多问题

class Picture
{
    int mx;
    int my;
    int * data;
public:
    // 主要问题：构造函数未进行完全构造
    Picture(int x, int y)
    {
        mx = x;         // 也不好：在构造函数体中而非
                        // 成员初始化式中进行赋值
        my = y;
        data = nullptr; // 也不好：在构造函数中而非
                        // 成员初始化式中进行常量初始化
    }

    ~Picture()
    {
        Cleanup();
    }

    // ...

    // 不好：两阶段初始化
    bool Init()
    {
        // 不变式检查
        if (mx <= 0 || my <= 0) {
            return false;
        }
        if (data) {
            return false;
        }
        data = (int*) malloc(mx*my*sizeof(int));   // 也不好：拥有原始指针，还用了 malloc
        return data != nullptr;
    }

    // 也不好：没有理由让清理操作作为单独的函数
    void Cleanup()
    {
        if (data) free(data);
        data = nullptr;
    }
};

Picture picture(100, 0); // 此时 picture 尚未就绪可用
// 这里将失败
if (!picture.Init()) {
    puts("Error, invalid picture");
}
// 现在有一个无效的 picture 对象实例。
```
```cpp
class Picture
{
    int mx;
    int my;
    vector<int> data;

    static int check_size(int size)
    {
        // 不变式检查
        Expects(size > 0);
        return size;
    }

public:
    // 更好的方式是以一个 2D 的 Size 类作为单个形参
    Picture(int x, int y)
        : mx(check_size(x))
        , my(check_size(y))
        // 现在已知 x 和 y 为有效的大小
        , data(mx * my) // 出错时将抛出 std::bad_alloc
    {
        // 图片就绪可用
    }

    // 编译器生成的析构函数会完成工作。（另见 C.21）

    // ...
};

Picture picture1(100, 100);
// picture1 已就绪可用……

// y 并非有效大小值，
// 缺省的契约违规行为将会调用 std::terminate
Picture picture2(100, 0);
// 不会抵达这里……
```
- 始终在构造函数中建立类不变式。
- 不要在需要对象之前就定义它。
### NR.6: 请勿把所有清理操作放在函数末尾并使用 `goto exit`
`goto` 是易错的。 这种技巧是进行 RAII 式的资源和错误处理的前异常时代的技巧。
### NR.7: 请勿使数据成员为 `protected`
`protected` 数据是一种错误来源。 `protected` 数据可以被各种地方的无界限数量的代码所操纵。 `protected` 数据是在类层次中等价于全局对象的东西。
# NL: Naming and layout suggestions
### NL.1: 不要在代码注释中说明可以由代码来清晰表达的东西
编译器不会读注释。 注释没有代码那么精确。 注释不会像代码那样进行一致地更新。
```cpp
auto x = m * v1 + vv;   // 将 m 乘以 v1 并将其结果加上 vv
```
### NL.2: 在代码注释中说明意图
代码表示的是做了什么，而不是想要做成什么。通常来说意图比实现能够更清晰简明地进行说明。
```cpp
void stable_sort(Sortable& c)
    // 对 c 根据由 < 决定的顺序进行排序，保持相等元素（由 == 定义）的
    // 原始相对顺序
{
    // ... 相当多的不平常的代码行 ...
}
```
如果代码注释和代码有冲突，则它们都可能是错的。
### NL.3: 保持代码注释简明干脆
冗长啰嗦会拖慢理解速度，而且到处散布在代码文件里也会让代码难于阅读。
使用明白易懂的英文。 也许我可以流利使用丹麦语，但大多数程序员不行；我的代码的维护者也不行。 避免使用网络用语，注意你的文法，标点，以及大小写。 目标是专业性，而不是“够酷”。
### NL.4: 保持一种统一的缩进风格
可读性。避免“微妙的错误”。
使用一种工具。
### NL.5: 避免在名字中编码类型信息
当名字反映类型而不是功能时，它将变得难于为提供其功能而改变其所使用的类型。 而且，当改变变量的类型时，使用它的代码也得修改。 最小化无意进行的转换。
```cpp
void print_int(int i);
void print_string(const char*);

print_int(1);          // 重复，人工进行类型匹配
print_string("xyzzy"); // 重复，人工进行类型匹配
```
```cpp
void print(int i);
void print(string_view);    // 对任意字符串式的序列都能工作

print(1);              // 简洁，自动类型匹配
print("xyzzy");        // 简洁，自动类型匹配
```
在无类型语言中曾经采用过像匈牙利记法这样的技巧来在名字中编码类型，但在像 C++ 这样的强静态类型语言中，这通常是不必要而且实际上是有害的，因为这些标注会过时（这些累赘和注释类似，而且和它们一样会烂掉），而且它们干扰了语言的恰当用法（应当代之以使用相同的名字和重载决议）。
### NL.7: 使名字的长度大约正比于其作用域的长度
作用域越大，搞混的机会和意外的名字冲突的机会就越大。
```cpp
double sqrt(double x);   // 返回 x 的平方根；x 必须是非负数

int length(const char* p);  // 返回零结尾的 C 风格字符串的字符数量

int length_of_string(const char zero_terminated_array_of_char[])    // 不好: 啰嗦

int g;      // 不好: 全局变量具有密秘的名字

int open;   // 不好: 全局变量使用短小且常用的名字
```
为指针使用 `p`，以及为浮点变量使用 `x` 是符合惯例的，在受限的作用域中不会造成混乱。
### NL.8: 使用一种统一的命名风格
命名和命名风格的一致性会提高可读性。
命名风格有好多，当你使用多个程序库时，你无法遵循所有它们不同的命名约定。 应当选用一种“自有风格”，但保持“导入”的程序为其原有风格不变。
### NL.9: 将 `ALL_CAPS`（全大写）仅用于宏的名字
避免在宏和遵循作用域和类型规则的名字之间造成混乱。
- 对带有小写字母的宏进行标记
- 对 `ALL_CAPS` 非宏名字进行标记
### NL.10: 优先采用 `underscore_style`（下划线风格）的名字
用下划线来分隔名字的各部分就是 C 和 C++ 的原始风格，并被用于 C++ 标准库中。
这条规则仅作为当你有选择权时的缺省方案。 通常你是没有什么选择权的，而只能遵循某个已经设立的风格以维持一致性。 对一致性的需要优先于个人喜好。
这个推荐适用于当你没有约束条件或者没有更好的想法时的情况。 经过很多要求给予指导后，添加这个规则。
### NL.11: 使字面量可阅读
用数字分隔符来避免长串的数字
```cpp
auto c = 299'792'458; // m/s2
auto q2 = 0b0000'1111'0000'0000;
auto ss_number = 123'456'7890;
```
需要清晰性时使用字面量后缀
```cpp
auto hello = "Hello!"s; // std::string
auto world = "world";   // C 风格字符串
auto interval = 100ms;  // 使用 <chrono>
```
标记长数字串。麻烦的是“长”的定义；也许应当是 7。
### NL.15: 节制地使用空格
太多的空格会让文本更大更分散。
我们将恰当放置的空白评价为能够明显有助于可读性。但请勿过度。
### NL.16: 使用一种常规的类成员声明次序
一种常规的成员次序会提高可读性。
以如下次序声明类
- 类型：类，枚举，别名（`using`）
- 构造函数，赋值，析构函数
- 函数
- 数据
采用先是 `public`，然后是 `protected`，之后是 `private` 的次序。
### NL.17: 使用从 K&R 衍生出的代码布局
这正是 C 和 C++ 的原始代码布局。它很好地保持了纵向空间。它对不同语言构造（如函数和类）进行了很好的区分。
在 C++ 的语境中，这种风格通常被称为“Stroustrup”。
```cpp
struct Cable {
    int x;
    // ...
};

double foo(int x)
{
    if (0 < x) {
        // ...
    }

    switch (x) {
    case 0:
        // ...
        break;
    case amazing:
        // ...
        break;
    default:
        // ...
        break;
    }

    if (0 < x)
        ++x;

    if (x < 0)
        something();
    else
        something_else();

    return some_value;
}
```
注意 `if` 和 `(` 之间有一个空格
每个语句，`if` 的分支，以及 `for` 的代码体都使用单独的代码行。
`class` 和 `struct` 的 `{` 并不在单独的代码行上，但函数的 `{` 在单独的代码行上。
对你自定义的类型的名字进行首字母大写，以将其与标准库类型相区分。
不要对函数名大写。
如果想要强制实施的话，请使用某个 IDE 进行格式化。
### NL.18: 使用 C++ 风格的声明符布局
C 风格的布局强调其在表达式中的用法和文法，而 C++ 风格强调的是类型。 对表达式用法的说辞并不适用于引用。
```cpp
T& operator[](size_t);   // OK
T &operator[](size_t);   // 奇怪
T & operator[](size_t);   // 不确定
```
### NL.19: 避免使用容易误读的名字
可读性。 并非每个人都有能将字符轻易区分开的屏幕和打印机。 我们很容易搞混拼写相似和略微拼错的单词。
```cpp
int oO01lL = 6; // 不好

int splunk = 7;
int splonk = 8; // 不好：splunk 和 splonk 很容易搞混
```
### NL.20: 不要把两个语句放在同一行中
可读性。 当一行里有多个语句时，相当容易忽视某个语句。
```cpp
int x = 7; char* p = 29;    // 请勿如此
int x = 7; f(x);  ++x;      // 请勿如此
```
### NL.21: 每个声明式（仅）声明一个名字
可读性。 最小化声明符语法造成的混乱。
### NL.25: 请勿将 `void` 用作参数类型
这很啰嗦，而且仅在考虑 C 兼容性是才有必要。
```cpp
void f(void);   // 不好

void g();       // 好多了
```
### NL.26: 采用符合惯例的 `const` 写法
更多程序员更加熟悉惯例写法。 大型代码库中的一致性。
```cpp
const int x = 7;    // OK
int const y = 9;    // 不好

const int *const p = nullptr;   // OK, 指向常量 int 的常量指针
int const *const p = nullptr;   // 不好，指向常量 int 的常量指针
```
标记用作类型的后缀的 `const`。
### NL.27: 为代码文件使用后缀 `.cpp`，而对接口文件使用后缀 `.h`
这是一条历史悠久的约定。 不过一致性更加重要，因此如果你的项目用了别的约定的话，应当遵守它。